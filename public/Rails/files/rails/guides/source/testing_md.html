<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>testing.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            testing.md
        </h1>
        <ul class="files">
            <li>rails/guides/source/testing.md</li>
            <li>Last modified: 2013-04-26 19:51:18 +0300</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-A+Guide+to+Testing+Rails+Applications"><a href="../../../../classes/A.html">A</a> Guide to Testing <a href="../../../../classes/Rails.html">Rails</a> Applications</h1>

<p>This guide covers built-in mechanisms offered by <a
href="../../../../classes/Rails.html">Rails</a> to test your application.</p>

<p>After reading this guide, you will know:</p>
<ul><li>
<p><a href="../../../../classes/Rails.html">Rails</a> testing terminology.</p>
</li><li>
<p>How to write unit, functional, and integration tests for your application.</p>
</li><li>
<p>Other popular testing approaches and plugins.</p>
</li></ul>
<hr style="height: 1px">

<h2 id="label-Why+Write+Tests+for+your+Rails+Applications%3F">Why Write Tests for your <a href="../../../../classes/Rails.html">Rails</a> Applications?</h2>

<p><a href="../../../../classes/Rails.html">Rails</a> makes it super easy to
write your tests. It starts by producing skeleton test code while you are
creating your models and controllers.</p>

<p>By simply running your <a href="../../../../classes/Rails.html">Rails</a>
tests you can ensure your code adheres to the desired functionality even
after some major code refactoring.</p>

<p><a href="../../../../classes/Rails.html">Rails</a> tests can also simulate
browser requests and thus you can test your application&#39;s response
without having to test it through your browser.</p>

<h2 id="label-Introduction+to+Testing">Introduction to Testing</h2>

<p>Testing support was woven into the <a
href="../../../../classes/Rails.html">Rails</a> fabric from the beginning.
It wasn&#39;t an “oh! let&#39;s bolt on support for running tests because
they&#39;re new and cool” epiphany. Just about every <a
href="../../../../classes/Rails.html">Rails</a> application interacts
heavily with a database and, as a result, your tests will need a database
to interact with as well. To write efficient tests, you&#39;ll need to
understand how to set up this database and populate it with sample data.</p>

<h3 id="label-The+Test+Environment">The Test Environment</h3>

<p>By default, every <a href="../../../../classes/Rails.html">Rails</a>
application has three environments: development, test, and production. The
database for each one of them is configured in
<code>config/database.yml</code>.</p>

<p><a href="../../../../classes/A.html">A</a> dedicated test database allows
you to set up and interact with test data in isolation. Tests can mangle
test data with confidence, that won&#39;t touch the data in the development
or production databases.</p>

<h3 id="label-Rails+Sets+up+for+Testing+from+the+Word+Go"><a href="../../../../classes/Rails.html">Rails</a> Sets up for Testing from the Word Go</h3>

<p><a href="../../../../classes/Rails.html">Rails</a> creates a
<code>test</code> folder for you as soon as you create a <a
href="../../../../classes/Rails.html">Rails</a> project using <code>rails
new</code> <em>application_name</em>. If you list the contents of this
folder then you shall see:</p>

<pre><code>$ ls -F test

fixtures/  functional/  integration/  test_helper.rb  unit/</code></pre>

<p>The <code>unit</code> directory is meant to hold tests for your models, the
<code>functional</code> directory is meant to hold tests for your
controllers and the <code>integration</code> directory is meant to hold
tests that involve any number of controllers interacting.</p>

<p><a href="../../../../classes/Fixtures.html">Fixtures</a> are a way of
organizing test data; they reside in the <code>fixtures</code> folder.</p>

<p>The <code>test_helper.rb</code> file holds the default configuration for
your tests.</p>

<h3 id="label-The+Low-Down+on+Fixtures">The Low-Down on <a href="../../../../classes/Fixtures.html">Fixtures</a></h3>

<p>For good tests, you&#39;ll need to give some thought to setting up test
data. In <a href="../../../../classes/Rails.html">Rails</a>, you can handle
this by defining and customizing fixtures.</p>

<h4 id="label-What+Are+Fixtures%3F">What Are <a href="../../../../classes/Fixtures.html">Fixtures</a>?</h4>

<p><em>Fixtures</em> is a fancy word for sample data. <a
href="../../../../classes/Fixtures.html">Fixtures</a> allow you to populate
your testing database with predefined data before your tests run. <a
href="../../../../classes/Fixtures.html">Fixtures</a> are database
independent written in YAML. There is one file per model.</p>

<p>You&#39;ll find fixtures under your <code>test/fixtures</code> directory.
When you run <code>rails generate model</code> to create a new model
fixture stubs will be automatically created and placed in this directory.</p>

<h4 id="label-YAML">YAML</h4>

<p>YAML-formatted fixtures are a very human-friendly way to describe your
sample data. These types of fixtures have the <strong>.yml</strong> file
extension (as in <code>users.yml</code>).</p>

<p>Here&#39;s a sample YAML fixture file:</p>

<pre><code># lo &amp; behold!  I am a YAML comment!
david:
 name: David Heinemeier Hansson
 birthday: 1979-10-15
 profession: Systems development

steve:
 name: Steve Ross Kellock
 birthday: 1974-09-27
 profession: guy with keyboard</code></pre>

<p>Each fixture is given a name followed by an indented list of
colon-separated key/value pairs. Records are typically separated by a blank
space. You can place comments in a fixture file by using the # character in
the first column. Keys which resemble YAML keywords such as &#39;yes&#39;
and &#39;no&#39; are quoted so that the YAML Parser correctly interprets
them.</p>

<h4 id="label-ERB%27in+It+Up">ERB&#39;in It Up</h4>

<p><a href="../../../../classes/ERB.html">ERB</a> allows you to embed Ruby
code within templates. The YAML fixture format is pre-processed with <a
href="../../../../classes/ERB.html">ERB</a> when <a
href="../../../../classes/Rails.html">Rails</a> loads fixtures. This allows
you to use Ruby to help you generate some sample data. For example, the
following code generates a thousand users:</p>

<pre><code>&lt;% 1000.times do |n| %&gt;
user_&lt;%= n %&gt;:
  username: &lt;%= &quot;user%03d&quot; % n %&gt;
  email: &lt;%= &quot;user%03d@example.com&quot; % n %&gt;
&lt;% end %&gt;</code></pre>

<h4 id="label-Fixtures+in+Action"><a href="../../../../classes/Fixtures.html">Fixtures</a> in Action</h4>

<p><a href="../../../../classes/Rails.html">Rails</a> by default automatically
loads all fixtures from the <code>test/fixtures</code> folder for your unit
and functional test. Loading involves three steps:</p>
<ul><li>
<p>Remove any existing data from the table corresponding to the fixture</p>
</li><li>
<p>Load the fixture data into the table</p>
</li><li>
<p>Dump the fixture data into a variable in case you want to access it
directly</p>
</li></ul>

<h4 id="label-Fixtures+are+Active+Record+objects"><a href="../../../../classes/Fixtures.html">Fixtures</a> are Active Record objects</h4>

<p><a href="../../../../classes/Fixtures.html">Fixtures</a> are instances of
Active Record. As mentioned in point #3 above, you can access the object
directly because it is automatically setup as a local variable of the test
case. For example:</p>

<pre><code># this will return the User object for the fixture named david
users(:david)

# this will return the property for david called id
users(:david).id

# one can also access methods available on the User class
email(david.girlfriend.email, david.location_tonight)
</code></pre>

<h2 id="label-Unit+Testing+your+Models">Unit Testing your Models</h2>

<p>In <a href="../../../../classes/Rails.html">Rails</a>, unit tests are what
you write to test your models.</p>

<p>For this guide we will be using <a
href="../../../../classes/Rails.html">Rails</a> <em>scaffolding</em>. It
will create the model, a migration, controller and views for the new
resource in a single operation. It will also create a full test suite
following <a href="../../../../classes/Rails.html">Rails</a> best
practices. I will be using examples from this generated code and will be
supplementing it with additional examples where necessary.</p>

<p>NOTE: For more information on <a
href="../../../../classes/Rails.html">Rails</a> <em>scaffolding</em>, refer
to <a href="http://getting_started.html">Getting Started with Rails</a></p>

<p>When you use <code>rails generate scaffold</code>, for a resource among
other things it creates a test stub in the <code>test/models</code> folder:</p>

<pre><code>$ rails generate scaffold post title:string body:text
...
create  app/models/post.rb
create  test/models/post_test.rb
create  test/fixtures/posts.yml
...</code></pre>

<p>The default test stub in <code>test/models/post_test.rb</code> looks like
this:</p>

<pre><code>require &#39;test_helper&#39;

class PostTest &lt; ActiveSupport::TestCase
  # Replace this with your real tests.
  test &quot;the truth&quot; do
    assert true
  end
end
</code></pre>

<p><a href="../../../../classes/A.html">A</a> line by line examination of this
file will help get you oriented to <a
href="../../../../classes/Rails.html">Rails</a> testing code and
terminology.</p>

<pre><code>require &#39;test_helper&#39;
</code></pre>

<p>As you know by now, <code>test_helper.rb</code> specifies the default
configuration to run our tests. This is included with all the tests, so any
methods added to this file are available to all your tests.</p>

<pre><code>class PostTest &lt; ActiveSupport::TestCase
</code></pre>

<p>The <code>PostTest</code> class defines a <em>test case</em> because it
inherits from <code>ActiveSupport::TestCase</code>. <code>PostTest</code>
thus has all the methods available from
<code>ActiveSupport::TestCase</code>. You&#39;ll see those methods a little
later in this guide.</p>

<p>Any method defined within a <code>Test::Unit</code> test case that begins
with <code>test</code> (case sensitive) is simply called a test. So,
<code>test_password</code>, <code>test_valid_password</code> and
<code>testValidPassword</code> all are legal test names and are run
automatically when the test case is run.</p>

<p><a href="../../../../classes/Rails.html">Rails</a> adds a <code>test</code>
method that takes a test name and a block. It generates a normal
<code>Test::Unit</code> test with method names prefixed with
<code>test_</code>. So,</p>

<pre><code>test &quot;the truth&quot; do
  assert true
end
</code></pre>

<p>acts as if you had written</p>

<pre><code>def test_the_truth
  assert true
end
</code></pre>

<p>only the <code>test</code> macro allows a more readable test name. You can
still use regular method definitions though.</p>

<p>NOTE: The method name is generated by replacing spaces with underscores.
The result does not need to be a valid Ruby identifier though, the name may
contain punctuation characters etc. That&#39;s because in Ruby technically
any string may be a method name. Odd ones need <code>define_method</code>
and <code>send</code> calls, but formally there&#39;s no restriction.</p>

<pre><code>assert true
</code></pre>

<p>This line of code is called an <em>assertion</em>. An assertion is a line
of code that evaluates an object (or expression) for expected results. For
example, an assertion can check:</p>
<ul><li>
<p>does this value = that value?</p>
</li><li>
<p>is this object nil?</p>
</li><li>
<p>does this line of code throw an exception?</p>
</li><li>
<p>is the user&#39;s password greater than 5 characters?</p>
</li></ul>

<p>Every test contains one or more assertions. Only when all the assertions
are successful will the test pass.</p>

<h3 id="label-Preparing+your+Application+for+Testing">Preparing your Application for Testing</h3>

<p>Before you can run your tests, you need to ensure that the test database
structure is current. For this you can use the following rake commands:</p>

<pre><code>$ rake db:migrate
...
$ rake db:test:load</code></pre>

<p>The <code>rake db:migrate</code> above runs any pending migrations on the
<em>development</em> environment and updates <code>db/schema.rb</code>. The
<code>rake db:test:load</code> recreates the test database from the current
<code>db/schema.rb</code>. On subsequent attempts, it is a good idea to
first run <code>db:test:prepare</code>, as it first checks for pending
migrations and warns you appropriately.</p>

<p>NOTE: <code>db:test:prepare</code> will fail with an error if
<code>db/schema.rb</code> doesn&#39;t exist.</p>

<h4 id="label-Rake+Tasks+for+Preparing+your+Application+for+Testing">Rake Tasks for Preparing your Application for Testing</h4>

<p>| Tasks | Description | | —————————— | ————————————————————————- | |
<code>rake db:test:clone</code> | Recreate the test database from the
current environment&#39;s database schema | | <code>rake
db:test:clone_structure</code> | Recreate the test database from the
development structure | | <code>rake db:test:load</code> | Recreate the
test database from the current <code>schema.rb</code> | | <code>rake
db:test:prepare</code> | Check for pending migrations and load the test
schema | | <code>rake db:test:purge</code> | Empty the test database. |</p>

<p>TIP: You can see all these rake tasks and their descriptions by running
<code>rake --tasks --describe</code></p>

<h3 id="label-Running+Tests">Running Tests</h3>

<p>Running a test is as simple as invoking the file containing the test cases
through Ruby:</p>

<pre><code>$ ruby -Itest test/models/post_test.rb

Loaded suite models/post_test
Started
.
Finished in 0.023513 seconds.

1 tests, 1 assertions, 0 failures, 0 errors</code></pre>

<p>This will run all the test methods from the test case. Note that
<code>test_helper.rb</code> is in the <code>test</code> directory, hence
this directory needs to be added to the load path using the <code>-I</code>
switch.</p>

<p>You can also run a particular test method from the test case by using the
<code>-n</code> switch with the <code>test method name</code>.</p>

<pre><code>$ ruby -Itest test/models/post_test.rb -n test_the_truth

Loaded suite models/post_test
Started
.
Finished in 0.023513 seconds.

1 tests, 1 assertions, 0 failures, 0 errors</code></pre>

<p>The <code>.</code> (dot) above indicates a passing test. When a test fails
you see an <code>F</code>; when a test throws an error you see an
<code>E</code> in its place. The last line of the output is the summary.</p>

<p>To see how a test failure is reported, you can add a failing test to the
<code>post_test.rb</code> test case.</p>

<pre><code>test &quot;should not save post without title&quot; do
  post = Post.new
  assert !post.save
end
</code></pre>

<p>Let us run this newly added test.</p>

<pre><code>$ ruby unit/post_test.rb -n test_should_not_save_post_without_title
Loaded suite -e
Started
F
Finished in 0.102072 seconds.

  1) Failure:
test_should_not_save_post_without_title(PostTest) [/test/models/post_test.rb:6]:
&lt;false&gt; is not true.

1 tests, 1 assertions, 1 failures, 0 errors</code></pre>

<p>In the output, <code>F</code> denotes a failure. You can see the
corresponding trace shown under <code>1)</code> along with the name of the
failing test. The next few lines contain the stack trace followed by a
message which mentions the actual value and the expected value by the
assertion. The default assertion messages provide just enough information
to help pinpoint the error. To make the assertion failure message more
readable, every assertion provides an optional message parameter, as shown
here:</p>

<pre><code>test &quot;should not save post without title&quot; do
  post = Post.new
  assert !post.save, &quot;Saved the post without a title&quot;
end
</code></pre>

<p>Running this test shows the friendlier assertion message:</p>

<pre><code>1) Failure:
test_should_not_save_post_without_title(PostTest) [/test/models/post_test.rb:6]:
Saved the post without a title.
&lt;false&gt; is not true.</code></pre>

<p>Now to get this test to pass we can add a model level validation for the
<em>title</em> field.</p>

<pre><code>class Post &lt; ActiveRecord::Base
  validates :title, presence: true
end
</code></pre>

<p>Now the test should pass. Let us verify by running the test again:</p>

<pre><code>$ ruby unit/post_test.rb -n test_should_not_save_post_without_title
Loaded suite unit/post_test
Started
.
Finished in 0.193608 seconds.

1 tests, 1 assertions, 0 failures, 0 errors</code></pre>

<p>Now, if you noticed, we first wrote a test which fails for a desired
functionality, then we wrote some code which adds the functionality and
finally we ensured that our test passes. This approach to software
development is referred to as <em>Test-Driven Development</em> (TDD).</p>

<p>TIP: Many <a href="../../../../classes/Rails.html">Rails</a> developers
practice <em>Test-Driven Development</em> (TDD). This is an excellent way
to build up a test suite that exercises every part of your application. TDD
is beyond the scope of this guide, but one place to start is with <a
href="http://andrzejonsoftware.blogspot.com/2007/05/15-tdd-steps-to-create-rails.html">15
TDD steps to create a Rails application</a>.</p>

<p>To see how an error gets reported, here&#39;s a test containing an error:</p>

<pre><code>test &quot;should report error&quot; do
  # some_undefined_variable is not defined elsewhere in the test case
  some_undefined_variable
  assert true
end
</code></pre>

<p>Now you can see even more output in the console from running the tests:</p>

<pre><code>$ ruby unit/post_test.rb -n test_should_report_error
Loaded suite -e
Started
E
Finished in 0.082603 seconds.

  1) Error:
test_should_report_error(PostTest):
NameError: undefined local variable or method `some_undefined_variable&#39; for #&lt;PostTest:0x249d354&gt;
    /test/models/post_test.rb:6:in `test_should_report_error&#39;

1 tests, 0 assertions, 0 failures, 1 errors</code></pre>

<p>Notice the &#39;E&#39; in the output. It denotes a test with error.</p>

<p>NOTE: The execution of each test method stops as soon as any error or an
assertion failure is encountered, and the test suite continues with the
next method. All test methods are executed in alphabetical order.</p>

<h3 id="label-What+to+Include+in+Your+Unit+Tests">What to Include in Your Unit Tests</h3>

<p>Ideally, you would like to include a test for everything which could
possibly break. It&#39;s a good practice to have at least one test for each
of your validations and at least one test for every method in your model.</p>

<h3 id="label-Assertions+Available">Assertions Available</h3>

<p>By now you&#39;ve caught a glimpse of some of the assertions that are
available. Assertions are the worker bees of testing. They are the ones
that actually perform the checks to ensure that things are going as
planned.</p>

<p>There are a bunch of different types of assertions you can use. Here&#39;s
the complete list of assertions that ship with <code>test/unit</code>, the
default testing library used by <a
href="../../../../classes/Rails.html">Rails</a>. The <code>[msg]</code>
parameter is an optional string message you can specify to make your test
failure messages clearer. It&#39;s not required.</p>

<p>| Assertion | Purpose | | —————————————————————- | ——- | | <code>assert(
boolean, [msg] )</code> | Ensures that the object/expression is true.| |
<code>assert_equal( expected, actual, [msg] )</code> | Ensures that
<code>expected == actual</code> is true.| | <code>assert_not_equal(
expected, actual, [msg] )</code> | Ensures that <code>expected !=
actual</code> is true.| | <code>assert_same( expected, actual, [msg]
)</code> | Ensures that <code>expected.equal?(actual)</code> is true.| |
<code>assert_not_same( expected, actual, [msg] )</code> | Ensures that
<code>!expected.equal?(actual)</code> is true.| | <code>assert_nil( obj,
[msg] )</code> | Ensures that <code>obj.nil?</code> is true.| |
<code>assert_not_nil( obj, [msg] )</code> | Ensures that
<code>!obj.nil?</code> is true.| | <code>assert_match( regexp, string,
[msg] )</code> | Ensures that a string matches the regular expression.| |
<code>assert_no_match( regexp, string, [msg] )</code> | Ensures that a
string doesn&#39;t match the regular expression.| | <code>assert_in_delta(
expecting, actual, delta, [msg] )</code> | Ensures that the numbers
<code>expecting</code> and <code>actual</code> are within
<code>delta</code> of each other.| | <code>assert_throws( symbol, [msg] ) {
block }</code> | Ensures that the given block throws the symbol.| |
<code>assert_raise( exception1, exception2, ... ) { block }</code> |
Ensures that the given block raises one of the given exceptions.| |
<code>assert_nothing_raised( exception1, exception2, ... ) { block }</code>
| Ensures that the given block doesn&#39;t raise one of the given
exceptions.| | <code>assert_instance_of( class, obj, [msg] )</code> |
Ensures that <code>obj</code> is of the <code>class</code> type.| |
<code>assert_kind_of( class, obj, [msg] )</code> | Ensures that
<code>obj</code> is or descends from <code>class</code>.| |
<code>assert_respond_to( obj, symbol, [msg] )</code> | Ensures that
<code>obj</code> has a method called <code>symbol</code>.| |
<code>assert_operator( obj1, operator, obj2, [msg] )</code> | Ensures that
<code>obj1.operator(obj2)</code> is true.| | <code>assert_send( array,
[msg] )</code> | Ensures that executing the method listed in
<code>array[1]</code> on the object in <code>array[0]</code> with the
parameters of <code>array[2 and up]</code> is true. This one is weird eh?|
| <code>flunk( [msg] )</code> | Ensures failure. This is useful to
explicitly mark a test that isn&#39;t finished yet.|</p>

<p>Because of the modular nature of the testing framework, it is possible to
create your own assertions. In fact, that&#39;s exactly what <a
href="../../../../classes/Rails.html">Rails</a> does. It includes some
specialized assertions to make your life easier.</p>

<p>NOTE: Creating your own assertions is an advanced topic that we won&#39;t
cover in this tutorial.</p>

<h3 id="label-Rails+Specific+Assertions"><a href="../../../../classes/Rails.html">Rails</a> Specific Assertions</h3>

<p><a href="../../../../classes/Rails.html">Rails</a> adds some custom
assertions of its own to the <code>test/unit</code> framework:</p>

<p>| Assertion | Purpose | | ——————————————————————————— | ——- | |
<code>assert_difference(expressions, difference = 1, message = nil)
{...}</code> | Test numeric difference between the return value of an
expression as a result of what is evaluated in the yielded block.| |
<code>assert_no_difference(expressions, message = nil,
&amp;amp;block)</code> | Asserts that the numeric result of evaluating an
expression is not changed before and after invoking the passed in block.| |
<code>assert_recognizes(expected_options, path, extras={},
message=nil)</code> | Asserts that the routing of the given path was
handled correctly and that the parsed options (given in the
expected_options hash) match path. Basically, it asserts that <a
href="../../../../classes/Rails.html">Rails</a> recognizes the route given
by expected_options.| | <code>assert_generates(expected_path, options,
defaults={}, extras = {}, message=nil)</code> | Asserts that the provided
options can be used to generate the provided path. This is the inverse of
assert_recognizes. The extras parameter is used to tell the request the
names and values of additional request parameters that would be in a query
string. The message parameter allows you to specify a custom error message
for assertion failures.| | <code>assert_response(type, message =
nil)</code> | Asserts that the response comes with a specific status code.
You can specify <code>:success</code> to indicate 200-299,
<code>:redirect</code> to indicate 300-399, <code>:missing</code> to
indicate 404, or <code>:error</code> to match the 500-599 range| |
<code>assert_redirected_to(options = {}, message=nil)</code> | Assert that
the redirection options passed in match those of the redirect called in the
latest action. This match can be partial, such that
<code>assert_redirected_to(controller: &quot;weblog&quot;)</code> will also
match the redirection of <code>redirect_to(controller: &quot;weblog&quot;,
action: &quot;show&quot;)</code> and so on.| |
<code>assert_template(expected = nil, message=nil)</code> | Asserts that
the request was rendered with the appropriate template file.|</p>

<p>You&#39;ll see the usage of some of these assertions in the next chapter.</p>

<h2 id="label-Functional+Tests+for+Your+Controllers">Functional Tests for Your Controllers</h2>

<p>In <a href="../../../../classes/Rails.html">Rails</a>, testing the various
actions of a single controller is called writing functional tests for that
controller. Controllers handle the incoming web requests to your
application and eventually respond with a rendered view.</p>

<h3 id="label-What+to+Include+in+your+Functional+Tests">What to Include in your Functional Tests</h3>

<p>You should test for things such as:</p>
<ul><li>
<p>was the web request successful?</p>
</li><li>
<p>was the user redirected to the right page?</p>
</li><li>
<p>was the user successfully authenticated?</p>
</li><li>
<p>was the correct object stored in the response template?</p>
</li><li>
<p>was the appropriate message displayed to the user in the view?</p>
</li></ul>

<p>Now that we have used <a href="../../../../classes/Rails.html">Rails</a>
scaffold generator for our <code>Post</code> resource, it has already
created the controller code and tests. You can take look at the file
<code>posts_controller_test.rb</code> in the <code>test/controllers</code>
directory.</p>

<p>Let me take you through one such test, <code>test_should_get_index</code>
from the file <code>posts_controller_test.rb</code>.</p>

<pre><code>test &quot;should get index&quot; do
  get :index
  assert_response :success
  assert_not_nil assigns(:posts)
end
</code></pre>

<p>In the <code>test_should_get_index</code> test, <a
href="../../../../classes/Rails.html">Rails</a> simulates a request on the
action called <code>index</code>, making sure the request was successful
and also ensuring that it assigns a valid <code>posts</code> instance
variable.</p>

<p>The <code>get</code> method kicks off the web request and populates the
results into the response. It accepts 4 arguments:</p>
<ul><li>
<p>The action of the controller you are requesting. This can be in the form of
a string or a symbol.</p>
</li><li>
<p>An optional hash of request parameters to pass into the action (eg. query
string parameters or post variables).</p>
</li><li>
<p>An optional hash of session variables to pass along with the request.</p>
</li><li>
<p>An optional hash of flash values.</p>
</li></ul>

<p>Example: Calling the <code>:show</code> action, passing an <code>id</code>
of 12 as the <code>params</code> and setting a <code>user_id</code> of 5 in
the session:</p>

<pre><code>get(:show, {&#39;id&#39; =&gt; &quot;12&quot;}, {&#39;user_id&#39; =&gt; 5})
</code></pre>

<p><a href="../../../../classes/Another.html">Another</a> example: Calling the
<code>:view</code> action, passing an <code>id</code> of 12 as the
<code>params</code>, this time with no session, but with a flash message.</p>

<pre><code>get(:view, {&#39;id&#39; =&gt; &#39;12&#39;}, nil, {&#39;message&#39; =&gt; &#39;booya!&#39;})
</code></pre>

<p>NOTE: If you try running <code>test_should_create_post</code> test from
<code>posts_controller_test.rb</code> it will fail on account of the newly
added model level validation and rightly so.</p>

<p>Let us modify <code>test_should_create_post</code> test in
<code>posts_controller_test.rb</code> so that all our test pass:</p>

<pre><code>test &quot;should create post&quot; do
  assert_difference(&#39;Post.count&#39;) do
    post :create, post: {title: &#39;Some title&#39;}
  end

  assert_redirected_to post_path(assigns(:post))
end
</code></pre>

<p>Now you can try running all the tests and they should pass.</p>

<h3 id="label-Available+Request+Types+for+Functional+Tests">Available Request Types for Functional Tests</h3>

<p>If you&#39;re familiar with the HTTP protocol, you&#39;ll know that
<code>get</code> is a type of request. There are 6 request types supported
in <a href="../../../../classes/Rails.html">Rails</a> functional tests:</p>
<ul><li>
<p><code>get</code></p>
</li><li>
<p><code>post</code></p>
</li><li>
<p><code>patch</code></p>
</li><li>
<p><code>put</code></p>
</li><li>
<p><code>head</code></p>
</li><li>
<p><code>delete</code></p>
</li></ul>

<p>All of request types are methods that you can use, however, you&#39;ll
probably end up using the first two more often than the others.</p>

<p>NOTE: Functional tests do not verify whether the specified request type
should be accepted by the action. Request types in this context exist to
make your tests more descriptive.</p>

<h3 id="label-The+Four+Hashes+of+the+Apocalypse">The Four Hashes of the Apocalypse</h3>

<p>After a request has been made by using one of the 5 methods
(<code>get</code>, <code>post</code>, etc.) and processed, you will have 4
<a href="../../../../classes/Hash.html">Hash</a> objects ready for use:</p>
<ul><li>
<p><code>assigns</code> - Any objects that are stored as instance variables in
actions for use in views.</p>
</li><li>
<p><code>cookies</code> - Any cookies that are set.</p>
</li><li>
<p><code>flash</code> - Any objects living in the flash.</p>
</li><li>
<p><code>session</code> - Any object living in session variables.</p>
</li></ul>

<p>As is the case with normal <a href="../../../../classes/Hash.html">Hash</a>
objects, you can access the values by referencing the keys by string. You
can also reference them by symbol name, except for <code>assigns</code>.
For example:</p>

<pre><code>flash[&quot;gordon&quot;]               flash[:gordon]
session[&quot;shmession&quot;]          session[:shmession]
cookies[&quot;are_good_for_u&quot;]     cookies[:are_good_for_u]

# Because you can&#39;t use assigns[:something] for historical reasons:
assigns[&quot;something&quot;]          assigns(:something)
</code></pre>

<h3 id="label-Instance+Variables+Available">Instance Variables Available</h3>

<p>You also have access to three instance variables in your functional tests:</p>
<ul><li>
<p><code>@controller</code> - The controller processing the request</p>
</li><li>
<p><code>@request</code> - The request</p>
</li><li>
<p><code>@response</code> - The response</p>
</li></ul>

<h3 id="label-Testing+Templates+and+Layouts">Testing Templates and Layouts</h3>

<p>If you want to make sure that the response rendered the correct template
and layout, you can use the <code>assert_template</code> method:</p>

<pre><code>test &quot;index should render correct template and layout&quot; do
  get :index
  assert_template :index
  assert_template layout: &quot;layouts/application&quot;
end
</code></pre>

<p>Note that you cannot test for template and layout at the same time, with
one call to <code>assert_template</code> method. Also, for the
<code>layout</code> test, you can give a regular expression instead of a
string, but using the string, makes things clearer. On the other hand, you
have to include the “layouts” directory name even if you save your layout
file in this standard layout directory. Hence,</p>

<pre><code>assert_template layout: &quot;application&quot;
</code></pre>

<p>will not work.</p>

<p>If your view renders any partial, when asserting for the layout, you have
to assert for the partial at the same time. Otherwise, assertion will fail.</p>

<p>Hence:</p>

<pre><code>test &quot;new should render correct layout&quot; do
  get :new
  assert_template layout: &quot;layouts/application&quot;, partial: &quot;_form&quot;
end
</code></pre>

<p>is the correct way to assert for the layout when the view renders a partial
with name <code>_form</code>. Omitting the <code>:partial</code> key in
your <code>assert_template</code> call will complain.</p>

<h3 id="label-A+Fuller+Functional+Test+Example"><a href="../../../../classes/A.html">A</a> Fuller Functional Test Example</h3>

<p>Here&#39;s another example that uses <code>flash</code>,
<code>assert_redirected_to</code>, and <code>assert_difference</code>:</p>

<pre><code>test &quot;should create post&quot; do
  assert_difference(&#39;Post.count&#39;) do
    post :create, post: {title: &#39;Hi&#39;, body: &#39;This is my first post.&#39;}
  end
  assert_redirected_to post_path(assigns(:post))
  assert_equal &#39;Post was successfully created.&#39;, flash[:notice]
end
</code></pre>

<h3 id="label-Testing+Views">Testing Views</h3>

<p>Testing the response to your request by asserting the presence of key <a
href="../../../../classes/HTML.html">HTML</a> elements and their content is
a useful way to test the views of your application. The
<code>assert_select</code> assertion allows you to do this by using a
simple yet powerful syntax.</p>

<p>NOTE: You may find references to <code>assert_tag</code> in other
documentation, but this is now deprecated in favor of
<code>assert_select</code>.</p>

<p>There are two forms of <code>assert_select</code>:</p>

<p><code>assert_select(selector, [equality], [message])</code> ensures that
the equality condition is met on the selected elements through the
selector. The selector may be a CSS selector expression (String), an
expression with substitution values, or an <code>HTML::Selector</code>
object.</p>

<p><code>assert_select(element, selector, [equality], [message])</code>
ensures that the equality condition is met on all the selected elements
through the selector starting from the <em>element</em> (instance of
<code>HTML::Node</code>) and its descendants.</p>

<p>For example, you could verify the contents on the title element in your
response with:</p>

<pre><code>assert_select &#39;title&#39;, &quot;Welcome to Rails Testing Guide&quot;
</code></pre>

<p>You can also use nested <code>assert_select</code> blocks. In this case the
inner <code>assert_select</code> runs the assertion on the complete
collection of elements selected by the outer <code>assert_select</code>
block:</p>

<pre><code>assert_select &#39;ul.navigation&#39; do
  assert_select &#39;li.menu_item&#39;
end
</code></pre>

<p>Alternatively the collection of elements selected by the outer
<code>assert_select</code> may be iterated through so that
<code>assert_select</code> may be called separately for each element.
Suppose for example that the response contains two ordered lists, each with
four list elements then the following tests will both pass.</p>

<pre><code>assert_select &quot;ol&quot; do |elements|
  elements.each do |element|
    assert_select element, &quot;li&quot;, 4
  end
end

assert_select &quot;ol&quot; do
  assert_select &quot;li&quot;, 8
end
</code></pre>

<p>The <code>assert_select</code> assertion is quite powerful. For more
advanced usage, refer to its <a
href="http://api.rubyonrails.org/classes/ActionDispatch/Assertions/SelectorAssertions.html">documentation</a>.</p>

<h4 id="label-Additional+View-Based+Assertions">Additional View-Based Assertions</h4>

<p>There are more assertions that are primarily used in testing views:</p>

<p>| Assertion | Purpose | | ———————————————————- | ——- | |
<code>assert_select_email</code> | Allows you to make assertions on the
body of an e-mail. | | <code>assert_select_encoded</code> | Allows you to
make assertions on encoded <a
href="../../../../classes/HTML.html">HTML</a>. It does this by un-encoding
the contents of each element and then calling the block with all the
un-encoded elements.| | <code>css_select(selector)</code> or
<code>css_select(element, selector)</code> | Returns an array of all the
elements selected by the <em>selector</em>. In the second variant it first
matches the base <em>element</em> and tries to match the <em>selector</em>
expression on any of its children. If there are no matches both variants
return an empty array.|</p>

<p>Here&#39;s an example of using <code>assert_select_email</code>:</p>

<pre><code>assert_select_email do
  assert_select &#39;small&#39;, &#39;Please click the &quot;Unsubscribe&quot; link if you want to opt-out.&#39;
end
</code></pre>

<h2 id="label-Integration+Testing">Integration Testing</h2>

<p>Integration tests are used to test the interaction among any number of
controllers. They are generally used to test important work flows within
your application.</p>

<p>Unlike Unit and Functional tests, integration tests have to be explicitly
created under the &#39;test/integration&#39; folder within your
application. <a href="../../../../classes/Rails.html">Rails</a> provides a
generator to create an integration test skeleton for you.</p>

<pre><code>$ rails generate integration_test user_flows
      exists  test/integration/
      create  test/integration/user_flows_test.rb</code></pre>

<p>Here&#39;s what a freshly-generated integration test looks like:</p>

<pre><code>require &#39;test_helper&#39;

class UserFlowsTest &lt; ActionDispatch::IntegrationTest
  fixtures :all

  # Replace this with your real tests.
  test &quot;the truth&quot; do
    assert true
  end
end
</code></pre>

<p>Integration tests inherit from
<code>ActionDispatch::IntegrationTest</code>. This makes available some
additional helpers to use in your integration tests. Also you need to
explicitly include the fixtures to be made available to the test.</p>

<h3 id="label-Helpers+Available+for+Integration+Tests">Helpers Available for Integration Tests</h3>

<p>In addition to the standard testing helpers, there are some additional
helpers available to integration tests:</p>

<p>| Helper | Purpose | | —————————————————————— | ——- | | <code>https?</code>
| Returns <code>true</code> if the session is mimicking a secure HTTPS
request.| | <code>https!</code> | Allows you to mimic a secure HTTPS
request.| | <code>host!</code> | Allows you to set the host name to use in
the next request.| | <code>redirect?</code> | Returns <code>true</code> if
the last request was a redirect.| | <code>follow_redirect!</code> | Follows
a single redirect response.| | <code>request_via_redirect(http_method,
path, [parameters], [headers])</code> | Allows you to make an HTTP request
and follow any subsequent redirects.| | <code>post_via_redirect(path,
[parameters], [headers])</code> | Allows you to make an HTTP POST request
and follow any subsequent redirects.| | <code>get_via_redirect(path,
[parameters], [headers])</code> | Allows you to make an HTTP GET request
and follow any subsequent redirects.| | <code>patch_via_redirect(path,
[parameters], [headers])</code> | Allows you to make an HTTP PATCH request
and follow any subsequent redirects.| | <code>put_via_redirect(path,
[parameters], [headers])</code> | Allows you to make an HTTP PUT request
and follow any subsequent redirects.| | <code>delete_via_redirect(path,
[parameters], [headers])</code> | Allows you to make an HTTP DELETE request
and follow any subsequent redirects.| | <code>open_session</code> | Opens a
new session instance.|</p>

<h3 id="label-Integration+Testing+Examples">Integration Testing Examples</h3>

<p><a href="../../../../classes/A.html">A</a> simple integration test that
exercises multiple controllers:</p>

<pre><code>require &#39;test_helper&#39;

class UserFlowsTest &lt; ActionDispatch::IntegrationTest
  fixtures :users

  test &quot;login and browse site&quot; do
    # login via https
    https!
    get &quot;/login&quot;
    assert_response :success

    post_via_redirect &quot;/login&quot;, username: users(:avs).username, password: users(:avs).password
    assert_equal &#39;/welcome&#39;, path
    assert_equal &#39;Welcome avs!&#39;, flash[:notice]

    https!(false)
    get &quot;/posts/all&quot;
    assert_response :success
    assert assigns(:products)
  end
end
</code></pre>

<p>As you can see the integration test involves multiple controllers and
exercises the entire stack from database to dispatcher. In addition you can
have multiple session instances open simultaneously in a test and extend
those instances with assertion methods to create a very powerful testing
DSL (domain-specific language) just for your application.</p>

<p>Here&#39;s an example of multiple sessions and custom DSL in an integration
test</p>

<pre><code>require &#39;test_helper&#39;

class UserFlowsTest &lt; ActionDispatch::IntegrationTest
  fixtures :users

  test &quot;login and browse site&quot; do

    # User avs logs in
    avs = login(:avs)
    # User guest logs in
    guest = login(:guest)

    # Both are now available in different sessions
    assert_equal &#39;Welcome avs!&#39;, avs.flash[:notice]
    assert_equal &#39;Welcome guest!&#39;, guest.flash[:notice]

    # User avs can browse site
    avs.browses_site
    # User guest can browse site as well
    guest.browses_site

    # Continue with other assertions
  end

  private

  module CustomDsl
    def browses_site
      get &quot;/products/all&quot;
      assert_response :success
      assert assigns(:products)
    end
  end

  def login(user)
    open_session do |sess|
      sess.extend(CustomDsl)
      u = users(user)
      sess.https!
      sess.post &quot;/login&quot;, username: u.username, password: u.password
      assert_equal &#39;/welcome&#39;, path
      sess.https!(false)
    end
  end
end
</code></pre>

<h2 id="label-Rake+Tasks+for+Running+your+Tests">Rake Tasks for Running your Tests</h2>

<p>You don&#39;t need to set up and run your tests by hand on a test-by-test
basis. <a href="../../../../classes/Rails.html">Rails</a> comes with a
number of rake tasks to help in testing. The table below lists all rake
tasks that come along in the default <a
href="../../Rakefile.html">Rakefile</a> when you initiate a <a
href="../../../../classes/Rails.html">Rails</a> project.</p>

<p>| Tasks | Description | | ——————————- | ———– | | <code>rake test</code> |
Runs all unit, functional and integration tests. You can also simply run
<code>rake</code> as the <em>test</em> target is the default.| | <code>rake
test:controllers</code> | Runs all the controller tests from
<code>test/controllers</code>| | <code>rake test:functionals</code> | Runs
all the functional tests from <code>test/controllers</code>,
<code>test/mailers</code>, and <code>test/functional</code>| | <code>rake
test:helpers</code> | Runs all the helper tests from
<code>test/helpers</code>| | <code>rake test:integration</code> | Runs all
the integration tests from <code>test/integration</code>| | <code>rake
test:mailers</code> | Runs all the mailer tests from
<code>test/mailers</code>| | <code>rake test:models</code> | Runs all the
model tests from <code>test/models</code>| | <code>rake test:recent</code>
| Tests recent changes| | <code>rake test:uncommitted</code> | Runs all the
tests which are uncommitted. Supports Subversion and Git| | <code>rake
test:units</code> | Runs all the unit tests from <code>test/models</code>,
<code>test/helpers</code>, and <code>test/unit</code>|</p>

<h2 id="label-Brief+Note+About+Test%3A%3AUnit">Brief Note About <code>Test::Unit</code></h2>

<p>Ruby ships with a boat load of libraries. Ruby 1.8 provides
<code>Test::Unit</code>, a framework for unit testing in Ruby. All the
basic assertions discussed above are actually defined in
<code>Test::Unit::Assertions</code>. The class
<code>ActiveSupport::TestCase</code> which we have been using in our unit
and functional tests extends <code>Test::Unit::TestCase</code>, allowing us
to use all of the basic assertions in our tests.</p>

<p>Ruby 1.9 introduced <code>MiniTest</code>, an updated version of
<code>Test::Unit</code> which provides a backwards compatible API for
<code>Test::Unit</code>. You could also use <code>MiniTest</code> in Ruby
1.8 by installing the <code>minitest</code> gem.</p>

<p>NOTE: For more information on <code>Test::Unit</code>, refer to <a
href="http://ruby-doc.org/stdlib/libdoc/test/unit/rdoc/">test/unit
Documentation</a> For more information on <code>MiniTest</code>, refer to
<a
href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/minitest/unit/rdoc/">Minitest</a></p>

<h2 id="label-Setup+and+Teardown">Setup and Teardown</h2>

<p>If you would like to run a block of code before the start of each test and
another block of code after the end of each test you have two special
callbacks for your rescue. Let&#39;s take note of this by looking at an
example for our functional test in <code>Posts</code> controller:</p>

<pre><code>require &#39;test_helper&#39;

class PostsControllerTest &lt; ActionController::TestCase

  # called before every single test
  def setup
    @post = posts(:one)
  end

  # called after every single test
  def teardown
    # as we are re-initializing @post before every test
    # setting it to nil here is not essential but I hope
    # you understand how you can use the teardown method
    @post = nil
  end

  test &quot;should show post&quot; do
    get :show, id: @post.id
    assert_response :success
  end

  test &quot;should destroy post&quot; do
    assert_difference(&#39;Post.count&#39;, -1) do
      delete :destroy, id: @post.id
    end

    assert_redirected_to posts_path
  end

end
</code></pre>

<p>Above, the <code>setup</code> method is called before each test and so
<code>@post</code> is available for each of the tests. <a
href="../../../../classes/Rails.html">Rails</a> implements
<code>setup</code> and <code>teardown</code> as
<code>ActiveSupport::Callbacks</code>. Which essentially means you need not
only use <code>setup</code> and <code>teardown</code> as methods in your
tests. You could specify them by using:</p>
<ul><li>
<p>a block</p>
</li><li>
<p>a method (like in the earlier example)</p>
</li><li>
<p>a method name as a symbol</p>
</li><li>
<p>a lambda</p>
</li></ul>

<p>Let&#39;s see the earlier example by specifying <code>setup</code> callback
by specifying a method name as a symbol:</p>

<pre><code>require &#39;test_helper&#39;

class PostsControllerTest &lt; ActionController::TestCase

  # called before every single test
  setup :initialize_post

  # called after every single test
  def teardown
    @post = nil
  end

  test &quot;should show post&quot; do
    get :show, id: @post.id
    assert_response :success
  end

  test &quot;should update post&quot; do
    patch :update, id: @post.id, post: {}
    assert_redirected_to post_path(assigns(:post))
  end

  test &quot;should destroy post&quot; do
    assert_difference(&#39;Post.count&#39;, -1) do
      delete :destroy, id: @post.id
    end

    assert_redirected_to posts_path
  end

  private

  def initialize_post
    @post = posts(:one)
  end

end
</code></pre>

<h2 id="label-Testing+Routes">Testing Routes</h2>

<p>Like everything else in your <a
href="../../../../classes/Rails.html">Rails</a> application, it is
recommended that you test your routes. An example test for a route in the
default <code>show</code> action of <code>Posts</code> controller above
should look like:</p>

<pre><code>test &quot;should route to post&quot; do
  assert_routing &#39;/posts/1&#39;, {controller: &quot;posts&quot;, action: &quot;show&quot;, id: &quot;1&quot;}
end
</code></pre>

<h2 id="label-Testing+Your+Mailers">Testing Your Mailers</h2>

<p>Testing mailer classes requires some specific tools to do a thorough job.</p>

<h3 id="label-Keeping+the+Postman+in+Check">Keeping the Postman in Check</h3>

<p>Your mailer classes — like every other part of your <a
href="../../../../classes/Rails.html">Rails</a> application — should be
tested to ensure that it is working as expected.</p>

<p>The goals of testing your mailer classes are to ensure that:</p>
<ul><li>
<p>emails are being processed (created and sent)</p>
</li><li>
<p>the email content is correct (subject, sender, body, etc)</p>
</li><li>
<p>the right emails are being sent at the right times</p>
</li></ul>

<h4 id="label-From+All+Sides">From All Sides</h4>

<p>There are two aspects of testing your mailer, the unit tests and the
functional tests. In the unit tests, you run the mailer in isolation with
tightly controlled inputs and compare the output to a known value (a
fixture.) In the functional tests you don&#39;t so much test the minute
details produced by the mailer; instead, we test that our controllers and
models are using the mailer in the right way. You test to prove that the
right email was sent at the right time.</p>

<h3 id="label-Unit+Testing">Unit Testing</h3>

<p>In order to test that your mailer is working as expected, you can use unit
tests to compare the actual results of the mailer with pre-written examples
of what should be produced.</p>

<h4 id="label-Revenge+of+the+Fixtures">Revenge of the <a href="../../../../classes/Fixtures.html">Fixtures</a></h4>

<p>For the purposes of unit testing a mailer, fixtures are used to provide an
example of how the output <em>should</em> look. Because these are example
emails, and not Active Record data like the other fixtures, they are kept
in their own subdirectory apart from the other fixtures. The name of the
directory within <code>test/fixtures</code> directly corresponds to the
name of the mailer. So, for a mailer named <code>UserMailer</code>, the
fixtures should reside in <code>test/fixtures/user_mailer</code> directory.</p>

<p>When you generated your mailer, the generator creates stub fixtures for
each of the mailers actions. If you didn&#39;t use the generator you&#39;ll
have to make those files yourself.</p>

<h4 id="label-The+Basic+Test+Case">The Basic Test Case</h4>

<p>Here&#39;s a unit test to test a mailer named <code>UserMailer</code> whose
action <code>invite</code> is used to send an invitation to a friend. It is
an adapted version of the base test created by the generator for an
<code>invite</code> action.</p>

<pre><code>require &#39;test_helper&#39;

class UserMailerTest &lt; ActionMailer::TestCase
  tests UserMailer
  test &quot;invite&quot; do
    @expected.from    = &#39;me@example.com&#39;
    @expected.to      = &#39;friend@example.com&#39;
    @expected.subject = &quot;You have been invited by #{@expected.from}&quot;
    @expected.body    = read_fixture(&#39;invite&#39;)
    @expected.date    = Time.now

    assert_equal @expected.encoded, UserMailer.create_invite(&#39;me@example.com&#39;, &#39;friend@example.com&#39;, @expected.date).encoded
  end

end
</code></pre>

<p>In this test, <code>@expected</code> is an instance of
<code>TMail::Mail</code> that you can use in your tests. It is defined in
<code>ActionMailer::TestCase</code>. The test above uses
<code>@expected</code> to construct an email, which it then asserts with
email created by the custom mailer. The <code>invite</code> fixture is the
body of the email and is used as the sample content to assert against. The
helper <code>read_fixture</code> is used to read in the content from this
file.</p>

<p>Here&#39;s the content of the <code>invite</code> fixture:</p>

<pre><code>Hi friend@example.com,

You have been invited.

Cheers!</code></pre>

<p>This is the right time to understand a little more about writing tests for
your mailers. The line <code>ActionMailer::Base.delivery_method =
:test</code> in <code>config/environments/test.rb</code> sets the delivery
method to test mode so that email will not actually be delivered (useful to
avoid spamming your users while testing) but instead it will be appended to
an array (<code>ActionMailer::Base.deliveries</code>).</p>

<p>This way, emails are not actually sent, simply constructed. The precise
content of the email can then be checked against what is expected, as in
the example above.</p>

<h3 id="label-Functional+Testing">Functional Testing</h3>

<p>Functional testing for mailers involves more than just checking that the
email body, recipients and so forth are correct. In functional mail tests
you call the mail deliver methods and check that the appropriate emails
have been appended to the delivery list. It is fairly safe to assume that
the deliver methods themselves do their job. You are probably more
interested in whether your own business logic is sending emails when you
expect them to go out. For example, you can check that the invite friend
operation is sending an email appropriately:</p>

<pre><code>require &#39;test_helper&#39;

class UserControllerTest &lt; ActionController::TestCase
  test &quot;invite friend&quot; do
    assert_difference &#39;ActionMailer::Base.deliveries.size&#39;, +1 do
      post :invite_friend, email: &#39;friend@example.com&#39;
    end
    invite_email = ActionMailer::Base.deliveries.last

    assert_equal &quot;You have been invited by me@example.com&quot;, invite_email.subject
    assert_equal &#39;friend@example.com&#39;, invite_email.to[0]
    assert_match(/Hi friend@example.com/, invite_email.body)
  end
end
</code></pre>

<h2 id="label-Other+Testing+Approaches">Other Testing Approaches</h2>

<p>The built-in <code>test/unit</code> based testing is not the only way to
test <a href="../../../../classes/Rails.html">Rails</a> applications. <a
href="../../../../classes/Rails.html">Rails</a> developers have come up
with a wide variety of other approaches and aids for testing, including:</p>
<ul><li>
<p><a href="http://avdi.org/projects/nulldb/">NullDB</a>, a way to speed up
testing by avoiding database use.</p>
</li><li>
<p><a href="https://github.com/thoughtbot/factory_girl/tree/master">Factory
Girl</a>, a replacement for fixtures.</p>
</li><li>
<p><a href="https://github.com/notahat/machinist/tree/master">Machinist</a>,
another replacement for fixtures.</p>
</li><li>
<p><a href="http://www.thoughtbot.com/projects/shoulda">Shoulda</a>, an
extension to <code>test/unit</code> with additional helpers, macros, and
assertions.</p>
</li><li>
<p><a href="http://relishapp.com/rspec">RSpec</a>, a behavior-driven
development framework</p>
</li></ul>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>