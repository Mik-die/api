<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>initialization.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            initialization.md
        </h1>
        <ul class="files">
            <li>rails/guides/source/initialization.md</li>
            <li>Last modified: 2013-04-26 19:51:18 +0300</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-The+Rails+Initialization+Process">The <a href="../../../../classes/Rails.html">Rails</a> Initialization <a href="../../../../classes/Process.html">Process</a></h1>

<p>This guide explains the internals of the initialization process in <a
href="../../../../classes/Rails.html">Rails</a> as of <a
href="../../../../classes/Rails.html">Rails</a> 4. It is an extremely
in-depth guide and recommended for advanced <a
href="../../../../classes/Rails.html">Rails</a> developers.</p>

<p>After reading this guide, you will know:</p>
<ul><li>
<p>How to use <code>rails server</code>.</p>
</li></ul>
<hr style="height: 1px">

<p>This guide goes through every method call that is required to boot up the
Ruby on <a href="../../../../classes/Rails.html">Rails</a> stack for a
default <a href="../../../../classes/Rails.html">Rails</a> 4 application,
explaining each part in detail along the way. For this guide, we will be
focusing on what happens when you execute +rails server+ to boot your app.</p>

<p>NOTE: Paths in this guide are relative to <a
href="../../../../classes/Rails.html">Rails</a> or a <a
href="../../../../classes/Rails.html">Rails</a> application unless
otherwise specified.</p>

<p>TIP: If you want to follow along while browsing the <a
href="../../../../classes/Rails.html">Rails</a> <a
href="https://github.com/rails/rails">source code</a>, we recommend that
you use the <code>t</code> key binding to open the file finder inside
GitHub and find files quickly.</p>

<h2 id="label-Launch%21">Launch!</h2>

<p>Now we finally boot and initialize the app. It all starts with your
app&#39;s <code>bin/rails</code> executable. <a
href="../../../../classes/A.html">A</a> <a
href="../../../../classes/Rails.html">Rails</a> application is usually
started by running <code>rails console</code> or <code>rails server</code>.</p>

<h3 id="label-bin%2Frails"><code>bin/rails</code></h3>

<p>This file is as follows:</p>

<pre><code>#!/usr/bin/env ruby
APP_PATH = File.expand_path(&#39;../../config/application&#39;,  __FILE__)
require File.expand_path(&#39;../../config/boot&#39;,  __FILE__)
require &#39;rails/commands&#39;
</code></pre>

<p>The <code>APP_PATH</code> constant will be used later in
<code>rails/commands</code>. The <code>config/boot</code> file referenced
here is the <code>config/boot.rb</code> file in our application which is
responsible for loading Bundler and setting it up.</p>

<h3 id="label-config%2Fboot.rb"><code>config/boot.rb</code></h3>

<p><code>config/boot.rb</code> contains:</p>

<pre><code># Set up gems listed in the Gemfile.
ENV[&#39;BUNDLE_GEMFILE&#39;] ||= File.expand_path(&#39;../../Gemfile&#39;, __FILE__)

require &#39;bundler/setup&#39; if File.exists?(ENV[&#39;BUNDLE_GEMFILE&#39;])
</code></pre>

<p>In a standard <a href="../../../../classes/Rails.html">Rails</a>
application, there&#39;s a <code>Gemfile</code> which declares all
dependencies of the application. <code>config/boot.rb</code> sets
<code>ENV['BUNDLE_GEMFILE']</code> to the location of this file. If the <a
href="../../Gemfile.html">Gemfile</a> exists, <code>bundler/setup</code> is
then required.</p>

<p>The gems that a <a href="../../../../classes/Rails.html">Rails</a> 4
application depends on are as follows:</p>

<p>TODO: change these when the <a
href="../../../../classes/Rails.html">Rails</a> 4 release is near.</p>
<ul><li>
<p>abstract (1.0.0)</p>
</li><li>
<p>actionmailer (4.0.0.beta)</p>
</li><li>
<p>actionpack (4.0.0.beta)</p>
</li><li>
<p>activemodel (4.0.0.beta)</p>
</li><li>
<p>activerecord (4.0.0.beta)</p>
</li><li>
<p>activesupport (4.0.0.beta)</p>
</li><li>
<p>arel (2.0.7)</p>
</li><li>
<p>builder (3.0.0)</p>
</li><li>
<p>bundler (1.0.6)</p>
</li><li>
<p>erubis (2.6.6)</p>
</li><li>
<p>i18n (0.5.0)</p>
</li><li>
<p>mail (2.2.12)</p>
</li><li>
<p>mime-types (1.16)</p>
</li><li>
<p>polyglot (0.3.1)</p>
</li><li>
<p>rack (1.2.1)</p>
</li><li>
<p>rack-cache (0.5.3)</p>
</li><li>
<p>rack-mount (0.6.13)</p>
</li><li>
<p>rack-test (0.5.6)</p>
</li><li>
<p>rails (4.0.0.beta)</p>
</li><li>
<p>railties (4.0.0.beta)</p>
</li><li>
<p>rake (0.8.7)</p>
</li><li>
<p>sqlite3-ruby (1.3.2)</p>
</li><li>
<p>thor (0.14.6)</p>
</li><li>
<p>treetop (1.4.9)</p>
</li><li>
<p>tzinfo (0.3.23)</p>
</li></ul>

<h3 id="label-rails%2Fcommands.rb"><code>rails/commands.rb</code></h3>

<p>Once <code>config/boot.rb</code> has finished, the next file that is
required is <code>rails/commands</code> which will execute a command based
on the arguments passed in. In this case, the <code>ARGV</code> array
simply contains <code>server</code> which is extracted into the
<code>command</code> variable using these lines:</p>

<pre><code>ARGV &lt;&lt; &#39;--help&#39; if ARGV.empty?

aliases = {
  &quot;g&quot;  =&gt; &quot;generate&quot;,
  &quot;d&quot;  =&gt; &quot;destroy&quot;,
  &quot;c&quot;  =&gt; &quot;console&quot;,
  &quot;s&quot;  =&gt; &quot;server&quot;,
  &quot;db&quot; =&gt; &quot;dbconsole&quot;,
  &quot;r&quot;  =&gt; &quot;runner&quot;
}

command = ARGV.shift
command = aliases[command] || command
</code></pre>

<p>TIP: As you can see, an empty ARGV list will make <a
href="../../../../classes/Rails.html">Rails</a> show the help snippet.</p>

<p>If we used <code>s</code> rather than <code>server</code>, <a
href="../../../../classes/Rails.html">Rails</a> will use the
<code>aliases</code> defined in the file and match them to their respective
commands. With the <code>server</code> command, <a
href="../../../../classes/Rails.html">Rails</a> will run this code:</p>

<pre><code>when &#39;server&#39;
  # Change to the application&#39;s path if there is no config.ru file in current dir.
  # This allows us to run `rails server` from other directories, but still get
  # the main config.ru and properly set the tmp directory.
  Dir.chdir(File.expand_path(&#39;../../&#39;, APP_PATH)) unless File.exists?(File.expand_path(&quot;config.ru&quot;))

  require &#39;rails/commands/server&#39;
  Rails::Server.new.tap do |server|
    # We need to require application after the server sets environment,
    # otherwise the --environment option given to the server won&#39;t propagate.
    require APP_PATH
    Dir.chdir(Rails.application.root)
    server.start
  end
</code></pre>

<p>This file will change into the root of the directory (a path two
directories back from <code>APP_PATH</code> which points at
<code>config/application.rb</code>), but only if the <code>config.ru</code>
file isn&#39;t found. This then requires <code>rails/commands/server</code>
which sets up the <code>Rails::Server</code> class.</p>

<pre><code>require &#39;fileutils&#39;
require &#39;optparse&#39;
require &#39;action_dispatch&#39;

module Rails
  class Server &lt; ::Rack::Server
</code></pre>

<p><code>fileutils</code> and <code>optparse</code> are standard Ruby
libraries which provide helper functions for working with files and parsing
options.</p>

<h3 id="label-actionpack%2Flib%2Faction_dispatch.rb"><code>actionpack/lib/action_dispatch.rb</code></h3>

<p>Action Dispatch is the routing component of the <a
href="../../../../classes/Rails.html">Rails</a> framework. It adds
functionalities like routing, session, and common middlewares.</p>

<h3 id="label-rails%2Fcommands%2Fserver.rb"><code>rails/commands/server.rb</code></h3>

<p>The <code>Rails::Server</code> class is defined in this file as inheriting
from <code>Rack::Server</code>. When <code>Rails::Server.new</code> is
called, this calls the <code>initialize</code> method in
<code>rails/commands/server.rb</code>:</p>

<pre><code>def initialize(*)
  super
  set_environment
end
</code></pre>

<p>Firstly, <code>super</code> is called which calls the
<code>initialize</code> method on <code>Rack::Server</code>.</p>

<h3 id="label-Rack%3A+lib%2Frack%2Fserver.rb">Rack: <code>lib/rack/server.rb</code></h3>

<p><code>Rack::Server</code> is responsible for providing a common server
interface for all Rack-based applications, which <a
href="../../../../classes/Rails.html">Rails</a> is now a part of.</p>

<p>The <code>initialize</code> method in <code>Rack::Server</code> simply sets
a couple of variables:</p>

<pre><code>def initialize(options = nil)
  @options = options
  @app = options[:app] if options &amp;&amp; options[:app]
end
</code></pre>

<p>In this case, <code>options</code> will be <code>nil</code> so nothing
happens in this method.</p>

<p>After <code>super</code> has finished in <code>Rack::Server</code>, we jump
back to <code>rails/commands/server.rb</code>. At this point,
<code>set_environment</code> is called within the context of the
<code>Rails::Server</code> object and this method doesn&#39;t appear to do
much at first glance:</p>

<pre><code>def set_environment
  ENV[&quot;RAILS_ENV&quot;] ||= options[:environment]
end
</code></pre>

<p>In fact, the <code>options</code> method here does quite a lot. This method
is defined in <code>Rack::Server</code> like this:</p>

<pre><code>def options
  @options ||= parse_options(ARGV)
end
</code></pre>

<p>Then <code>parse_options</code> is defined like this:</p>

<pre><code>def parse_options(args)
  options = default_options

  # Don&#39;t evaluate CGI ISINDEX parameters.
  # http://hoohoo.ncsa.uiuc.edu/cgi/cl.html
  args.clear if ENV.include?(&quot;REQUEST_METHOD&quot;)

  options.merge! opt_parser.parse! args
  options[:config] = ::File.expand_path(options[:config])
  ENV[&quot;RACK_ENV&quot;] = options[:environment]
  options
end
</code></pre>

<p>With the <code>default_options</code> set to this:</p>

<pre><code>def default_options
  {
    :environment =&gt; ENV[&#39;RACK_ENV&#39;] || &quot;development&quot;,
    :pid         =&gt; nil,
    :Port        =&gt; 9292,
    :Host        =&gt; &quot;0.0.0.0&quot;,
    :AccessLog   =&gt; [],
    :config      =&gt; &quot;config.ru&quot;
  }
end
</code></pre>

<p>There is no <code>REQUEST_METHOD</code> key in <code>ENV</code> so we can
skip over that line. The next line merges in the options from
<code>opt_parser</code> which is defined plainly in
<code>Rack::Server</code></p>

<pre><code>def opt_parser
  Options.new
end
</code></pre>

<p>The class <strong>is</strong> defined in <code>Rack::Server</code>, but is
overwritten in <code>Rails::Server</code> to take different arguments. Its
<code>parse!</code> method begins like this:</p>

<pre><code>def parse!(args)
  args, options = args.dup, {}

  opt_parser = OptionParser.new do |opts|
    opts.banner = &quot;Usage: rails server [mongrel, thin, etc] [options]&quot;
    opts.on(&quot;-p&quot;, &quot;--port=port&quot;, Integer,
            &quot;Runs Rails on the specified port.&quot;, &quot;Default: 3000&quot;) { |v| options[:Port] = v }
  ...
</code></pre>

<p>This method will set up keys for the <code>options</code> which <a
href="../../../../classes/Rails.html">Rails</a> will then be able to use to
determine how its server should run. After <code>initialize</code> has
finished, we jump back into <code>rails/server</code> where
<code>APP_PATH</code> (which was set earlier) is required.</p>

<h3 id="label-config%2Fapplication"><code>config/application</code></h3>

<p>When <code>require APP_PATH</code> is executed,
<code>config/application.rb</code> is loaded. This file exists in your app
and it&#39;s free for you to change based on your needs.</p>

<h3 id="label-Rails%3A%3AServer%23start"><code>Rails::Server#start</code></h3>

<p>After <code>config/application</code> is loaded, <code>server.start</code>
is called. This method is defined like this:</p>

<pre><code>def start
  url = &quot;#{options[:SSLEnable] ? &#39;https&#39; : &#39;http&#39;}://#{options[:Host]}:#{options[:Port]}&quot;
  puts &quot;=&gt; Booting #{ActiveSupport::Inflector.demodulize(server)}&quot;
  puts &quot;=&gt; Rails #{Rails.version} application starting in #{Rails.env} on #{url}&quot;
  puts &quot;=&gt; Call with -d to detach&quot; unless options[:daemonize]
  trap(:INT) { exit }
  puts &quot;=&gt; Ctrl-C to shutdown server&quot; unless options[:daemonize]

  #Create required tmp directories if not found
  %w(cache pids sessions sockets).each do |dir_to_make|
    FileUtils.mkdir_p(Rails.root.join(&#39;tmp&#39;, dir_to_make))
  end

  unless options[:daemonize]
    wrapped_app # touch the app so the logger is set up

    console = ActiveSupport::Logger.new($stdout)
    console.formatter = Rails.logger.formatter

    Rails.logger.extend(ActiveSupport::Logger.broadcast(console))
  end

  super
ensure
  # The &#39;-h&#39; option calls exit before @options is set.
  # If we call &#39;options&#39; with it unset, we get double help banners.
  puts &#39;Exiting&#39; unless @options &amp;&amp; options[:daemonize]
end
</code></pre>

<p>This is where the first output of the <a
href="../../../../classes/Rails.html">Rails</a> initialization happens.
This method creates a trap for <code>INT</code> signals, so if you
<code>CTRL-C</code> the server, it will exit the process. As we can see
from the code here, it will create the <code>tmp/cache</code>,
<code>tmp/pids</code>, <code>tmp/sessions</code> and
<code>tmp/sockets</code> directories. It then calls
<code>wrapped_app</code> which is responsible for creating the <a
href="../../../../classes/Rack.html">Rack</a> app, before creating and
assigning an instance of <code>ActiveSupport::Logger</code>.</p>

<p>The <code>super</code> method will call <code>Rack::Server.start</code>
which begins its definition like this:</p>

<pre><code>def start &amp;blk
  if options[:warn]
    $-w = true
  end

  if includes = options[:include]
    $LOAD_PATH.unshift(*includes)
  end

  if library = options[:require]
    require library
  end

  if options[:debug]
    $DEBUG = true
    require &#39;pp&#39;
    p options[:server]
    pp wrapped_app
    pp app
  end

  check_pid! if options[:pid]

  # Touch the wrapped app, so that the config.ru is loaded before
  # daemonization (i.e. before chdir, etc).
  wrapped_app

  daemonize_app if options[:daemonize]

  write_pid if options[:pid]

  trap(:INT) do
    if server.respond_to?(:shutdown)
      server.shutdown
    else
      exit
    end
  end

  server.run wrapped_app, options, &amp;blk
end
</code></pre>

<p>The interesting part for a <a
href="../../../../classes/Rails.html">Rails</a> app is the last line,
<code>server.run</code>. Here we encounter the <code>wrapped_app</code>
method again, which this time we&#39;re going to explore more (even though
it was executed before, and thus memorized by now).</p>

<pre><code>@wrapped_app ||= build_app app
</code></pre>

<p>The <code>app</code> method here is defined like so:</p>

<pre><code>def app
  @app ||= begin
    if !::File.exist? options[:config]
      abort &quot;configuration #{options[:config]} not found&quot;
    end

    app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)
    self.options.merge! options
    app
  end
end
</code></pre>

<p>The <code>options[:config]</code> value defaults to <code>config.ru</code>
which contains this:</p>

<pre><code># This file is used by Rack-based servers to start the application.

require ::File.expand_path(&#39;../config/environment&#39;,  __FILE__)
run &lt;%= app_const %&gt;
</code></pre>

<p>The <code>Rack::Builder.parse_file</code> method here takes the content
from this <code>config.ru</code> file and parses it using this code:</p>

<pre><code>app = eval &quot;Rack::Builder.new {( &quot; + cfgfile + &quot;\n )}.to_app&quot;,
    TOPLEVEL_BINDING, config
</code></pre>

<p>The <code>initialize</code> method of <code>Rack::Builder</code> will take
the block here and execute it within an instance of
<code>Rack::Builder</code>. This is where the majority of the
initialization process of <a
href="../../../../classes/Rails.html">Rails</a> happens. The
<code>require</code> line for <code>config/environment.rb</code> in
<code>config.ru</code> is the first to run:</p>

<pre><code>require ::File.expand_path(&#39;../config/environment&#39;,  __FILE__)
</code></pre>

<h3 id="label-config%2Fenvironment.rb"><code>config/environment.rb</code></h3>

<p>This file is the common file required by <code>config.ru</code>
(<code>rails server</code>) and Passenger. This is where these two ways to
run the server meet; everything before this point has been <a
href="../../../../classes/Rack.html">Rack</a> and <a
href="../../../../classes/Rails.html">Rails</a> setup.</p>

<p>This file begins with requiring <code>config/application.rb</code>.</p>

<h3 id="label-config%2Fapplication.rb"><code>config/application.rb</code></h3>

<p>This file requires <code>config/boot.rb</code>, but only if it hasn&#39;t
been required before, which would be the case in <code>rails server</code>
but <strong>wouldn&#39;t</strong> be the case with Passenger.</p>

<p>Then the fun begins!</p>

<h2 id="label-Loading+Rails">Loading <a href="../../../../classes/Rails.html">Rails</a></h2>

<p>The next line in <code>config/application.rb</code> is:</p>

<pre><code>require &#39;rails/all&#39;
</code></pre>

<h3 id="label-railties%2Flib%2Frails%2Fall.rb"><code>railties/lib/rails/all.rb</code></h3>

<p>This file is responsible for requiring all the individual frameworks of
Rails:</p>

<pre><code>require &quot;rails&quot;

%w(
    active_record
    action_controller
    action_mailer
    rails/test_unit
    sprockets
).each do |framework|
  begin
    require &quot;#{framework}/railtie&quot;
  rescue LoadError
  end
end
</code></pre>

<p>This is where all the <a href="../../../../classes/Rails.html">Rails</a>
frameworks are loaded and thus made available to the application. We
won&#39;t go into detail of what happens inside each of those frameworks,
but you&#39;re encouraged to try and explore them on your own.</p>

<p>For now, just keep in mind that common functionality like <a
href="../../../../classes/Rails.html">Rails</a> engines, <a
href="../../../../classes/I18n.html">I18n</a> and <a
href="../../../../classes/Rails.html">Rails</a> configuration is all being
defined here.</p>

<h3 id="label-Back+to+config%2Fenvironment.rb">Back to <code>config/environment.rb</code></h3>

<p>When <code>config/application.rb</code> has finished loading <a
href="../../../../classes/Rails.html">Rails</a>, and defined your
application namespace, you go back to <code>config/environment.rb</code>,
where your application is initialized. For example, if you application was
called <code>Blog</code>, here you would find
<code>Blog::Application.initialize!</code>, which is defined in
<code>rails/application.rb</code></p>

<h3 id="label-railties%2Flib%2Frails%2Fapplication.rb"><code>railties/lib/rails/application.rb</code></h3>

<p>The <code>initialize!</code> method looks like this:</p>

<pre><code>def initialize!(group=:default) #:nodoc:
  raise &quot;Application has been already initialized.&quot; if @initialized
  run_initializers(group, self)
  @initialized = true
  self
end
</code></pre>

<p>As you can see, you can only initialize an app once. This is also where the
initializers are run.</p>

<p>TODO: review this</p>

<p>The initializers code itself is tricky. What <a
href="../../../../classes/Rails.html">Rails</a> is doing here is it
traverses all the class ancestors looking for an <code>initializers</code>
method, sorting them and running them. For example, the <code>Engine</code>
class will make all the engines available by providing the
<code>initializers</code> method.</p>

<p>After this is done we go back to <code>Rack::Server</code></p>

<h3 id="label-Rack%3A+lib%2Frack%2Fserver.rb">Rack: lib/rack/server.rb</h3>

<p>Last time we left when the <code>app</code> method was being defined:</p>

<pre><code>def app
  @app ||= begin
    if !::File.exist? options[:config]
      abort &quot;configuration #{options[:config]} not found&quot;
    end

    app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)
    self.options.merge! options
    app
  end
end
</code></pre>

<p>At this point <code>app</code> is the <a
href="../../../../classes/Rails.html">Rails</a> app itself (a middleware),
and what happens next is <a href="../../../../classes/Rack.html">Rack</a>
will call all the provided middlewares:</p>

<pre><code>def build_app(app)
  middleware[options[:environment]].reverse_each do |middleware|
    middleware = middleware.call(self) if middleware.respond_to?(:call)
    next unless middleware
    klass = middleware.shift
    app = klass.new(app, *middleware)
  end
  app
end
</code></pre>

<p>Remember, <code>build_app</code> was called (by wrapped_app) in the last
line of <code>Server#start</code>. Here&#39;s how it looked like when we
left:</p>

<pre><code>server.run wrapped_app, options, &amp;blk
</code></pre>

<p>At this point, the implementation of <code>server.run</code> will depend on
the server you&#39;re using. For example, if you were using Mongrel,
here&#39;s what the <code>run</code> method would look like:</p>

<pre><code>def self.run(app, options={})
  server = ::Mongrel::HttpServer.new(
    options[:Host]           || &#39;0.0.0.0&#39;,
    options[:Port]           || 8080,
    options[:num_processors] || 950,
    options[:throttle]       || 0,
    options[:timeout]        || 60)
  # Acts like Rack::URLMap, utilizing Mongrel&#39;s own path finding methods.
  # Use is similar to #run, replacing the app argument with a hash of
  # { path=&gt;app, ... } or an instance of Rack::URLMap.
  if options[:map]
    if app.is_a? Hash
      app.each do |path, appl|
        path = &#39;/&#39;+path unless path[0] == ?/
        server.register(path, Rack::Handler::Mongrel.new(appl))
      end
    elsif app.is_a? URLMap
      app.instance_variable_get(:@mapping).each do |(host, path, appl)|
       next if !host.nil? &amp;&amp; !options[:Host].nil? &amp;&amp; options[:Host] != host
       path = &#39;/&#39;+path unless path[0] == ?/
       server.register(path, Rack::Handler::Mongrel.new(appl))
      end
    else
      raise ArgumentError, &quot;first argument should be a Hash or URLMap&quot;
    end
  else
    server.register(&#39;/&#39;, Rack::Handler::Mongrel.new(app))
  end
  yield server  if block_given?
  server.run.join
end
</code></pre>

<p>We won&#39;t dig into the server configuration itself, but this is the last
piece of our journey in the <a
href="../../../../classes/Rails.html">Rails</a> initialization process.</p>

<p>This high level overview will help you understand when your code is
executed and how, and overall become a better <a
href="../../../../classes/Rails.html">Rails</a> developer. If you still
want to know more, the <a href="../../../../classes/Rails.html">Rails</a>
source code itself is probably the best place to go next.</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>