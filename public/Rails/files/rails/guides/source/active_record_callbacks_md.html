<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>active_record_callbacks.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            active_record_callbacks.md
        </h1>
        <ul class="files">
            <li>rails/guides/source/active_record_callbacks.md</li>
            <li>Last modified: 2013-04-26 19:46:46 +0300</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-Active+Record+Callbacks">Active Record Callbacks</h1>

<p>This guide teaches you how to hook into the life cycle of your Active
Record objects.</p>

<p>After reading this guide, you will know:</p>
<ul><li>
<p>The life cycle of Active Record objects.</p>
</li><li>
<p>How to create callback methods that respond to events in the object life
cycle.</p>
</li><li>
<p>How to create special classes that encapsulate common behavior for your
callbacks.</p>
</li></ul>
<hr style="height: 1px">

<h2 id="label-The+Object+Life+Cycle">The <a href="../../../../classes/Object.html">Object</a> Life Cycle</h2>

<p>During the normal operation of a <a
href="../../../../classes/Rails.html">Rails</a> application, objects may be
created, updated, and destroyed. Active Record provides hooks into this
<em>object life cycle</em> so that you can control your application and its
data.</p>

<p>Callbacks allow you to trigger logic before or after an alteration of an
object&#39;s state.</p>

<h2 id="label-Callbacks+Overview">Callbacks Overview</h2>

<p>Callbacks are methods that get called at certain moments of an object&#39;s
life cycle. With callbacks it is possible to write code that will run
whenever an Active Record object is created, saved, updated, deleted,
validated, or loaded from the database.</p>

<h3 id="label-Callback+Registration">Callback Registration</h3>

<p>In order to use the available callbacks, you need to register them. You can
implement the callbacks as ordinary methods and use a macro-style class
method to register them as callbacks:</p>

<pre><code>class User &lt; ActiveRecord::Base
  validates :login, :email, presence: true

  before_validation :ensure_login_has_a_value

  protected
  def ensure_login_has_a_value
    if login.nil?
      self.login = email unless email.blank?
    end
  end
end
</code></pre>

<p>The macro-style class methods can also receive a block. Consider using this
style if the code inside your block is so short that it fits in a single
line:</p>

<pre><code>class User &lt; ActiveRecord::Base
  validates :login, :email, presence: true

  before_create do |user|
    user.name = user.login.capitalize if user.name.blank?
  end
end
</code></pre>

<p>Callbacks can also be registered to only fire on certain lifecycle events:</p>

<pre><code>class User &lt; ActiveRecord::Base
  before_validation :normalize_name, on: :create

  # :on takes an array as well
  after_validation :set_location, on: [ :create, :update ]

  protected
  def normalize_name
    self.name = self.name.downcase.titleize
  end

  def set_location
    self.location = LocationService.query(self)
  end
end
</code></pre>

<p>It is considered good practice to declare callback methods as protected or
private. If left public, they can be called from outside of the model and
violate the principle of object encapsulation.</p>

<h2 id="label-Available+Callbacks">Available Callbacks</h2>

<p>Here is a list with all the available Active Record callbacks, listed in
the same order in which they will get called during the respective
operations:</p>

<h3 id="label-Creating+an+Object">Creating an <a href="../../../../classes/Object.html">Object</a></h3>
<ul><li>
<p><code>before_validation</code></p>
</li><li>
<p><code>after_validation</code></p>
</li><li>
<p><code>before_save</code></p>
</li><li>
<p><code>around_save</code></p>
</li><li>
<p><code>before_create</code></p>
</li><li>
<p><code>around_create</code></p>
</li><li>
<p><code>after_create</code></p>
</li><li>
<p><code>after_save</code></p>
</li></ul>

<h3 id="label-Updating+an+Object">Updating an <a href="../../../../classes/Object.html">Object</a></h3>
<ul><li>
<p><code>before_validation</code></p>
</li><li>
<p><code>after_validation</code></p>
</li><li>
<p><code>before_save</code></p>
</li><li>
<p><code>around_save</code></p>
</li><li>
<p><code>before_update</code></p>
</li><li>
<p><code>around_update</code></p>
</li><li>
<p><code>after_update</code></p>
</li><li>
<p><code>after_save</code></p>
</li></ul>

<h3 id="label-Destroying+an+Object">Destroying an <a href="../../../../classes/Object.html">Object</a></h3>
<ul><li>
<p><code>before_destroy</code></p>
</li><li>
<p><code>around_destroy</code></p>
</li><li>
<p><code>after_destroy</code></p>
</li></ul>

<p>WARNING. <code>after_save</code> runs both on create and update, but always
<em>after</em> the more specific callbacks <code>after_create</code> and
<code>after_update</code>, no matter the order in which the macro calls
were executed.</p>

<h3 id="label-after_initialize+and+after_find"><code>after_initialize</code> and <code>after_find</code></h3>

<p>The <code>after_initialize</code> callback will be called whenever an
Active Record object is instantiated, either by directly using
<code>new</code> or when a record is loaded from the database. It can be
useful to avoid the need to directly override your Active Record
<code>initialize</code> method.</p>

<p>The <code>after_find</code> callback will be called whenever Active Record
loads a record from the database. <code>after_find</code> is called before
<code>after_initialize</code> if both are defined.</p>

<p>The <code>after_initialize</code> and <code>after_find</code> callbacks
have no <code>before_*</code> counterparts, but they can be registered just
like the other Active Record callbacks.</p>

<pre><code>class User &lt; ActiveRecord::Base
  after_initialize do |user|
    puts &quot;You have initialized an object!&quot;
  end

  after_find do |user|
    puts &quot;You have found an object!&quot;
  end
end

&gt;&gt; User.new
You have initialized an object!
=&gt; #&lt;User id: nil&gt;

&gt;&gt; User.first
You have found an object!
You have initialized an object!
=&gt; #&lt;User id: 1&gt;
</code></pre>

<h2 id="label-Running+Callbacks">Running Callbacks</h2>

<p>The following methods trigger callbacks:</p>
<ul><li>
<p><code>create</code></p>
</li><li>
<p><code>create!</code></p>
</li><li>
<p><code>decrement!</code></p>
</li><li>
<p><code>destroy</code></p>
</li><li>
<p><code>destroy!</code></p>
</li><li>
<p><code>destroy_all</code></p>
</li><li>
<p><code>increment!</code></p>
</li><li>
<p><code>save</code></p>
</li><li>
<p><code>save!</code></p>
</li><li>
<p><code>save(validate: false)</code></p>
</li><li>
<p><code>toggle!</code></p>
</li><li>
<p><code>update_attribute</code></p>
</li><li>
<p><code>update</code></p>
</li><li>
<p><code>update!</code></p>
</li><li>
<p><code>valid?</code></p>
</li></ul>

<p>Additionally, the <code>after_find</code> callback is triggered by the
following finder methods:</p>
<ul><li>
<p><code>all</code></p>
</li><li>
<p><code>first</code></p>
</li><li>
<p><code>find</code></p>
</li><li>
<p><code>find_by_*</code></p>
</li><li>
<p><code>find_by_*!</code></p>
</li><li>
<p><code>find_by_sql</code></p>
</li><li>
<p><code>last</code></p>
</li></ul>

<p>The <code>after_initialize</code> callback is triggered every time a new
object of the class is initialized.</p>

<p>NOTE: The <code>find_by_*</code> and <code>find_by_*!</code> methods are
dynamic finders generated automatically for every attribute. Learn more
about them at the <a
href="http://active_record_querying.html#dynamic-finders">Dynamic finders
section</a></p>

<h2 id="label-Skipping+Callbacks">Skipping Callbacks</h2>

<p>Just as with validations, it is also possible to skip callbacks. These
methods should be used with caution, however, because important business
rules and application logic may be kept in callbacks. Bypassing them
without understanding the potential implications may lead to invalid data.</p>
<ul><li>
<p><code>decrement</code></p>
</li><li>
<p><code>decrement_counter</code></p>
</li><li>
<p><code>delete</code></p>
</li><li>
<p><code>delete_all</code></p>
</li><li>
<p><code>increment</code></p>
</li><li>
<p><code>increment_counter</code></p>
</li><li>
<p><code>toggle</code></p>
</li><li>
<p><code>touch</code></p>
</li><li>
<p><code>update_column</code></p>
</li><li>
<p><code>update_columns</code></p>
</li><li>
<p><code>update_all</code></p>
</li><li>
<p><code>update_counters</code></p>
</li></ul>

<h2 id="label-Halting+Execution">Halting Execution</h2>

<p>As you start registering new callbacks for your models, they will be queued
for execution. This queue will include all your model&#39;s validations,
the registered callbacks, and the database operation to be executed.</p>

<p>The whole callback chain is wrapped in a transaction. If any
<em>before</em> callback method returns exactly <code>false</code> or
raises an exception, the execution chain gets halted and a ROLLBACK is
issued; <em>after</em> callbacks can only accomplish that by raising an
exception.</p>

<p>WARNING. Raising an arbitrary exception may break code that expects
<code>save</code> and its friends not to fail like that. The
<code>ActiveRecord::Rollback</code> exception is thought precisely to tell
Active Record a rollback is going on. That one is internally captured but
not reraised.</p>

<h2 id="label-Relational+Callbacks">Relational Callbacks</h2>

<p>Callbacks work through model relationships, and can even be defined by
them. Suppose an example where a user has many posts. <a
href="../../../../classes/A.html">A</a> user&#39;s posts should be
destroyed if the user is destroyed. Let&#39;s add an
<code>after_destroy</code> callback to the <code>User</code> model by way
of its relationship to the <code>Post</code> model:</p>

<pre><code>class User &lt; ActiveRecord::Base
  has_many :posts, dependent: :destroy
end

class Post &lt; ActiveRecord::Base
  after_destroy :log_destroy_action

  def log_destroy_action
    puts &#39;Post destroyed&#39;
  end
end

&gt;&gt; user = User.first
=&gt; #&lt;User id: 1&gt;
&gt;&gt; user.posts.create!
=&gt; #&lt;Post id: 1, user_id: 1&gt;
&gt;&gt; user.destroy
Post destroyed
=&gt; #&lt;User id: 1&gt;
</code></pre>

<h2 id="label-Conditional+Callbacks">Conditional Callbacks</h2>

<p>As with validations, we can also make the calling of a callback method
conditional on the satisfaction of a given predicate. We can do this using
the <code>:if</code> and <code>:unless</code> options, which can take a
symbol, a string, a <code>Proc</code> or an <code>Array</code>. You may use
the <code>:if</code> option when you want to specify under which conditions
the callback <strong>should</strong> be called. If you want to specify the
conditions under which the callback <strong>should not</strong> be called,
then you may use the <code>:unless</code> option.</p>

<h3 id="label-Using+%3Aif+and+%3Aunless+with+a+Symbol">Using <code>:if</code> and <code>:unless</code> with a <code>Symbol</code></h3>

<p>You can associate the <code>:if</code> and <code>:unless</code> options
with a symbol corresponding to the name of a predicate method that will get
called right before the callback. When using the <code>:if</code> option,
the callback won&#39;t be executed if the predicate method returns false;
when using the <code>:unless</code> option, the callback won&#39;t be
executed if the predicate method returns true. This is the most common
option. Using this form of registration it is also possible to register
several different predicates that should be called to check if the callback
should be executed.</p>

<pre><code>class Order &lt; ActiveRecord::Base
  before_save :normalize_card_number, if: :paid_with_card?
end
</code></pre>

<h3 id="label-Using+%3Aif+and+%3Aunless+with+a+String">Using <code>:if</code> and <code>:unless</code> with a <a href="../../../../classes/String.html">String</a></h3>

<p>You can also use a string that will be evaluated using <code>eval</code>
and hence needs to contain valid Ruby code. You should use this option only
when the string represents a really short condition:</p>

<pre><code>class Order &lt; ActiveRecord::Base
  before_save :normalize_card_number, if: &quot;paid_with_card?&quot;
end
</code></pre>

<h3 id="label-Using+%3Aif+and+%3Aunless+with+a+Proc">Using <code>:if</code> and <code>:unless</code> with a <code>Proc</code></h3>

<p>Finally, it is possible to associate <code>:if</code> and
<code>:unless</code> with a <code>Proc</code> object. This option is best
suited when writing short validation methods, usually one-liners:</p>

<pre><code>class Order &lt; ActiveRecord::Base
  before_save :normalize_card_number,
    if: Proc.new { |order| order.paid_with_card? }
end
</code></pre>

<h3 id="label-Multiple+Conditions+for+Callbacks">Multiple Conditions for Callbacks</h3>

<p>When writing conditional callbacks, it is possible to mix both
<code>:if</code> and <code>:unless</code> in the same callback declaration:</p>

<pre><code>class Comment &lt; ActiveRecord::Base
  after_create :send_email_to_author, if: :author_wants_emails?,
    unless: Proc.new { |comment| comment.post.ignore_comments? }
end
</code></pre>

<h2 id="label-Callback+Classes">Callback Classes</h2>

<p>Sometimes the callback methods that you&#39;ll write will be useful enough
to be reused by other models. Active Record makes it possible to create
classes that encapsulate the callback methods, so it becomes very easy to
reuse them.</p>

<p>Here&#39;s an example where we create a class with an
<code>after_destroy</code> callback for a <code>PictureFile</code> model:</p>

<pre><code>class PictureFileCallbacks
  def after_destroy(picture_file)
    if File.exists?(picture_file.filepath)
      File.delete(picture_file.filepath)
    end
  end
end
</code></pre>

<p>When declared inside a class, as above, the callback methods will receive
the model object as a parameter. We can now use the callback class in the
model:</p>

<pre><code>class PictureFile &lt; ActiveRecord::Base
  after_destroy PictureFileCallbacks.new
end
</code></pre>

<p>Note that we needed to instantiate a new <code>PictureFileCallbacks</code>
object, since we declared our callback as an instance method. This is
particularly useful if the callbacks make use of the state of the
instantiated object. Often, however, it will make more sense to declare the
callbacks as class methods:</p>

<pre><code>class PictureFileCallbacks
  def self.after_destroy(picture_file)
    if File.exists?(picture_file.filepath)
      File.delete(picture_file.filepath)
    end
  end
end
</code></pre>

<p>If the callback method is declared this way, it won&#39;t be necessary to
instantiate a <code>PictureFileCallbacks</code> object.</p>

<pre><code>class PictureFile &lt; ActiveRecord::Base
  after_destroy PictureFileCallbacks
end
</code></pre>

<p>You can declare as many callbacks as you want inside your callback classes.</p>

<h2 id="label-Transaction+Callbacks">Transaction Callbacks</h2>

<p>There are two additional callbacks that are triggered by the completion of
a database transaction: <code>after_commit</code> and
<code>after_rollback</code>. These callbacks are very similar to the
<code>after_save</code> callback except that they don&#39;t execute until
after database changes have either been committed or rolled back. They are
most useful when your active record models need to interact with external
systems which are not part of the database transaction.</p>

<p>Consider, for example, the previous example where the
<code>PictureFile</code> model needs to delete a file after the
corresponding record is destroyed. If anything raises an exception after
the <code>after_destroy</code> callback is called and the transaction rolls
back, the file will have been deleted and the model will be left in an
inconsistent state. For example, suppose that <code>picture_file_2</code>
in the code below is not valid and the <code>save!</code> method raises an
error.</p>

<pre><code>PictureFile.transaction do
  picture_file_1.destroy
  picture_file_2.save!
end
</code></pre>

<p>By using the <code>after_commit</code> callback we can account for this
case.</p>

<pre><code>class PictureFile &lt; ActiveRecord::Base
  after_commit :delete_picture_file_from_disk, :on =&gt; [:destroy]

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end
</code></pre>

<p>NOTE: the <code>:on</code> option specifies when a callback will be fired.
If you don&#39;t supply the <code>:on</code> option the callback will fire
for every action.</p>

<p>The <code>after_commit</code> and <code>after_rollback</code> callbacks are
guaranteed to be called for all models created, updated, or destroyed
within a transaction block. If any exceptions are raised within one of
these callbacks, they will be ignored so that they don&#39;t interfere with
the other callbacks. As such, if your callback code could raise an
exception, you&#39;ll need to rescue it and handle it appropriately within
the callback.</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>