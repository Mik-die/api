<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>getting_started.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            getting_started.md
        </h1>
        <ul class="files">
            <li>rails/guides/source/getting_started.md</li>
            <li>Last modified: 2013-04-26 19:51:18 +0300</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-Getting+Started+with+Rails">Getting Started with <a href="../../../../classes/Rails.html">Rails</a></h1>

<p>This guide covers getting up and running with Ruby on <a
href="../../../../classes/Rails.html">Rails</a>.</p>

<p>After reading this guide, you will know:</p>
<ul><li>
<p>How to install <a href="../../../../classes/Rails.html">Rails</a>, create a
new <a href="../../../../classes/Rails.html">Rails</a> application, and
connect your  application to a database.</p>
</li><li>
<p>The general layout of a <a href="../../../../classes/Rails.html">Rails</a>
application.</p>
</li><li>
<p>The basic principles of MVC (Model, View, Controller) and RESTful design.</p>
</li><li>
<p>How to quickly generate the starting pieces of a <a
href="../../../../classes/Rails.html">Rails</a> application.</p>
</li></ul>
<hr style="height: 1px">

<h2 id="label-Guide+Assumptions">Guide Assumptions</h2>

<p>This guide is designed for beginners who want to get started with a <a
href="../../../../classes/Rails.html">Rails</a> application from scratch.
It does not assume that you have any prior experience with <a
href="../../../../classes/Rails.html">Rails</a>. However, to get the most
out of it, you need to have some prerequisites installed:</p>
<ul><li>
<p>The <a href="http://www.ruby-lang.org/en/downloads">Ruby</a> language
version 1.9.3 or newer</p>
</li><li>
<p>The <a href="http://rubygems.org/">RubyGems</a> packaging system</p>
<ul><li>
<p>To learn more about RubyGems, please read the <a
href="http://docs.rubygems.org/read/book/1">RubyGems User Guide</a></p>
</li></ul>
</li><li>
<p><a href="../../../../classes/A.html">A</a> working installation of the <a
href="http://www.sqlite.org">SQLite3 Database</a></p>
</li></ul>

<p><a href="../../../../classes/Rails.html">Rails</a> is a web application
framework running on the Ruby programming language. If you have no prior
experience with Ruby, you will find a very steep learning curve diving
straight into <a href="../../../../classes/Rails.html">Rails</a>. There are
some good free resources on the internet for learning Ruby, including:</p>
<ul><li>
<p><a href="http://www.humblelittlerubybook.com">Mr. Neighborly’s Humble
Little Ruby Book</a></p>
</li><li>
<p><a href="http://www.ruby-doc.org/docs/ProgrammingRuby/">Programming
Ruby</a></p>
</li><li>
<p><a href="http://mislav.uniqpath.com/poignant-guide/">Why’s (Poignant) Guide
to Ruby</a></p>
</li></ul>

<h2 id="label-What+is+Rails%3F">What is <a href="../../../../classes/Rails.html">Rails</a>?</h2>

<p><a href="../../../../classes/Rails.html">Rails</a> is a web application
development framework written in the Ruby language. It is designed to make
programming web applications easier by making assumptions about what every
developer needs to get started. It allows you to write less code while
accomplishing more than many other languages and frameworks. Experienced <a
href="../../../../classes/Rails.html">Rails</a> developers also report that
it makes web application development more fun.</p>

<p><a href="../../../../classes/Rails.html">Rails</a> is opinionated software.
It makes the assumption that there is the “best” way to do things, and
it&#39;s designed to encourage that way - and in some cases to discourage
alternatives. If you learn “The <a
href="../../../../classes/Rails.html">Rails</a> Way” you&#39;ll probably
discover a tremendous increase in productivity. If you persist in bringing
old habits from other languages to your <a
href="../../../../classes/Rails.html">Rails</a> development, and trying to
use patterns you learned elsewhere, you may have a less happy experience.</p>

<p>The <a href="../../../../classes/Rails.html">Rails</a> philosophy includes
two major guiding principles:</p>
<ul><li>
<p>DRY - “Don&#39;t Repeat Yourself” - suggests that writing the same code
over and over again is a bad thing.</p>
</li><li>
<p>Convention Over Configuration - means that <a
href="../../../../classes/Rails.html">Rails</a> makes assumptions about
what you want to do and how you&#39;re going to do it, rather than
requiring you to specify every little thing through endless configuration
files.</p>
</li></ul>

<h2 id="label-Creating+a+New+Rails+Project">Creating a New <a href="../../../../classes/Rails.html">Rails</a> <a href="../../../../classes/Project.html">Project</a></h2>

<p>The best way to use this guide is to follow each step as it happens, no
code or step needed to make this example application has been left out, so
you can literally follow along step by step. You can get the complete code
<a
href="https://github.com/lifo/docrails/tree/master/guides/code/getting_started">here</a>.</p>

<p>By following along with this guide, you&#39;ll create a <a
href="../../../../classes/Rails.html">Rails</a> project called
<code>blog</code>, a (very) simple weblog. Before you can start building
the application, you need to make sure that you have <a
href="../../../../classes/Rails.html">Rails</a> itself installed.</p>

<p>TIP: The examples below use <code>#</code> and <code>$</code> to denote
superuser and regular user terminal prompts respectively in a UNIX-like OS.
If you are using Windows, your prompt will look something like
<code>c:\source_code&gt;</code></p>

<h3 id="label-Installing+Rails">Installing <a href="../../../../classes/Rails.html">Rails</a></h3>

<p>Open up a command line prompt. On Mac OS X open Terminal.app, on Windows
choose “Run” from your Start menu and type &#39;cmd.exe&#39;. Any commands
prefaced with a dollar sign <code>$</code> should be run in the command
line. Verify that you have a current version of Ruby installed:</p>

<pre><code>$ ruby -v
ruby 1.9.3p385</code></pre>

<p>To install <a href="../../../../classes/Rails.html">Rails</a>, use the
<code>gem install</code> command provided by RubyGems:</p>

<pre><code>$ gem install rails</code></pre>

<p>TIP. <a href="../../../../classes/A.html">A</a> number of tools exist to
help you quickly install Ruby and Ruby on <a
href="../../../../classes/Rails.html">Rails</a> on your system. Windows
users can use <a href="http://railsinstaller.org">Rails Installer</a>,
while Mac OS X users can use <a href="http://railsoneclick.com">Rails One
Click</a>.</p>

<p>To verify that you have everything installed correctly, you should be able
to run the following:</p>

<pre><code>$ rails --version</code></pre>

<p>If it says something like “Rails 3.2.9”, you are ready to continue.</p>

<h3 id="label-Creating+the+Blog+Application">Creating the <a href="../../../../classes/Blog.html">Blog</a> Application</h3>

<p><a href="../../../../classes/Rails.html">Rails</a> comes with a number of
scripts called generators that are designed to make your development life
easier by creating everything that&#39;s necessary to start working on a
particular task. <a href="../../../../classes/One.html">One</a> of these is
the new application generator, which will provide you with the foundation
of a fresh <a href="../../../../classes/Rails.html">Rails</a> application
so that you don&#39;t have to write it yourself.</p>

<p>To use this generator, open a terminal, navigate to a directory where you
have rights to create files, and type:</p>

<pre><code>$ rails new blog</code></pre>

<p>This will create a <a href="../../../../classes/Rails.html">Rails</a>
application called <a href="../../../../classes/Blog.html">Blog</a> in a
directory called blog and install the gem dependencies that are already
mentioned in <code>Gemfile</code> using <code>bundle install</code>.</p>

<p>TIP: You can see all of the command line options that the <a
href="../../../../classes/Rails.html">Rails</a> application builder accepts
by running <code>rails new -h</code>.</p>

<p>After you create the blog application, switch to its folder to continue
work directly in that application:</p>

<pre><code>$ cd blog</code></pre>

<p>The <code>rails new blog</code> command we ran above created a folder in
your working directory called <code>blog</code>. The <code>blog</code>
directory has a number of auto-generated files and folders that make up the
structure of a <a href="../../../../classes/Rails.html">Rails</a>
application. Most of the work in this tutorial will happen in the
<code>app/</code> folder, but here&#39;s a basic rundown on the function of
each of the files and folders that <a
href="../../../../classes/Rails.html">Rails</a> created by default:</p>

<p>| File/Folder | Purpose | | ———– | ——- | |app/|Contains the controllers,
models, views, helpers, mailers and assets for your application. You&#39;ll
focus on this folder for the remainder of this guide.| |bin/|Contains the
rails script that starts your app and can contain other scripts you use to
deploy or run your application.| |config/|Configure your application&#39;s
runtime rules, routes, database, and more. This is covered in more detail
in <a href="http://configuring.html">Configuring Rails Applications</a>|
|config.ru|Rack configuration for <a
href="../../../../classes/Rack.html">Rack</a> based servers used to start
the application.| |db/|Contains your current database schema, as well as
the database migrations.| |Gemfile&lt;br /&gt;Gemfile.lock|These files
allow you to specify what gem dependencies are needed for your <a
href="../../../../classes/Rails.html">Rails</a> application. These files
are used by the Bundler gem. For more information about Bundler, see <a
href="http://gembundler.com">the Bundler website</a> | |lib/|Extended
modules for your application.| |log/|Application log files.| |public/|The
only folder seen to the world as-is. Contains the static files and compiled
assets.| |Rakefile|This file locates and loads tasks that can be run from
the command line. The task definitions are defined throughout the
components of <a href="../../../../classes/Rails.html">Rails</a>. Rather
than changing <a href="../../Rakefile.html">Rakefile</a>, you should add
your own tasks by adding files to the lib/tasks directory of your
application.| |README.rdoc|This is a brief instruction manual for your
application. You should edit this file to tell others what your application
does, how to set it up, and so on.| |test/|Unit tests, fixtures, and other
test apparatus. These are covered in <a href="http://testing.html">Testing
Rails Applications</a>| |tmp/|Temporary files (like cache, pid and session
files)| |vendor/|A place for all third-party code. In a typical <a
href="../../../../classes/Rails.html">Rails</a> application, this includes
Ruby Gems and the <a href="../../../../classes/Rails.html">Rails</a> source
code (if you optionally install it into your project).|</p>

<h2 id="label-Hello%2C+Rails%21">Hello, <a href="../../../../classes/Rails.html">Rails</a>!</h2>

<p>To begin with, let&#39;s get some text up on screen quickly. To do this,
you need to get your <a href="../../../../classes/Rails.html">Rails</a>
application server running.</p>

<h3 id="label-Starting+up+the+Web+Server">Starting up the <a href="../../../../classes/Web.html">Web</a> Server</h3>

<p>You actually have a functional <a
href="../../../../classes/Rails.html">Rails</a> application already. To see
it, you need to start a web server on your development machine. You can do
this by running:</p>

<pre><code>$ rails server</code></pre>

<p>TIP: Compiling CoffeeScript to JavaScript requires a JavaScript runtime and
the absence of a runtime will give you an <code>execjs</code> error.
Usually Mac OS X and Windows come with a JavaScript runtime installed. <a
href="../../../../classes/Rails.html">Rails</a> adds the
<code>therubyracer</code> gem to <a href="../../Gemfile.html">Gemfile</a>
in a commented line for new apps and you can uncomment if you need it.
<code>therubyrhino</code> is the recommended runtime for JRuby users and is
added by default to <a href="../../Gemfile.html">Gemfile</a> in apps
generated under JRuby. You can investigate about all the supported runtimes
at <a href="https://github.com/sstephenson/execjs#readme">ExecJS</a>.</p>

<p>This will fire up WEBrick, a webserver built into Ruby by default. To see
your application in action, open a browser window and navigate to <a
href="http://localhost:3000">localhost:3000</a>. You should see the <a
href="../../../../classes/Rails.html">Rails</a> default information page:</p>

<p><img src="http://images/rails_welcome.png" /></p>

<p>TIP: To stop the web server, hit Ctrl+C in the terminal window where
it&#39;s running. To verify the server has stopped you should see your
command prompt cursor again. For most UNIX-like systems including Mac OS X
this will be a dollar sign <code>$</code>. In development mode, <a
href="../../../../classes/Rails.html">Rails</a> does not generally require
you to restart the server; changes you make in files will be automatically
picked up by the server.</p>

<p>The “Welcome Aboard” page is the <em>smoke test</em> for a new <a
href="../../../../classes/Rails.html">Rails</a> application: it makes sure
that you have your software configured correctly enough to serve a page.
You can also click on the <em>About your application’s environment</em>
link to see a summary of your application&#39;s environment.</p>

<h3 id="label-Say+%22Hello%22%2C+Rails">Say “Hello”, <a href="../../../../classes/Rails.html">Rails</a></h3>

<p>To get <a href="../../../../classes/Rails.html">Rails</a> saying “Hello”,
you need to create at minimum a <em>controller</em> and a <em>view</em>.</p>

<p><a href="../../../../classes/A.html">A</a> controller&#39;s purpose is to
receive specific requests for the application. <em>Routing</em> decides
which controller receives which requests. Often, there is more than one
route to each controller, and different routes can be served by different
<em>actions</em>. Each action&#39;s purpose is to collect information to
provide it to a view.</p>

<p><a href="../../../../classes/A.html">A</a> view&#39;s purpose is to display
this information in a human readable format. An important distinction to
make is that it is the <em>controller</em>, not the view, where information
is collected. The view should just display that information. By default,
view templates are written in a language called <a
href="../../../../classes/ERB.html">ERB</a> (Embedded Ruby) which is
converted by the request cycle in <a
href="../../../../classes/Rails.html">Rails</a> before being sent to the
user.</p>

<p>To create a new controller, you will need to run the “controller” generator
and tell it you want a controller called “welcome” with an action called
“index”, just like this:</p>

<pre><code>$ rails generate controller welcome index</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> will create several
files and a route for you.</p>

<pre><code>create  app/controllers/welcome_controller.rb
 route  get &quot;welcome/index&quot;
invoke  erb
create    app/views/welcome
create    app/views/welcome/index.html.erb
invoke  test_unit
create    test/controllers/welcome_controller_test.rb
invoke  helper
create    app/helpers/welcome_helper.rb
invoke    test_unit
create      test/helpers/welcome_helper_test.rb
invoke  assets
invoke    coffee
create      app/assets/javascripts/welcome.js.coffee
invoke    scss
create      app/assets/stylesheets/welcome.css.scss</code></pre>

<p>Most important of these are of course the controller, located at
<code>app/controllers/welcome_controller.rb</code> and the view, located at
<code>app/views/welcome/index.html.erb</code>.</p>

<p>Open the <code>app/views/welcome/index.html.erb</code> file in your text
editor and edit it to contain a single line of code:</p>

<pre><code>&lt;h1&gt;Hello, Rails!&lt;/h1&gt;</code></pre>

<h3 id="label-Setting+the+Application+Home+Page">Setting the Application Home Page</h3>

<p>Now that we have made the controller and view, we need to tell <a
href="../../../../classes/Rails.html">Rails</a> when we want Hello <a
href="../../../../classes/Rails.html">Rails</a>! to show up. In our case,
we want it to show up when we navigate to the root URL of our site, <a
href="http://localhost:3000">localhost:3000</a>. At the moment, “Welcome
Aboard” is occupying that spot.</p>

<p>Next, you have to tell <a href="../../../../classes/Rails.html">Rails</a>
where your actual home page is located.</p>

<p>Open the file <code>config/routes.rb</code> in your editor.</p>

<pre><code>Blog::Application.routes.draw do
  get &quot;welcome/index&quot;

  # The priority is based upon order of creation:
  # first created -&gt; highest priority.
  # ...
  # You can have the root of your site routed with &quot;root&quot;
  # root to: &quot;welcome#index&quot;
</code></pre>

<p>This is your application&#39;s <em>routing file</em> which holds entries in
a special DSL (domain-specific language) that tells <a
href="../../../../classes/Rails.html">Rails</a> how to connect incoming
requests to controllers and actions. This file contains many sample routes
on commented lines, and one of them actually shows you how to connect the
root of your site to a specific controller and action. Find the line
beginning with <code>root :to</code> and uncomment it. It should look
something like the following:</p>

<pre><code>root to: &quot;welcome#index&quot;
</code></pre>

<p>The <code>root to: &quot;welcome#index&quot;</code> tells <a
href="../../../../classes/Rails.html">Rails</a> to map requests to the root
of the application to the welcome controller&#39;s index action and
<code>get &quot;welcome/index&quot;</code> tells <a
href="../../../../classes/Rails.html">Rails</a> to map requests to <a
href="http://localhost:3000/welcome/index">localhost:3000/welcome/index</a>
to the welcome controller&#39;s index action. This was created earlier when
you ran the controller generator (<code>rails generate controller welcome
index</code>).</p>

<p>If you navigate to <a href="http://localhost:3000">localhost:3000</a> in
your browser, you&#39;ll see the <code>Hello, Rails!</code> message you put
into <code>app/views/welcome/index.html.erb</code>, indicating that this
new route is indeed going to <code>WelcomeController</code>&#39;s
<code>index</code> action and is rendering the view correctly.</p>

<p>TIP: For more information about routing, refer to <a
href="http://routing.html">Rails Routing from the Outside In</a>.</p>

<h2 id="label-Getting+Up+and+Running">Getting Up and Running</h2>

<p>Now that you&#39;ve seen how to create a controller, an action and a view,
let&#39;s create something with a bit more substance.</p>

<p>In the <a href="../../../../classes/Blog.html">Blog</a> application, you
will now create a new <em>resource</em>. <a
href="../../../../classes/A.html">A</a> resource is the term used for a
collection of similar objects, such as posts, people or animals. You can
create, read, update and destroy items for a resource and these operations
are referred to as <em>CRUD</em> operations.</p>

<p>In the next section, you will add the ability to create new posts in your
application and be able to view them. This is the “C” and the “R” from
CRUD: creation and reading. The form for doing this will look like this:</p>

<p><img src="http://images/getting_started/new_post.png" /></p>

<p>It will look a little basic for now, but that&#39;s ok. We&#39;ll look at
improving the styling for it afterwards.</p>

<h3 id="label-Laying+down+the+ground+work">Laying down the ground work</h3>

<p>The first thing that you are going to need to create a new post within the
application is a place to do that. <a
href="../../../../classes/A.html">A</a> great place for that would be at
<code>/posts/new</code>. If you attempt to navigate to that now — by
visiting <a
href="http://localhost:3000/posts/new">localhost:3000/posts/new</a> — <a
href="../../../../classes/Rails.html">Rails</a> will give you a routing
error:</p>

<p><img src="http://images/getting_started/routing_error_no_route_matches.png"
/></p>

<p>This is because there is nowhere inside the routes for the application —
defined inside <code>config/routes.rb</code> — that defines this route. By
default, <a href="../../../../classes/Rails.html">Rails</a> has no routes
configured at all, besides the root route you defined earlier, and so you
must define your routes as you need them.</p>

<p>To do this, you&#39;re going to need to create a route inside
<code>config/routes.rb</code> file, on a new line between the
<code>do</code> and the <code>end</code> for the <code>draw</code> method:</p>

<pre><code>get &quot;posts/new&quot;
</code></pre>

<p>This route is a super-simple route: it defines a new route that only
responds to <code>GET</code> requests, and that the route is at
<code>posts/new</code>. But how does it know where to go without the use of
the <code>:to</code> option? Well, <a
href="../../../../classes/Rails.html">Rails</a> uses a sensible default
here: <a href="../../../../classes/Rails.html">Rails</a> will assume that
you want this route to go to the new action inside the posts controller.</p>

<p>With the route defined, requests can now be made to <code>/posts/new</code>
in the application. Navigate to <a
href="http://localhost:3000/posts/new">localhost:3000/posts/new</a> and
you&#39;ll see another routing error:</p>

<p><img src="http://images/getting_started/routing_error_no_controller.png" /></p>

<p>This error is happening because this route need a controller to be defined.
The route is attempting to find that controller so it can serve the
request, but with the controller undefined, it just can&#39;t do that. The
solution to this particular problem is simple: you need to create a
controller called <code>PostsController</code>. You can do this by running
this command:</p>

<pre><code>$ rails g controller posts</code></pre>

<p>If you open up the newly generated
<code>app/controllers/posts_controller.rb</code> you&#39;ll see a fairly
empty controller:</p>

<pre><code>class PostsController &lt; ApplicationController
end
</code></pre>

<p><a href="../../../../classes/A.html">A</a> controller is simply a class
that is defined to inherit from <code>ApplicationController</code>.
It&#39;s inside this class that you&#39;ll define methods that will become
the actions for this controller. These actions will perform CRUD operations
on the posts within our system.</p>

<p>If you refresh <a
href="http://localhost:3000/posts/new">localhost:3000/posts/new</a> now,
you&#39;ll get a new error:</p>

<p><img src="http://images/getting_started/unknown_action_new_for_posts.png"
/></p>

<p>This error indicates that <a
href="../../../../classes/Rails.html">Rails</a> cannot find the
<code>new</code> action inside the <code>PostsController</code> that you
just generated. This is because when controllers are generated in <a
href="../../../../classes/Rails.html">Rails</a> they are empty by default,
unless you tell it you wanted actions during the generation process.</p>

<p>To manually define an action inside a controller, all you need to do is to
define a new method inside the controller. Open
<code>app/controllers/posts_controller.rb</code> and inside the
<code>PostsController</code> class, define a <code>new</code> method like
this:</p>

<pre><code>def new
end
</code></pre>

<p>With the <code>new</code> method defined in <code>PostsController</code>,
if you refresh <a
href="http://localhost:3000/posts/new">localhost:3000/posts/new</a>
you&#39;ll see another error:</p>

<p><img src="http://images/getting_started/template_is_missing_posts_new.png"
/></p>

<p>You&#39;re getting this error now because <a
href="../../../../classes/Rails.html">Rails</a> expects plain actions like
this one to have views associated with them to display their information.
With no view available, <a href="../../../../classes/Rails.html">Rails</a>
errors out.</p>

<p>In the above image, the bottom line has been truncated. Let&#39;s see what
the full thing looks like:</p>
<blockquote>
Missing template posts/new, application/new with {locale:[:en], formats:[:html], handlers:[:erb, :builder, :coffee]}. Searched in: * "/path/to/blog/app/views"
</blockquote>
<p>That&#39;s quite a lot of text! Let&#39;s quickly go through and understand
what each part of it does.</p>

<p>The first part identifies what template is missing. In this case, it&#39;s
the <code>posts/new</code> template. <a
href="../../../../classes/Rails.html">Rails</a> will first look for this
template. If not found, then it will attempt to load a template called
<code>application/new</code>. It looks for one here because the
<code>PostsController</code> inherits from
<code>ApplicationController</code>.</p>

<p>The next part of the message contains a hash. The <code>:locale</code> key
in this hash simply indicates what spoken language template should be
retrieved. By default, this is the English — or “en” — template. The next
key, <code>:formats</code> specifies the format of template to be served in
response. The default format is <code>:html</code>, and so <a
href="../../../../classes/Rails.html">Rails</a> is looking for an <a
href="../../../../classes/HTML.html">HTML</a> template. The final key,
<code>:handlers</code>, is telling us what <em>template handlers</em> could
be used to render our template. <code>:erb</code> is most commonly used for
<a href="../../../../classes/HTML.html">HTML</a> templates,
<code>:builder</code> is used for XML templates, and <code>:coffee</code>
uses CoffeeScript to build JavaScript templates.</p>

<p>The final part of this message tells us where <a
href="../../../../classes/Rails.html">Rails</a> has looked for the
templates. Templates within a basic <a
href="../../../../classes/Rails.html">Rails</a> application like this are
kept in a single location, but in more complex applications it could be
many different paths.</p>

<p>The simplest template that would work in this case would be one located at
<code>app/views/posts/new.html.erb</code>. The extension of this file name
is key: the first extension is the <em>format</em> of the template, and the
second extension is the <em>handler</em> that will be used. <a
href="../../../../classes/Rails.html">Rails</a> is attempting to find a
template called <code>posts/new</code> within <code>app/views</code> for
the application. The format for this template can only be <code>html</code>
and the handler must be one of <code>erb</code>, <code>builder</code> or
<code>coffee</code>. Because you want to create a new <a
href="../../../../classes/HTML.html">HTML</a> form, you will be using the
<code>ERB</code> language. Therefore the file should be called
<code>posts/new.html.erb</code> and needs to be located inside the
<code>app/views</code> directory of the application.</p>

<p>Go ahead now and create a new file at
<code>app/views/posts/new.html.erb</code> and write this content in it:</p>

<pre><code>&lt;h1&gt;New Post&lt;/h1&gt;</code></pre>

<p>When you refresh <a
href="http://localhost:3000/posts/new">localhost:3000/posts/new</a>
you&#39;ll now see that the page has a title. The route, controller, action
and view are now working harmoniously! It&#39;s time to create the form for
a new post.</p>

<h3 id="label-The+first+form">The first form</h3>

<p>To create a form within this template, you will use a <em>form
builder</em>. The primary form builder for <a
href="../../../../classes/Rails.html">Rails</a> is provided by a helper
method called <code>form_for</code>. To use this method, add this code into
<code>app/views/posts/new.html.erb</code>:</p>

<pre><code>&lt;%= form_for :post do |f| %&gt;
  &lt;p&gt;
    &lt;%= f.label :title %&gt;&lt;br&gt;
    &lt;%= f.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.label :text %&gt;&lt;br&gt;
    &lt;%= f.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;</code></pre>

<p>If you refresh the page now, you&#39;ll see the exact same form as in the
example. Building forms in <a
href="../../../../classes/Rails.html">Rails</a> is really just that easy!</p>

<p>When you call <code>form_for</code>, you pass it an identifying object for
this form. In this case, it&#39;s the symbol <code>:post</code>. This tells
the <code>form_for</code> helper what this form is for. Inside the block
for this method, the <code>FormBuilder</code> object — represented by
<code>f</code> — is used to build two labels and two text fields, one each
for the title and text of a post. Finally, a call to <code>submit</code> on
the <code>f</code> object will create a submit button for the form.</p>

<p>There&#39;s one problem with this form though. If you inspect the <a
href="../../../../classes/HTML.html">HTML</a> that is generated, by viewing
the source of the page, you will see that the <code>action</code> attribute
for the form is pointing at <code>/posts/new</code>. This is a problem
because this route goes to the very page that you&#39;re on right at the
moment, and that route should only be used to display the form for a new
post.</p>

<p>The form needs to use a different URL in order to go somewhere else. This
can be done quite simply with the <code>:url</code> option of
<code>form_for</code>. Typically in <a
href="../../../../classes/Rails.html">Rails</a>, the action that is used
for new form submissions like this is called “create”, and so the form
should be pointed to that action.</p>

<p>Edit the <code>form_for</code> line inside
<code>app/views/posts/new.html.erb</code> to look like this:</p>

<pre><code>&lt;%= form_for :post, url: { action: :create } do |f| %&gt;</code></pre>

<p>In this example, a <code>Hash</code> object is passed to the
<code>:url</code> option. What <a
href="../../../../classes/Rails.html">Rails</a> will do with this is that
it will point the form to the <code>create</code> action of the current
controller, the <code>PostsController</code>, and will send a
<code>POST</code> request to that route. For this to work, you will need to
add a route to <code>config/routes.rb</code>, right underneath the one for
“posts/new”:</p>

<pre><code>post &quot;posts&quot; =&gt; &quot;posts#create&quot;
</code></pre>

<p>By using the <code>post</code> method rather than the <code>get</code>
method, <a href="../../../../classes/Rails.html">Rails</a> will define a
route that will only respond to POST methods. The POST method is the
typical method used by forms all over the web.</p>

<p>With the form and its associated route defined, you will be able to fill in
the form and then click the submit button to begin the process of creating
a new post, so go ahead and do that. When you submit the form, you should
see a familiar error:</p>

<p><img
src="http://images/getting_started/unknown_action_create_for_posts.png" /></p>

<p>You now need to create the <code>create</code> action within the
<code>PostsController</code> for this to work.</p>

<h3 id="label-Creating+posts">Creating posts</h3>

<p>To make the “Unknown action” go away, you can define a <code>create</code>
action within the <code>PostsController</code> class in
<code>app/controllers/posts_controller.rb</code>, underneath the
<code>new</code> action:</p>

<pre><code>class PostsController &lt; ApplicationController
  def new
  end

  def create
  end
end
</code></pre>

<p>If you re-submit the form now, you&#39;ll see another familiar error: a
template is missing. That&#39;s ok, we can ignore that for now. What the
<code>create</code> action should be doing is saving our new post to a
database.</p>

<p>When a form is submitted, the fields of the form are sent to <a
href="../../../../classes/Rails.html">Rails</a> as <em>parameters</em>.
These parameters can then be referenced inside the controller actions,
typically to perform a particular task. To see what these parameters look
like, change the <code>create</code> action to this:</p>

<pre><code>def create
  render text: params[:post].inspect
end
</code></pre>

<p>The <code>render</code> method here is taking a very simple hash with a key
of <code>text</code> and value of <code>params[:post].inspect</code>. The
<code>params</code> method is the object which represents the parameters
(or fields) coming in from the form. The <code>params</code> method returns
an <code>ActiveSupport::HashWithIndifferentAccess</code> object, which
allows you to access the keys of the hash using either strings or symbols.
In this situation, the only parameters that matter are the ones from the
form.</p>

<p>If you re-submit the form one more time you&#39;ll now no longer get the
missing template error. Instead, you&#39;ll see something that looks like
the following:</p>

<pre><code>{&quot;title&quot;=&gt;&quot;First post!&quot;, &quot;text&quot;=&gt;&quot;This is my first post.&quot;}
</code></pre>

<p>This action is now displaying the parameters for the post that are coming
in from the form. However, this isn&#39;t really all that helpful. Yes, you
can see the parameters but nothing in particular is being done with them.</p>

<h3 id="label-Creating+the+Post+model">Creating the <a href="../../../../classes/Post.html">Post</a> model</h3>

<p>Models in <a href="../../../../classes/Rails.html">Rails</a> use a singular
name, and their corresponding database tables use a plural name. <a
href="../../../../classes/Rails.html">Rails</a> provides a generator for
creating models, which most <a
href="../../../../classes/Rails.html">Rails</a> developers tend to use when
creating new models. To create the new model, run this command in your
terminal:</p>

<pre><code>$ rails generate model Post title:string text:text</code></pre>

<p>With that command we told <a
href="../../../../classes/Rails.html">Rails</a> that we want a
<code>Post</code> model, together with a <em>title</em> attribute of type
string, and a <em>text</em> attribute of type text. Those attributes are
automatically added to the <code>posts</code> table in the database and
mapped to the <code>Post</code> model.</p>

<p><a href="../../../../classes/Rails.html">Rails</a> responded by creating a
bunch of files. For now, we&#39;re only interested in
<code>app/models/post.rb</code> and
<code>db/migrate/20120419084633_create_posts.rb</code> (your name could be
a bit different). The latter is responsible for creating the database
structure, which is what we&#39;ll look at next.</p>

<p>TIP: Active Record is smart enough to automatically map column names to
model attributes, which means you don&#39;t have to declare attributes
inside <a href="../../../../classes/Rails.html">Rails</a> models, as that
will be done automatically by Active Record.</p>

<h3 id="label-Running+a+Migration">Running a Migration</h3>

<p>As we&#39;ve just seen, <code>rails generate model</code> created a
<em>database migration</em> file inside the <code>db/migrate</code>
directory. Migrations are Ruby classes that are designed to make it simple
to create and modify database tables. <a
href="../../../../classes/Rails.html">Rails</a> uses rake commands to run
migrations, and it&#39;s possible to undo a migration after it&#39;s been
applied to your database. Migration filenames include a timestamp to ensure
that they&#39;re processed in the order that they were created.</p>

<p>If you look in the <code>db/migrate/20120419084633_create_posts.rb</code>
file (remember, yours will have a slightly different name), here&#39;s what
you&#39;ll find:</p>

<pre><code>class CreatePosts &lt; ActiveRecord::Migration
  def change
    create_table :posts do |t|
      t.string :title
      t.text :text

      t.timestamps
    end
  end
end
</code></pre>

<p>The above migration creates a method named <code>change</code> which will
be called when you run this migration. The action defined in this method is
also reversible, which means <a
href="../../../../classes/Rails.html">Rails</a> knows how to reverse the
change made by this migration, in case you want to reverse it later. When
you run this migration it will create a <code>posts</code> table with one
string column and a text column. It also creates two timestamp fields to
allow <a href="../../../../classes/Rails.html">Rails</a> to track post
creation and update times.</p>

<p>TIP: For more information about migrations, refer to <a
href="http://migrations.html">Rails Database Migrations</a>.</p>

<p>At this point, you can use a rake command to run the migration:</p>

<pre><code>$ rake db:migrate</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> will execute this
migration command and tell you it created the Posts table.</p>

<pre><code>==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -&gt; 0.0019s
==  CreatePosts: migrated (0.0020s) ===========================================</code></pre>

<p>NOTE. Because you&#39;re working in the development environment by default,
this command will apply to the database defined in the
<code>development</code> section of your <code>config/database.yml</code>
file. If you would like to execute migrations in another environment, for
instance in production, you must explicitly pass it when invoking the
command: <code>rake db:migrate RAILS_ENV=production</code>.</p>

<h3 id="label-Saving+data+in+the+controller">Saving data in the controller</h3>

<p>Back in <code>posts_controller</code>, we need to change the
<code>create</code> action to use the new <code>Post</code> model to save
the data in the database. Open
<code>app/controllers/posts_controller.rb</code> and change the
<code>create</code> action to look like this:</p>

<pre><code>def create
  @post = Post.new(params[:post])

  @post.save
  redirect_to action: :show, id: @post.id
end
</code></pre>

<p>Here&#39;s what&#39;s going on: every <a
href="../../../../classes/Rails.html">Rails</a> model can be initialized
with its respective attributes, which are automatically mapped to the
respective database columns. In the first line we do just that (remember
that <code>params[:post]</code> contains the attributes we&#39;re
interested in). Then, <code>@post.save</code> is responsible for saving the
model in the database. Finally, we redirect the user to the
<code>show</code> action, which we&#39;ll define later.</p>

<p>TIP: As we&#39;ll see later, <code>@post.save</code> returns a boolean
indicating whether the model was saved or not.</p>

<h3 id="label-Showing+Posts">Showing Posts</h3>

<p>If you submit the form again now, <a
href="../../../../classes/Rails.html">Rails</a> will complain about not
finding the <code>show</code> action. That&#39;s not very useful though, so
let&#39;s add the <code>show</code> action before proceeding. Open
<code>config/routes.rb</code> and add the following route:</p>

<pre><code>get &quot;posts/:id&quot; =&gt; &quot;posts#show&quot;
</code></pre>

<p>The special syntax <code>:id</code> tells rails that this route expects an
<code>:id</code> parameter, which in our case will be the id of the post.
Note that this time we had to specify the actual mapping,
<code>posts#show</code> because otherwise <a
href="../../../../classes/Rails.html">Rails</a> would not know which action
to render.</p>

<p>As we did before, we need to add the <code>show</code> action in
<code>app/controllers/posts_controller.rb</code> and its respective view.</p>

<pre><code>def show
  @post = Post.find(params[:id])
end
</code></pre>

<p><a href="../../../../classes/A.html">A</a> couple of things to note. We use
<code>Post.find</code> to find the post we&#39;re interested in. We also
use an instance variable (prefixed by <code>@</code>) to hold a reference
to the post object. We do this because <a
href="../../../../classes/Rails.html">Rails</a> will pass all instance
variables to the view.</p>

<p>Now, create a new file <code>app/view/posts/show.html.erb</code> with the
following content:</p>

<pre><code>&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @post.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @post.text %&gt;
&lt;/p&gt;</code></pre>

<p>If you now go to <a
href="http://localhost:3000/posts/new">localhost:3000/posts/new</a>
you&#39;ll <em>almost</em> be able to create a post. Try it! You should get
an error that looks like this:</p>

<p><img
src="http://images/getting_started/forbidden_attributes_for_new_post.png"
/></p>

<p><a href="../../../../classes/Rails.html">Rails</a> has several security
features that help you write secure applications, and you&#39;re running
into one of them now. This one is called &#39;strong_parameters,&#39; which
requires us to tell <a href="../../../../classes/Rails.html">Rails</a>
exactly which parameters we want to accept in our controllers. In this
case, we want to allow the &#39;title&#39; and &#39;text&#39; parameters,
so change your <code>create</code> controller action to look like this:</p>

<pre><code>def create
    @post = Post.new(params[:post].permit(:title, :text))

    @post.save
    redirect_to action: :show, id: @post.id
  end
</code></pre>

<p>See the <code>permit</code>? It allows us to accept both <code>title</code>
and <code>text</code> in this action. With this change, you should finally
be able to create new <code>Post</code>s. Visit <a
href="http://localhost:3000/posts/new">localhost:3000/posts/new</a> and
give it a try!</p>

<p><img src="http://images/getting_started/show_action_for_posts.png" /></p>

<h3 id="label-Listing+all+posts">Listing all posts</h3>

<p>We still need a way to list all our posts, so let&#39;s do that. As usual,
we&#39;ll need a route placed into <code>config/routes.rb</code>:</p>

<pre><code>get &quot;posts&quot; =&gt; &quot;posts#index&quot;
</code></pre>

<p>And an action for that route inside the <code>PostsController</code> in the
<code>app/controllers/posts_controller.rb</code> file:</p>

<pre><code>def index
  @posts = Post.all
end
</code></pre>

<p>And then finally a view for this action, located at
<code>app/views/posts/index.html.erb</code>:</p>

<pre><code>&lt;h1&gt;Listing posts&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Text&lt;/th&gt;
  &lt;/tr&gt;

  &lt;% @posts.each do |post| %&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;%= post.title %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= post.text %&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;% end %&gt;
&lt;/table&gt;</code></pre>

<p>Now if you go to <code>http://localhost:3000/posts</code> you will see a
list of all the posts that you have created.</p>

<h3 id="label-Adding+links">Adding links</h3>

<p>You can now create, show, and list posts. Now let&#39;s add some links to
navigate through pages.</p>

<p>Open <code>app/views/welcome/index.html.erb</code> and modify it as
follows:</p>

<pre><code>&lt;h1&gt;Hello, Rails!&lt;/h1&gt;
&lt;%= link_to &quot;My Blog&quot;, controller: &quot;posts&quot; %&gt;</code></pre>

<p>The <code>link_to</code> method is one of Rails&#39; built-in view helpers.
It creates a hyperlink based on text to display and where to go - in this
case, to the path for posts.</p>

<p>Let&#39;s add links to the other views as well, starting with adding this
“New Post” link to <code>app/views/posts/index.html.erb</code>, placing it
above the <code>&lt;table&gt;</code> tag:</p>

<pre><code>&lt;%= link_to &#39;New post&#39;, action: :new %&gt;</code></pre>

<p>This link will allow you to bring up the form that lets you create a new
post. You should also add a link to this template —
<code>app/views/posts/new.html.erb</code> — to go back to the
<code>index</code> action. Do this by adding this underneath the form in
this template:</p>

<pre><code>&lt;%= form_for :post do |f| %&gt;
  ...
&lt;% end %&gt;

&lt;%= link_to &#39;Back&#39;, action: :index %&gt;</code></pre>

<p>Finally, add another link to the <code>app/views/posts/show.html.erb</code>
template to go back to the <code>index</code> action as well, so that
people who are viewing a single post can go back and view the whole list
again:</p>

<pre><code>&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @post.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @post.text %&gt;
&lt;/p&gt;

&lt;%= link_to &#39;Back&#39;, action: :index %&gt;</code></pre>

<p>TIP: If you want to link to an action in the same controller, you don&#39;t
need to specify the <code>:controller</code> option, as <a
href="../../../../classes/Rails.html">Rails</a> will use the current
controller by default.</p>

<p>TIP: In development mode (which is what you&#39;re working in by default),
<a href="../../../../classes/Rails.html">Rails</a> reloads your application
with every browser request, so there&#39;s no need to stop and restart the
web server when a change is made.</p>

<h3 id="label-Allowing+the+update+of+fields">Allowing the update of fields</h3>

<p>The model file, <code>app/models/post.rb</code> is about as simple as it
can get:</p>

<pre><code>class Post &lt; ActiveRecord::Base
end
</code></pre>

<p>There isn&#39;t much to this file - but note that the <code>Post</code>
class inherits from <code>ActiveRecord::Base</code>. Active Record supplies
a great deal of functionality to your <a
href="../../../../classes/Rails.html">Rails</a> models for free, including
basic database CRUD (Create, Read, Update, Destroy) operations, data
validation, as well as sophisticated search support and the ability to
relate multiple models to one another.</p>

<h3 id="label-Adding+Some+Validation">Adding Some Validation</h3>

<p><a href="../../../../classes/Rails.html">Rails</a> includes methods to help
you validate the data that you send to models. Open the
<code>app/models/post.rb</code> file and edit it:</p>

<pre><code>class Post &lt; ActiveRecord::Base
  validates :title, presence: true,
                    length: { minimum: 5 }
end
</code></pre>

<p>These changes will ensure that all posts have a title that is at least five
characters long. <a href="../../../../classes/Rails.html">Rails</a> can
validate a variety of conditions in a model, including the presence or
uniqueness of columns, their format, and the existence of associated
objects. Validations are covered in detail in <a
href="http://active_record_validations.html">Active Record Validations</a></p>

<p>With the validation now in place, when you call <code>@post.save</code> on
an invalid post, it will return <code>false</code>. If you open
<code>app/controllers/posts_controller.rb</code> again, you&#39;ll notice
that we don&#39;t check the result of calling <code>@post.save</code>
inside the <code>create</code> action. If <code>@post.save</code> fails in
this situation, we need to show the form back to the user. To do this,
change the <code>new</code> and <code>create</code> actions inside
<code>app/controllers/posts_controller.rb</code> to these:</p>

<pre><code>def new
  @post = Post.new
end

def create
  @post = Post.new(params[:post].permit(:title, :text))

  if @post.save
    redirect_to action: :show, id: @post.id
  else
    render &#39;new&#39;
  end
end
</code></pre>

<p>The <code>new</code> action is now creating a new instance variable called
<code>@post</code>, and you&#39;ll see why that is in just a few moments.</p>

<p>Notice that inside the <code>create</code> action we use
<code>render</code> instead of <code>redirect_to</code> when
<code>save</code> returns <code>false</code>. The <code>render</code>
method is used so that the <code>@post</code> object is passed back to the
<code>new</code> template when it is rendered. This rendering is done
within the same request as the form submission, whereas the
<code>redirect_to</code> will tell the browser to issue another request.</p>

<p>If you reload <a
href="http://localhost:3000/posts/new">localhost:3000/posts/new</a> and try
to save a post without a title, <a
href="../../../../classes/Rails.html">Rails</a> will send you back to the
form, but that&#39;s not very useful. You need to tell the user that
something went wrong. To do that, you&#39;ll modify
<code>app/views/posts/new.html.erb</code> to check for error messages:</p>

<pre><code>&lt;%= form_for :post, url: { action: :create } do |f| %&gt;
  &lt;% if @post.errors.any? %&gt;
  &lt;div id=&quot;errorExplanation&quot;&gt;
    &lt;h2&gt;&lt;%= pluralize(@post.errors.count, &quot;error&quot;) %&gt; prohibited
      this post from being saved:&lt;/h2&gt;
    &lt;ul&gt;
    &lt;% @post.errors.full_messages.each do |msg| %&gt;
      &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
    &lt;% end %&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &lt;% end %&gt;
  &lt;p&gt;
    &lt;%= f.label :title %&gt;&lt;br&gt;
    &lt;%= f.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.label :text %&gt;&lt;br&gt;
    &lt;%= f.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;%= link_to &#39;Back&#39;, action: :index %&gt;</code></pre>

<p><a href="../../../../classes/A.html">A</a> few things are going on. We
check if there are any errors with <code>@post.errors.any?</code>, and in
that case we show a list of all errors with
<code>@post.errors.full_messages</code>.</p>

<p><code>pluralize</code> is a rails helper that takes a number and a string
as its arguments. If the number is greater than one, the string will be
automatically pluralized.</p>

<p>The reason why we added <code>@post = Post.new</code> in
<code>posts_controller</code> is that otherwise <code>@post</code> would be
<code>nil</code> in our view, and calling <code>@post.errors.any?</code>
would throw an error.</p>

<p>TIP: <a href="../../../../classes/Rails.html">Rails</a> automatically wraps
fields that contain an error with a div with class
<code>field_with_errors</code>. You can define a css rule to make them
standout.</p>

<p>Now you&#39;ll get a nice error message when saving a post without title
when you attempt to do just that on the new post form <a
href="http://localhost:3000/posts/new">(http://localhost:3000/posts/new)</a>.</p>

<p><img src="http://images/getting_started/form_with_errors.png" /></p>

<h3 id="label-Updating+Posts">Updating Posts</h3>

<p>We&#39;ve covered the “CR” part of CRUD. Now let&#39;s focus on the “U”
part, updating posts.</p>

<p>The first step we&#39;ll take is adding an <code>edit</code> action to
<code>posts_controller</code>.</p>

<p>Start by adding a route to <code>config/routes.rb</code>:</p>

<pre><code>get &quot;posts/:id/edit&quot; =&gt; &quot;posts#edit&quot;
</code></pre>

<p>And then add the controller action:</p>

<pre><code>def edit
  @post = Post.find(params[:id])
end
</code></pre>

<p>The view will contain a form similar to the one we used when creating new
posts. Create a file called <code>app/views/posts/edit.html.erb</code> and
make it look as follows:</p>

<pre><code>&lt;h1&gt;Editing post&lt;/h1&gt;

&lt;%= form_for :post, url: { action: :update, id: @post.id },
method: :patch do |f| %&gt;
  &lt;% if @post.errors.any? %&gt;
  &lt;div id=&quot;errorExplanation&quot;&gt;
    &lt;h2&gt;&lt;%= pluralize(@post.errors.count, &quot;error&quot;) %&gt; prohibited
      this post from being saved:&lt;/h2&gt;
    &lt;ul&gt;
    &lt;% @post.errors.full_messages.each do |msg| %&gt;
      &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
    &lt;% end %&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &lt;% end %&gt;
  &lt;p&gt;
    &lt;%= f.label :title %&gt;&lt;br&gt;
    &lt;%= f.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.label :text %&gt;&lt;br&gt;
    &lt;%= f.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;%= link_to &#39;Back&#39;, action: :index %&gt;</code></pre>

<p>This time we point the form to the <code>update</code> action, which is not
defined yet but will be very soon.</p>

<p>The <code>method: :patch</code> option tells <a
href="../../../../classes/Rails.html">Rails</a> that we want this form to
be submitted via the <code>PATCH</code> HTTP method which is the HTTP
method you&#39;re expected to use to <strong>update</strong> resources
according to the REST protocol.</p>

<p>TIP: By default forms built with the <em>form_for</em> helper are sent via
<code>POST</code>.</p>

<p>Next, we need to add the <code>update</code> action. The file
<code>config/routes.rb</code> will need just one more line:</p>

<pre><code>patch &quot;posts/:id&quot; =&gt; &quot;posts#update&quot;
</code></pre>

<p>And then create the <code>update</code> action in
<code>app/controllers/posts_controller.rb</code>:</p>

<pre><code>def update
  @post = Post.find(params[:id])

  if @post.update(params[:post].permit(:title, :text))
    redirect_to action: :show, id: @post.id
  else
    render &#39;edit&#39;
  end
end
</code></pre>

<p>The new method, <code>update</code>, is used when you want to update a
record that already exists, and it accepts a hash containing the attributes
that you want to update. As before, if there was an error updating the post
we want to show the form back to the user.</p>

<p>TIP: You don&#39;t need to pass all attributes to <code>update</code>. For
example, if you&#39;d call <code>@post.update(title: &#39;A new
title&#39;)</code> <a href="../../../../classes/Rails.html">Rails</a> would
only update the <code>title</code> attribute, leaving all other attributes
untouched.</p>

<p>Finally, we want to show a link to the <code>edit</code> action in the list
of all the posts, so let&#39;s add that now to
<code>app/views/posts/index.html.erb</code> to make it appear next to the
“Show” link:</p>

<pre><code>&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Text&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @posts.each do |post| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= post.title %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= post.text %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to &#39;Show&#39;, action: :show, id: post.id %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to &#39;Edit&#39;, action: :edit, id: post.id %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;</code></pre>

<p>And we&#39;ll also add one to the
<code>app/views/posts/show.html.erb</code> template as well, so that
there&#39;s also an “Edit” link on a post&#39;s page. Add this at the
bottom of the template:</p>

<pre><code>...

&lt;%= link_to &#39;Back&#39;, action: :index %&gt;
| &lt;%= link_to &#39;Edit&#39;, action: :edit, id: @post.id %&gt;</code></pre>

<p>And here&#39;s how our app looks so far:</p>

<p><img src="http://images/getting_started/index_action_with_edit_link.png" /></p>

<h3 id="label-Using+partials+to+clean+up+duplication+in+views">Using partials to clean up duplication in views</h3>

<p>Our <code>edit</code> page looks very similar to the <code>new</code> page,
in fact they both share the same code for displaying the form. Let&#39;s
remove some duplication by using a view partial. By convention, partial
files are prefixed by an underscore.</p>

<p>TIP: You can read more about partials in the <a
href="http://layouts_and_rendering.html">Layouts and Rendering in Rails</a>
guide.</p>

<p>Create a new file <code>app/views/posts/_form.html.erb</code> with the
following content:</p>

<pre><code>&lt;%= form_for @post do |f| %&gt;
  &lt;% if @post.errors.any? %&gt;
  &lt;div id=&quot;errorExplanation&quot;&gt;
    &lt;h2&gt;&lt;%= pluralize(@post.errors.count, &quot;error&quot;) %&gt; prohibited
      this post from being saved:&lt;/h2&gt;
    &lt;ul&gt;
    &lt;% @post.errors.full_messages.each do |msg| %&gt;
      &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
    &lt;% end %&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &lt;% end %&gt;
  &lt;p&gt;
    &lt;%= f.label :title %&gt;&lt;br&gt;
    &lt;%= f.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.label :text %&gt;&lt;br&gt;
    &lt;%= f.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;</code></pre>

<p>Everything except for the <code>form_for</code> declaration remained the
same. How <code>form_for</code> can figure out the right
<code>action</code> and <code>method</code> attributes when building the
form will be explained in just a moment. For now, let&#39;s update the
<code>app/views/posts/new.html.erb</code> view to use this new partial,
rewriting it completely:</p>

<pre><code>&lt;h1&gt;New post&lt;/h1&gt;

&lt;%= render &#39;form&#39; %&gt;

&lt;%= link_to &#39;Back&#39;, action: :index %&gt;</code></pre>

<p>Then do the same for the <code>app/views/posts/edit.html.erb</code> view:</p>

<pre><code>&lt;h1&gt;Edit post&lt;/h1&gt;

&lt;%= render &#39;form&#39; %&gt;

&lt;%= link_to &#39;Back&#39;, action: :index %&gt;</code></pre>

<p>Point your browser to <a
href="http://localhost:3000/posts/new">localhost:3000/posts/new</a> and try
creating a new post. Everything still works. Now try editing the post and
you&#39;ll receive the following error:</p>

<p><img src="http://images/getting_started/undefined_method_post_path.png" /></p>

<p>To understand this error, you need to understand how <code>form_for</code>
works. When you pass an object to <code>form_for</code> and you don&#39;t
specify a <code>:url</code> option, <a
href="../../../../classes/Rails.html">Rails</a> will try to guess the
<code>action</code> and <code>method</code> options by checking if the
passed object is a new record or not. <a
href="../../../../classes/Rails.html">Rails</a> follows the REST
convention, so to create a new <code>Post</code> object it will look for a
route named <code>posts_path</code>, and to update a <code>Post</code>
object it will look for a route named <code>post_path</code> and pass the
current object. Similarly, rails knows that it should create new objects
via POST and update them via PUT.</p>

<p>If you run <code>rake routes</code> from the console you&#39;ll see that we
already have a <code>posts_path</code> route, which was created
automatically by <a href="../../../../classes/Rails.html">Rails</a> when we
defined the route for the index action. However, we don&#39;t have a
<code>post_path</code> yet, which is the reason why we received an error
before. With your server running you can view your routes by visiting <a
href="http://localhost:3000/rails/info/routes">localhost:3000/rails/info/routes</a>,
or you can generate them from the command line by running <code>rake
routes</code>:</p>

<pre><code>$ rake routes

    posts GET  /posts(.:format)            posts#index
posts_new GET  /posts/new(.:format)        posts#new
          POST /posts(.:format)            posts#create
          GET  /posts/:id(.:format)        posts#show
          GET  /posts/:id/edit(.:format)   posts#edit
          PUT  /posts/:id(.:format)        posts#update
     root      /                           welcome#index</code></pre>

<p>To fix this, open <code>config/routes.rb</code> and modify the <code>get
&quot;posts/:id&quot;</code> line like this:</p>

<pre><code>get &quot;posts/:id&quot; =&gt; &quot;posts#show&quot;, as: :post
</code></pre>

<p>The <code>:as</code> option tells the <code>get</code> method that we want
to make routing helpers called <code>post_url</code> and
<code>post_path</code> available to our application. These are precisely
the methods that the <code>form_for</code> needs when editing a post, and
so now you&#39;ll be able to update posts again.</p>

<p>NOTE: The <code>:as</code> option is available on the <code>post</code>,
<code>patch</code>, <code>put</code>, <code>delete</code> and
<code>match</code> routing methods also.</p>

<h3 id="label-Deleting+Posts">Deleting Posts</h3>

<p>We&#39;re now ready to cover the “D” part of CRUD, deleting posts from the
database. Following the REST convention, we&#39;re going to add a route for
deleting posts to <code>config/routes.rb</code>:</p>

<pre><code>delete &quot;posts/:id&quot; =&gt; &quot;posts#destroy&quot;
</code></pre>

<p>The <code>delete</code> routing method should be used for routes that
destroy resources. If this was left as a typical <code>get</code> route, it
could be possible for people to craft malicious URLs like this:</p>

<pre><code>&lt;a href=&#39;http://example.com/posts/1/destroy&#39;&gt;look at this cat!&lt;/a&gt;</code></pre>

<p>We use the <code>delete</code> method for destroying resources, and this
route is mapped to the <code>destroy</code> action inside
<code>app/controllers/posts_controller.rb</code>, which doesn&#39;t exist
yet, but is provided below:</p>

<pre><code>def destroy
  @post = Post.find(params[:id])
  @post.destroy

  redirect_to action: :index
end
</code></pre>

<p>You can call <code>destroy</code> on Active Record objects when you want to
delete them from the database. Note that we don&#39;t need to add a view
for this action since we&#39;re redirecting to the <code>index</code>
action.</p>

<p>Finally, add a &#39;destroy&#39; link to your <code>index</code> action
template (<code>app/views/posts/index.html.erb</code>) to wrap everything
together.</p>

<pre><code>&lt;h1&gt;Listing Posts&lt;/h1&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Text&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @posts.each do |post| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= post.title %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= post.text %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to &#39;Show&#39;, action: :show, id: post.id %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to &#39;Edit&#39;, action: :edit, id: post.id %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to &#39;Destroy&#39;, { action: :destroy, id: post.id },
                    method: :delete, data: { confirm: &#39;Are you sure?&#39; } %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;</code></pre>

<p>Here we&#39;re using <code>link_to</code> in a different way. We wrap the
<code>:action</code> and <code>:id</code> attributes in a hash so that we
can pass those two keys in first as one argument, and then the final two
keys as another argument. The <code>:method</code> and
<code>:&#39;data-confirm&#39;</code> options are used as HTML5 attributes
so that when the link is clicked, <a
href="../../../../classes/Rails.html">Rails</a> will first show a confirm
dialog to the user, and then submit the link with method
<code>delete</code>. This is done via the JavaScript file
<code>jquery_ujs</code> which is automatically included into your
application&#39;s layout
(<code>app/views/layouts/application.html.erb</code>) when you generated
the application. Without this file, the confirmation dialog box
wouldn&#39;t appear.</p>

<p><img src="http://images/getting_started/confirm_dialog.png" /></p>

<p>Congratulations, you can now create, show, list, update and destroy posts.
In the next section will see how <a
href="../../../../classes/Rails.html">Rails</a> can aid us when creating
REST applications, and how we can refactor our <a
href="../../../../classes/Blog.html">Blog</a> app to take advantage of it.</p>

<h3 id="label-Going+Deeper+into+REST">Going Deeper into REST</h3>

<p>We&#39;ve now covered all the CRUD actions of a REST app. We did so by
declaring separate routes with the appropriate verbs into
<code>config/routes.rb</code>. Here&#39;s how that file looks so far:</p>

<pre><code>get &quot;posts&quot; =&gt; &quot;posts#index&quot;
get &quot;posts/new&quot;
post &quot;posts&quot; =&gt; &quot;posts#create&quot;
get &quot;posts/:id&quot; =&gt; &quot;posts#show&quot;, as: :post
get &quot;posts/:id/edit&quot; =&gt; &quot;posts#edit&quot;
patch &quot;posts/:id&quot; =&gt; &quot;posts#update&quot;
delete &quot;posts/:id&quot; =&gt; &quot;posts#destroy&quot;
</code></pre>

<p>That&#39;s a lot to type for covering a single <strong>resource</strong>.
Fortunately, <a href="../../../../classes/Rails.html">Rails</a> provides a
<code>resources</code> method which can be used to declare a standard REST
resource. Here&#39;s how <code>config/routes.rb</code> looks after the
cleanup:</p>

<pre><code>Blog::Application.routes.draw do

  resources :posts

  root to: &quot;welcome#index&quot;
end
</code></pre>

<p>If you run <code>rake routes</code>, you&#39;ll see that all the routes
that we declared before are still available:</p>

<pre><code>$ rake routes
    posts GET    /posts(.:format)          posts#index
          POST   /posts(.:format)          posts#create
 new_post GET    /posts/new(.:format)      posts#new
edit_post GET    /posts/:id/edit(.:format) posts#edit
     post GET    /posts/:id(.:format)      posts#show
          PUT    /posts/:id(.:format)      posts#update
          DELETE /posts/:id(.:format)      posts#destroy
     root        /                         welcome#index</code></pre>

<p>Also, if you go through the motions of creating, updating and deleting
posts the app still works as before.</p>

<p>TIP: In general, <a href="../../../../classes/Rails.html">Rails</a>
encourages the use of resources objects in place of declaring routes
manually. It was only done in this guide as a learning exercise. For more
information about routing, see <a href="http://routing.html">Rails Routing
from the Outside In</a>.</p>

<h2 id="label-Adding+a+Second+Model">Adding a Second Model</h2>

<p>It&#39;s time to add a second model to the application. The second model
will handle comments on posts.</p>

<h3 id="label-Generating+a+Model">Generating a Model</h3>

<p>We&#39;re going to see the same generator that we used before when creating
the <code>Post</code> model. This time we&#39;ll create a
<code>Comment</code> model to hold reference of post comments. Run this
command in your terminal:</p>

<pre><code>$ rails generate model Comment commenter:string body:text post:references</code></pre>

<p>This command will generate four files:</p>

<p>| <a href="../../../../classes/File.html">File</a> | Purpose | |
——————————————– | —————————————————————————————————— | |
db/migrate/20100207235629_create_comments.rb | Migration to create the
comments table in your database (your name will include a different
timestamp) | | app/models/comment.rb | The <a
href="../../../../classes/Comment.html">Comment</a> model | |
test/models/comment_test.rb | Testing harness for the comments model | |
test/fixtures/comments.yml | Sample comments for use in testing |</p>

<p>First, take a look at <code>app/models/comment.rb</code>:</p>

<pre><code>class Comment &lt; ActiveRecord::Base
  belongs_to :post
end
</code></pre>

<p>This is very similar to the <code>post.rb</code> model that you saw
earlier. The difference is the line <code>belongs_to :post</code>, which
sets up an Active Record <em>association</em>. You&#39;ll learn a little
about associations in the next section of this guide.</p>

<p>In addition to the model, <a
href="../../../../classes/Rails.html">Rails</a> has also made a migration
to create the corresponding database table:</p>

<pre><code>class CreateComments &lt; ActiveRecord::Migration
  def change
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :post

      t.timestamps
    end

    add_index :comments, :post_id
  end
end
</code></pre>

<p>The <code>t.references</code> line sets up a foreign key column for the
association between the two models. And the <code>add_index</code> line
sets up an index for this association column. Go ahead and run the
migration:</p>

<pre><code>$ rake db:migrate</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> is smart enough to only
execute the migrations that have not already been run against the current
database, so in this case you will just see:</p>

<pre><code>==  CreateComments: migrating =================================================
-- create_table(:comments)
   -&gt; 0.0008s
-- add_index(:comments, :post_id)
   -&gt; 0.0003s
==  CreateComments: migrated (0.0012s) ========================================</code></pre>

<h3 id="label-Associating+Models">Associating Models</h3>

<p>Active Record associations let you easily declare the relationship between
two models. In the case of comments and posts, you could write out the
relationships this way:</p>
<ul><li>
<p>Each comment belongs to one post.</p>
</li><li>
<p><a href="../../../../classes/One.html">One</a> post can have many comments.</p>
</li></ul>

<p>In fact, this is very close to the syntax that <a
href="../../../../classes/Rails.html">Rails</a> uses to declare this
association. You&#39;ve already seen the line of code inside the
<code>Comment</code> model (app/models/comment.rb) that makes each comment
belong to a Post:</p>

<pre><code>class Comment &lt; ActiveRecord::Base
  belongs_to :post
end
</code></pre>

<p>You&#39;ll need to edit <code>app/models/post.rb</code> to add the other
side of the association:</p>

<pre><code>class Post &lt; ActiveRecord::Base
  has_many :comments
  validates :title, presence: true,
                    length: { minimum: 5 }
  [...]
end
</code></pre>

<p>These two declarations enable a good bit of automatic behavior. For
example, if you have an instance variable <code>@post</code> containing a
post, you can retrieve all the comments belonging to that post as an array
using <code>@post.comments</code>.</p>

<p>TIP: For more information on Active Record associations, see the <a
href="http://association_basics.html">Active Record Associations</a> guide.</p>

<h3 id="label-Adding+a+Route+for+Comments">Adding a Route for Comments</h3>

<p>As with the <code>welcome</code> controller, we will need to add a route so
that <a href="../../../../classes/Rails.html">Rails</a> knows where we
would like to navigate to see <code>comments</code>. Open up the
<code>config/routes.rb</code> file again, and edit it as follows:</p>

<pre><code>resources :posts do
  resources :comments
end
</code></pre>

<p>This creates <code>comments</code> as a <em>nested resource</em> within
<code>posts</code>. This is another part of capturing the hierarchical
relationship that exists between posts and comments.</p>

<p>TIP: For more information on routing, see the <a
href="http://routing.html">Rails Routing</a> guide.</p>

<h3 id="label-Generating+a+Controller">Generating a Controller</h3>

<p>With the model in hand, you can turn your attention to creating a matching
controller. Again, we&#39;ll use the same generator we used before:</p>

<pre><code>$ rails generate controller Comments</code></pre>

<p>This creates six files and one empty directory:</p>

<p>| File/Directory | Purpose | | ——————————————– | —————————————- | |
app/controllers/comments_controller.rb | The Comments controller | |
app/views/comments/ | Views of the controller are stored here | |
test/controllers/comments_controller_test.rb | The test for the controller
| | app/helpers/comments_helper.rb | <a
href="../../../../classes/A.html">A</a> view helper file | |
test/helpers/comments_helper_test.rb | The test for the helper | |
app/assets/javascripts/comment.js.coffee | CoffeeScript for the controller
| | app/assets/stylesheets/comment.css.scss | Cascading style sheet for the
controller |</p>

<p>Like with any blog, our readers will create their comments directly after
reading the post, and once they have added their comment, will be sent back
to the post show page to see their comment now listed. Due to this, our
<code>CommentsController</code> is there to provide a method to create
comments and delete spam comments when they arrive.</p>

<p>So first, we&#39;ll wire up the <a
href="../../../../classes/Post.html">Post</a> show template
(<code>app/views/posts/show.html.erb</code>) to let us make a new comment:</p>

<pre><code>&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @post.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @post.text %&gt;
&lt;/p&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= form_for([@post, @post.comments.build]) do |f| %&gt;
  &lt;p&gt;
    &lt;%= f.label :commenter %&gt;&lt;br /&gt;
    &lt;%= f.text_field :commenter %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :body %&gt;&lt;br /&gt;
    &lt;%= f.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;%= link_to &#39;Edit Post&#39;, edit_post_path(@post) %&gt; |
&lt;%= link_to &#39;Back to Posts&#39;, posts_path %&gt;</code></pre>

<p>This adds a form on the <code>Post</code> show page that creates a new
comment by calling the <code>CommentsController</code> <code>create</code>
action. The <code>form_for</code> call here uses an array, which will build
a nested route, such as <code>/posts/1/comments</code>.</p>

<p>Let&#39;s wire up the <code>create</code> in
<code>app/controllers/comments_controller.rb</code>:</p>

<pre><code>class CommentsController &lt; ApplicationController
  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment].permit(:commenter, :body))
    redirect_to post_path(@post)
  end
end
</code></pre>

<p>You&#39;ll see a bit more complexity here than you did in the controller
for posts. That&#39;s a side-effect of the nesting that you&#39;ve set up.
Each request for a comment has to keep track of the post to which the
comment is attached, thus the initial call to the <code>find</code> method
of the <code>Post</code> model to get the post in question.</p>

<p>In addition, the code takes advantage of some of the methods available for
an association. We use the <code>create</code> method on
<code>@post.comments</code> to create and save the comment. This will
automatically link the comment so that it belongs to that particular post.</p>

<p>Once we have made the new comment, we send the user back to the original
post using the <code>post_path(@post)</code> helper. As we have already
seen, this calls the <code>show</code> action of the
<code>PostsController</code> which in turn renders the
<code>show.html.erb</code> template. This is where we want the comment to
show, so let&#39;s add that to the
<code>app/views/posts/show.html.erb</code>.</p>

<pre><code>&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @post.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @post.text %&gt;
&lt;/p&gt;

&lt;h2&gt;Comments&lt;/h2&gt;
&lt;% @post.comments.each do |comment| %&gt;
  &lt;p&gt;
    &lt;strong&gt;Commenter:&lt;/strong&gt;
    &lt;%= comment.commenter %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;strong&gt;Comment:&lt;/strong&gt;
    &lt;%= comment.body %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= form_for([@post, @post.comments.build]) do |f| %&gt;
  &lt;p&gt;
    &lt;%= f.label :commenter %&gt;&lt;br /&gt;
    &lt;%= f.text_field :commenter %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :body %&gt;&lt;br /&gt;
    &lt;%= f.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;%= link_to &#39;Edit Post&#39;, edit_post_path(@post) %&gt; |
&lt;%= link_to &#39;Back to Posts&#39;, posts_path %&gt;</code></pre>

<p>Now you can add posts and comments to your blog and have them show up in
the right places.</p>

<p><img src="http://images/getting_started/post_with_comments.png" /></p>

<h2 id="label-Refactoring">Refactoring</h2>

<p>Now that we have posts and comments working, take a look at the
<code>app/views/posts/show.html.erb</code> template. It is getting long and
awkward. We can use partials to clean it up.</p>

<h3 id="label-Rendering+Partial+Collections">Rendering Partial Collections</h3>

<p>First, we will make a comment partial to extract showing all the comments
for the post. Create the file
<code>app/views/comments/_comment.html.erb</code> and put the following
into it:</p>

<pre><code>&lt;p&gt;
  &lt;strong&gt;Commenter:&lt;/strong&gt;
  &lt;%= comment.commenter %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Comment:&lt;/strong&gt;
  &lt;%= comment.body %&gt;
&lt;/p&gt;</code></pre>

<p>Then you can change <code>app/views/posts/show.html.erb</code> to look like
the following:</p>

<pre><code>&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @post.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @post.text %&gt;
&lt;/p&gt;

&lt;h2&gt;Comments&lt;/h2&gt;
&lt;%= render @post.comments %&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= form_for([@post, @post.comments.build]) do |f| %&gt;
  &lt;p&gt;
    &lt;%= f.label :commenter %&gt;&lt;br /&gt;
    &lt;%= f.text_field :commenter %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :body %&gt;&lt;br /&gt;
    &lt;%= f.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;%= link_to &#39;Edit Post&#39;, edit_post_path(@post) %&gt; |
&lt;%= link_to &#39;Back to Posts&#39;, posts_path %&gt;</code></pre>

<p>This will now render the partial in
<code>app/views/comments/_comment.html.erb</code> once for each comment
that is in the <code>@post.comments</code> collection. As the
<code>render</code> method iterates over the <code>@post.comments</code>
collection, it assigns each comment to a local variable named the same as
the partial, in this case <code>comment</code> which is then available in
the partial for us to show.</p>

<h3 id="label-Rendering+a+Partial+Form">Rendering a Partial Form</h3>

<p>Let us also move that new comment section out to its own partial. Again,
you create a file <code>app/views/comments/_form.html.erb</code>
containing:</p>

<pre><code>&lt;%= form_for([@post, @post.comments.build]) do |f| %&gt;
  &lt;p&gt;
    &lt;%= f.label :commenter %&gt;&lt;br /&gt;
    &lt;%= f.text_field :commenter %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :body %&gt;&lt;br /&gt;
    &lt;%= f.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;</code></pre>

<p>Then you make the <code>app/views/posts/show.html.erb</code> look like the
following:</p>

<pre><code>&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @post.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @post.text %&gt;
&lt;/p&gt;

&lt;h2&gt;Comments&lt;/h2&gt;
&lt;%= render @post.comments %&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= render &quot;comments/form&quot; %&gt;

&lt;%= link_to &#39;Edit Post&#39;, edit_post_path(@post) %&gt; |
&lt;%= link_to &#39;Back to Posts&#39;, posts_path %&gt;</code></pre>

<p>The second render just defines the partial template we want to render,
<code>comments/form</code>. <a
href="../../../../classes/Rails.html">Rails</a> is smart enough to spot the
forward slash in that string and realize that you want to render the
<code>_form.html.erb</code> file in the <code>app/views/comments</code>
directory.</p>

<p>The <code>@post</code> object is available to any partials rendered in the
view because we defined it as an instance variable.</p>

<h2 id="label-Deleting+Comments">Deleting Comments</h2>

<p><a href="../../../../classes/Another.html">Another</a> important feature of
a blog is being able to delete spam comments. To do this, we need to
implement a link of some sort in the view and a <code>DELETE</code> action
in the <code>CommentsController</code>.</p>

<p>So first, let&#39;s add the delete link in the
<code>app/views/comments/_comment.html.erb</code> partial:</p>

<pre><code>&lt;p&gt;
  &lt;strong&gt;Commenter:&lt;/strong&gt;
  &lt;%= comment.commenter %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Comment:&lt;/strong&gt;
  &lt;%= comment.body %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;%= link_to &#39;Destroy Comment&#39;, [comment.post, comment],
               method: :delete,
               data: { confirm: &#39;Are you sure?&#39; } %&gt;
&lt;/p&gt;</code></pre>

<p>Clicking this new “Destroy Comment” link will fire off a <code>DELETE
/posts/:post_id/comments/:id</code> to our <code>CommentsController</code>,
which can then use this to find the comment we want to delete, so let&#39;s
add a destroy action to our controller
(<code>app/controllers/comments_controller.rb</code>):</p>

<pre><code>class CommentsController &lt; ApplicationController

  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end

  def destroy
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
    @comment.destroy
    redirect_to post_path(@post)
  end

end
</code></pre>

<p>The <code>destroy</code> action will find the post we are looking at,
locate the comment within the <code>@post.comments</code> collection, and
then remove it from the database and send us back to the show action for
the post.</p>

<h3 id="label-Deleting+Associated+Objects">Deleting Associated Objects</h3>

<p>If you delete a post then its associated comments will also need to be
deleted. Otherwise they would simply occupy space in the database. <a
href="../../../../classes/Rails.html">Rails</a> allows you to use the
<code>dependent</code> option of an association to achieve this. Modify the
<a href="../../../../classes/Post.html">Post</a> model,
<code>app/models/post.rb</code>, as follows:</p>

<pre><code>class Post &lt; ActiveRecord::Base
  has_many :comments, dependent: :destroy
  validates :title, presence: true,
                    length: { minimum: 5 }
  [...]
end
</code></pre>

<h2 id="label-Security">Security</h2>

<p>If you were to publish your blog online, anybody would be able to add, edit
and delete posts or delete comments.</p>

<p><a href="../../../../classes/Rails.html">Rails</a> provides a very simple
HTTP authentication system that will work nicely in this situation.</p>

<p>In the <code>PostsController</code> we need to have a way to block access
to the various actions if the person is not authenticated, here we can use
the <a href="../../../../classes/Rails.html">Rails</a>
<code>http_basic_authenticate_with</code> method, allowing access to the
requested action if that method allows it.</p>

<p>To use the authentication system, we specify it at the top of our
<code>PostsController</code>, in this case, we want the user to be
authenticated on every action, except for <code>index</code> and
<code>show</code>, so we write that in
<code>app/controllers/posts_controller.rb</code>:</p>

<pre><code>class PostsController &lt; ApplicationController

  http_basic_authenticate_with name: &quot;dhh&quot;, password: &quot;secret&quot;, except: [:index, :show]

  def index
    @posts = Post.all
  end

  # snipped for brevity
</code></pre>

<p>We also only want to allow authenticated users to delete comments, so in
the <code>CommentsController</code>
(<code>app/controllers/comments_controller.rb</code>) we write:</p>

<pre><code>class CommentsController &lt; ApplicationController

  http_basic_authenticate_with name: &quot;dhh&quot;, password: &quot;secret&quot;, only: :destroy

  def create
    @post = Post.find(params[:post_id])
    ...
  end
  # snipped for brevity
</code></pre>

<p>Now if you try to create a new post, you will be greeted with a basic HTTP
Authentication challenge</p>

<p><img src="http://images/challenge.png" /></p>

<h2 id="label-What%27s+Next%3F">What&#39;s Next?</h2>

<p>Now that you&#39;ve seen your first <a
href="../../../../classes/Rails.html">Rails</a> application, you should
feel free to update it and experiment on your own. But you don&#39;t have
to do everything without help. As you need assistance getting up and
running with <a href="../../../../classes/Rails.html">Rails</a>, feel free
to consult these support resources:</p>
<ul><li>
<p>The <a href="http://index.html">Ruby on Rails guides</a></p>
</li><li>
<p>The <a href="http://railstutorial.org/book">Ruby on Rails Tutorial</a></p>
</li><li>
<p>The <a href="http://groups.google.com/group/rubyonrails-talk">Ruby on Rails
mailing list</a></p>
</li><li>
<p>The <a href="irc://irc.freenode.net/#rubyonrails">#rubyonrails</a> channel
on irc.freenode.net</p>
</li></ul>

<p><a href="../../../../classes/Rails.html">Rails</a> also comes with built-in
help that you can generate using the rake command-line utility:</p>
<ul><li>
<p>Running <code>rake doc:guides</code> will put a full copy of the <a
href="../../../../classes/Rails.html">Rails</a> Guides in the
<code>doc/guides</code> folder of your application. Open
<code>doc/guides/index.html</code> in your web browser to explore the
Guides.</p>
</li><li>
<p>Running <code>rake doc:rails</code> will put a full copy of the API
documentation for <a href="../../../../classes/Rails.html">Rails</a> in the
<code>doc/api</code> folder of your application. Open
<code>doc/api/index.html</code> in your web browser to explore the API
documentation.</p>
</li></ul>

<p>TIP: To be able to generate the <a
href="../../../../classes/Rails.html">Rails</a> Guides locally with the
<code>doc:guides</code> rake task you need to install the RedCloth gem. Add
it to your <code>Gemfile</code> and run <code>bundle install</code> and
you&#39;re ready to go.</p>

<h2 id="label-Configuration+Gotchas">Configuration Gotchas</h2>

<p>The easiest way to work with <a
href="../../../../classes/Rails.html">Rails</a> is to store all external
data as UTF-8. If you don&#39;t, Ruby libraries and <a
href="../../../../classes/Rails.html">Rails</a> will often be able to
convert your native data into UTF-8, but this doesn&#39;t always work
reliably, so you&#39;re better off ensuring that all external data is
UTF-8.</p>

<p>If you have made a mistake in this area, the most common symptom is a black
diamond with a question mark inside appearing in the browser. <a
href="../../../../classes/Another.html">Another</a> common symptom is
characters like “Ã¼” appearing instead of “ü”. <a
href="../../../../classes/Rails.html">Rails</a> takes a number of internal
steps to mitigate common causes of these problems that can be automatically
detected and corrected. However, if you have external data that is not
stored as UTF-8, it can occasionally result in these kinds of issues that
cannot be automatically detected by <a
href="../../../../classes/Rails.html">Rails</a> and corrected.</p>

<p>Two very common sources of data that are not UTF-8:</p>
<ul><li>
<p>Your text editor: Most text editors (such as Textmate), default to saving
files as  UTF-8. If your text editor does not, this can result in special
characters that you  enter in your templates (such as é) to appear as a
diamond with a question mark inside  in the browser. This also applies to
your i18n translation files.  Most editors that do not already default to
UTF-8 (such as some versions of  Dreamweaver) offer a way to change the
default to UTF-8. Do so.</p>
</li><li>
<p>Your database. <a href="../../../../classes/Rails.html">Rails</a> defaults
to converting data from your database into UTF-8 at  the boundary. However,
if your database is not using UTF-8 internally, it may not  be able to
store all characters that your users enter. For instance, if your database 
is using Latin-1 internally, and your user enters a Russian, Hebrew, or
Japanese  character, the data will be lost forever once it enters the
database. If possible,  use UTF-8 as the internal storage of your database.</p>
</li></ul>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>