<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>form_helpers.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            form_helpers.md
        </h1>
        <ul class="files">
            <li>rails/guides/source/form_helpers.md</li>
            <li>Last modified: 2013-04-26 19:51:18 +0300</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-Form+Helpers">Form Helpers</h1>

<p>Forms in web applications are an essential interface for user input.
However, form markup can quickly become tedious to write and maintain
because of form control naming and their numerous attributes. <a
href="../../../../classes/Rails.html">Rails</a> does away with these
complexities by providing view helpers for generating form markup. However,
since they have different use-cases, developers are required to know all
the differences between similar helper methods before putting them to use.</p>

<p>After reading this guide, you will know:</p>
<ul><li>
<p>How to create search forms and similar kind of generic forms not
representing any specific model in your application.</p>
</li><li>
<p>How to make model-centric forms for creation and editing of specific
database records.</p>
</li><li>
<p>How to generate select boxes from multiple types of data.</p>
</li><li>
<p>The date and time helpers <a
href="../../../../classes/Rails.html">Rails</a> provides.</p>
</li><li>
<p>What makes a file upload form different.</p>
</li><li>
<p>Some cases of building forms to external resources.</p>
</li><li>
<p>How to build complex forms.</p>
</li></ul>
<hr style="height: 1px">

<p>NOTE: This guide is not intended to be a complete documentation of
available form helpers and their arguments. Please visit <a
href="http://api.rubyonrails.org/">the Rails API documentation</a> for a
complete reference.</p>

<h2 id="label-Dealing+with+Basic+Forms">Dealing with Basic Forms</h2>

<p>The most basic form helper is <code>form_tag</code>.</p>

<pre><code>&lt;%= form_tag do %&gt;
  Form contents
&lt;% end %&gt;</code></pre>

<p>When called without arguments like this, it creates a
<code>&lt;form&gt;</code> tag which, when submitted, will POST to the
current page. For instance, assuming the current page is
<code>/home/index</code>, the generated <a
href="../../../../classes/HTML.html">HTML</a> will look like this (some
line breaks added for readability):</p>

<pre><code>&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/home/index&quot; method=&quot;post&quot;&gt;
  &lt;div style=&quot;margin:0;padding:0&quot;&gt;
    &lt;input name=&quot;utf8&quot; type=&quot;hidden&quot; value=&quot;&amp;#x2713;&quot; /&gt;
    &lt;input name=&quot;authenticity_token&quot; type=&quot;hidden&quot; value=&quot;f755bb0ed134b76c432144748a6d4b7a7ddf2b71&quot; /&gt;
  &lt;/div&gt;
  Form contents
&lt;/form&gt;</code></pre>

<p>Now, you&#39;ll notice that the <a
href="../../../../classes/HTML.html">HTML</a> contains something extra: a
<code>div</code> element with two hidden input elements inside. This div is
important, because the form cannot be successfully submitted without it.
The first input element with name <code>utf8</code> enforces browsers to
properly respect your form&#39;s character encoding and is generated for
all forms whether their actions are “GET” or “POST”. The second input
element with name <code>authenticity_token</code> is a security feature of
<a href="../../../../classes/Rails.html">Rails</a> called
<strong>cross-site request forgery protection</strong>, and form helpers
generate it for every non-GET form (provided that this security feature is
enabled). You can read more about this in the <a
href="http://./security.html#cross-site-request-forgery-csrf">Security
Guide</a>.</p>

<p>NOTE: Throughout this guide, the <code>div</code> with the hidden input
elements will be excluded from code samples for brevity.</p>

<h3 id="label-A+Generic+Search+Form"><a href="../../../../classes/A.html">A</a> Generic Search Form</h3>

<p><a href="../../../../classes/One.html">One</a> of the most basic forms you
see on the web is a search form. This form contains:</p>
<ul><li>
<p>a form element with “GET” method,</p>
</li><li>
<p>a label for the input,</p>
</li><li>
<p>a text input element, and</p>
</li><li>
<p>a submit element.</p>
</li></ul>

<p>To create this form you will use <code>form_tag</code>,
<code>label_tag</code>, <code>text_field_tag</code>, and
<code>submit_tag</code>, respectively. Like this:</p>

<pre><code>&lt;%= form_tag(&quot;/search&quot;, method: &quot;get&quot;) do %&gt;
  &lt;%= label_tag(:q, &quot;Search for:&quot;) %&gt;
  &lt;%= text_field_tag(:q) %&gt;
  &lt;%= submit_tag(&quot;Search&quot;) %&gt;
&lt;% end %&gt;</code></pre>

<p>This will generate the following HTML:</p>

<pre><code>&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/search&quot; method=&quot;get&quot;&gt;
  &lt;label for=&quot;q&quot;&gt;Search for:&lt;/label&gt;
  &lt;input id=&quot;q&quot; name=&quot;q&quot; type=&quot;text&quot; /&gt;
  &lt;input name=&quot;commit&quot; type=&quot;submit&quot; value=&quot;Search&quot; /&gt;
&lt;/form&gt;</code></pre>

<p>TIP: For every form input, an ID attribute is generated from its name (“q”
in the example). These IDs can be very useful for CSS styling or
manipulation of form controls with JavaScript.</p>

<p>Besides <code>text_field_tag</code> and <code>submit_tag</code>, there is a
similar helper for <em>every</em> form control in <a
href="../../../../classes/HTML.html">HTML</a>.</p>

<p>IMPORTANT: Always use “GET” as the method for search forms. This allows
users to bookmark a specific search and get back to it. More generally <a
href="../../../../classes/Rails.html">Rails</a> encourages you to use the
right HTTP verb for an action.</p>

<h3 id="label-Multiple+Hashes+in+Form+Helper+Calls">Multiple Hashes in Form Helper Calls</h3>

<p>The <code>form_tag</code> helper accepts 2 arguments: the path for the
action and an options hash. This hash specifies the method of form
submission and <a href="../../../../classes/HTML.html">HTML</a> options
such as the form element&#39;s class.</p>

<p>As with the <code>link_to</code> helper, the path argument doesn&#39;t have
to be a string; it can be a hash of URL parameters recognizable by
Rails&#39; routing mechanism, which will turn the hash into a valid URL.
However, since both arguments to <code>form_tag</code> are hashes, you can
easily run into a problem if you would like to specify both. For instance,
let&#39;s say you write this:</p>

<pre><code>form_tag(controller: &quot;people&quot;, action: &quot;search&quot;, method: &quot;get&quot;, class: &quot;nifty_form&quot;)
# =&gt; &#39;&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/people/search?method=get&amp;class=nifty_form&quot; method=&quot;post&quot;&gt;&#39;
</code></pre>

<p>Here, <code>method</code> and <code>class</code> are appended to the query
string of the generated URL because even though you mean to write two
hashes, you really only specified one. So you need to tell Ruby which is
which by delimiting the first hash (or both) with curly brackets. This will
generate the <a href="../../../../classes/HTML.html">HTML</a> you expect:</p>

<pre><code>form_tag({controller: &quot;people&quot;, action: &quot;search&quot;}, method: &quot;get&quot;, class: &quot;nifty_form&quot;)
# =&gt; &#39;&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/people/search&quot; method=&quot;get&quot; class=&quot;nifty_form&quot;&gt;&#39;
</code></pre>

<h3 id="label-Helpers+for+Generating+Form+Elements">Helpers for Generating Form Elements</h3>

<p><a href="../../../../classes/Rails.html">Rails</a> provides a series of
helpers for generating form elements such as checkboxes, text fields, and
radio buttons. These basic helpers, with names ending in “_tag” (such as
<code>text_field_tag</code> and <code>check_box_tag</code>), generate just
a single <code>&lt;input&gt;</code> element. The first parameter to these
is always the name of the input. When the form is submitted, the name will
be passed along with the form data, and will make its way to the
<code>params</code> hash in the controller with the value entered by the
user for that field. For example, if the form contains <code>&lt;%=
text_field_tag(:query) %&gt;</code>, then you would be able to get the
value of this field in the controller with <code>params[:query]</code>.</p>

<p>When naming inputs, <a href="../../../../classes/Rails.html">Rails</a> uses
certain conventions that make it possible to submit parameters with
non-scalar values such as arrays or hashes, which will also be accessible
in <code>params</code>. You can read more about them in <a
href="#understanding-parameter-naming-conventions">chapter 7 of this
guide</a>. For details on the precise usage of these helpers, please refer
to the <a
href="http://api.rubyonrails.org/classes/ActionView/Helpers/FormTagHelper.html">API
documentation</a>.</p>

<h4 id="label-Checkboxes">Checkboxes</h4>

<p>Checkboxes are form controls that give the user a set of options they can
enable or disable:</p>

<pre><code>&lt;%= check_box_tag(:pet_dog) %&gt;
&lt;%= label_tag(:pet_dog, &quot;I own a dog&quot;) %&gt;
&lt;%= check_box_tag(:pet_cat) %&gt;
&lt;%= label_tag(:pet_cat, &quot;I own a cat&quot;) %&gt;</code></pre>

<p>This generates the following:</p>

<pre><code>&lt;input id=&quot;pet_dog&quot; name=&quot;pet_dog&quot; type=&quot;checkbox&quot; value=&quot;1&quot; /&gt;
&lt;label for=&quot;pet_dog&quot;&gt;I own a dog&lt;/label&gt;
&lt;input id=&quot;pet_cat&quot; name=&quot;pet_cat&quot; type=&quot;checkbox&quot; value=&quot;1&quot; /&gt;
&lt;label for=&quot;pet_cat&quot;&gt;I own a cat&lt;/label&gt;</code></pre>

<p>The first parameter to <code>check_box_tag</code>, of course, is the name
of the input. The second parameter, naturally, is the value of the input.
This value will be included in the form data (and be present in
<code>params</code>) when the checkbox is checked.</p>

<h4 id="label-Radio+Buttons">Radio Buttons</h4>

<p>Radio buttons, while similar to checkboxes, are controls that specify a set
of options in which they are mutually exclusive (i.e., the user can only
pick one):</p>

<pre><code>&lt;%= radio_button_tag(:age, &quot;child&quot;) %&gt;
&lt;%= label_tag(:age_child, &quot;I am younger than 21&quot;) %&gt;
&lt;%= radio_button_tag(:age, &quot;adult&quot;) %&gt;
&lt;%= label_tag(:age_adult, &quot;I&#39;m over 21&quot;) %&gt;</code></pre>

<p>Output:</p>

<pre><code>&lt;input id=&quot;age_child&quot; name=&quot;age&quot; type=&quot;radio&quot; value=&quot;child&quot; /&gt;
&lt;label for=&quot;age_child&quot;&gt;I am younger than 21&lt;/label&gt;
&lt;input id=&quot;age_adult&quot; name=&quot;age&quot; type=&quot;radio&quot; value=&quot;adult&quot; /&gt;
&lt;label for=&quot;age_adult&quot;&gt;I&#39;m over 21&lt;/label&gt;</code></pre>

<p>As with <code>check_box_tag</code>, the second parameter to
<code>radio_button_tag</code> is the value of the input. Because these two
radio buttons share the same name (age) the user will only be able to
select one, and <code>params[:age]</code> will contain either “child” or
“adult”.</p>

<p>NOTE: Always use labels for checkbox and radio buttons. They associate text
with a specific option and, by expanding the clickable region, make it
easier for users to click the inputs.</p>

<h3 id="label-Other+Helpers+of+Interest">Other Helpers of <a href="../../../../classes/Interest.html">Interest</a></h3>

<p>Other form controls worth mentioning are textareas, password fields, hidden
fields, search fields, telephone fields, date fields, time fields, color
fields, datetime fields, datetime-local fields, month fields, week fields,
URL fields and email fields:</p>

<pre><code>&lt;%= text_area_tag(:message, &quot;Hi, nice site&quot;, size: &quot;24x6&quot;) %&gt;
&lt;%= password_field_tag(:password) %&gt;
&lt;%= hidden_field_tag(:parent_id, &quot;5&quot;) %&gt;
&lt;%= search_field(:user, :name) %&gt;
&lt;%= telephone_field(:user, :phone) %&gt;
&lt;%= date_field(:user, :born_on) %&gt;
&lt;%= datetime_field(:user, :meeting_time) %&gt;
&lt;%= datetime_local_field(:user, :graduation_day) %&gt;
&lt;%= month_field(:user, :birthday_month) %&gt;
&lt;%= week_field(:user, :birthday_week) %&gt;
&lt;%= url_field(:user, :homepage) %&gt;
&lt;%= email_field(:user, :address) %&gt;
&lt;%= color_field(:user, :favorite_color) %&gt;
&lt;%= time_field(:task, :started_at) %&gt;</code></pre>

<p>Output:</p>

<pre><code>&lt;textarea id=&quot;message&quot; name=&quot;message&quot; cols=&quot;24&quot; rows=&quot;6&quot;&gt;Hi, nice site&lt;/textarea&gt;
&lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot; /&gt;
&lt;input id=&quot;parent_id&quot; name=&quot;parent_id&quot; type=&quot;hidden&quot; value=&quot;5&quot; /&gt;
&lt;input id=&quot;user_name&quot; name=&quot;user[name]&quot; type=&quot;search&quot; /&gt;
&lt;input id=&quot;user_phone&quot; name=&quot;user[phone]&quot; type=&quot;tel&quot; /&gt;
&lt;input id=&quot;user_born_on&quot; name=&quot;user[born_on]&quot; type=&quot;date&quot; /&gt;
&lt;input id=&quot;user_meeting_time&quot; name=&quot;user[meeting_time]&quot; type=&quot;datetime&quot; /&gt;
&lt;input id=&quot;user_graduation_day&quot; name=&quot;user[graduation_day]&quot; type=&quot;datetime-local&quot; /&gt;
&lt;input id=&quot;user_birthday_month&quot; name=&quot;user[birthday_month]&quot; type=&quot;month&quot; /&gt;
&lt;input id=&quot;user_birthday_week&quot; name=&quot;user[birthday_week]&quot; type=&quot;week&quot; /&gt;
&lt;input id=&quot;user_homepage&quot; name=&quot;user[homepage]&quot; type=&quot;url&quot; /&gt;
&lt;input id=&quot;user_address&quot; name=&quot;user[address]&quot; type=&quot;email&quot; /&gt;
&lt;input id=&quot;user_favorite_color&quot; name=&quot;user[favorite_color]&quot; type=&quot;color&quot; value=&quot;#000000&quot; /&gt;
&lt;input id=&quot;task_started_at&quot; name=&quot;task[started_at]&quot; type=&quot;time&quot; /&gt;</code></pre>

<p>Hidden inputs are not shown to the user but instead hold data like any
textual input. <a href="../../../../classes/Values.html">Values</a> inside
them can be changed with JavaScript.</p>

<p>IMPORTANT: The search, telephone, date, time, color, datetime,
datetime-local, month, week, URL, and email inputs are HTML5 controls. If
you require your app to have a consistent experience in older browsers, you
will need an HTML5 polyfill (provided by CSS and/or JavaScript). There is
definitely <a
href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills">no
shortage of solutions for this</a>, although a couple of popular tools at
the moment are <a href="http://www.modernizr.com/">Modernizr</a> and <a
href="http://yepnopejs.com/">yepnope</a>, which provide a simple way to add
functionality based on the presence of detected HTML5 features.</p>

<p>TIP: If you&#39;re using password input fields (for any purpose), you might
want to configure your application to prevent those parameters from being
logged. You can learn about this in the <a
href="http://security.html#logging">Security Guide</a>.</p>

<h2 id="label-Dealing+with+Model+Objects">Dealing with Model Objects</h2>

<h3 id="label-Model+Object+Helpers">Model <a href="../../../../classes/Object.html">Object</a> Helpers</h3>

<p><a href="../../../../classes/A.html">A</a> particularly common task for a
form is editing or creating a model object. While the <code>*_tag</code>
helpers can certainly be used for this task they are somewhat verbose as
for each tag you would have to ensure the correct parameter name is used
and set the default value of the input appropriately. <a
href="../../../../classes/Rails.html">Rails</a> provides helpers tailored
to this task. These helpers lack the _tag suffix, for example
<code>text_field</code>, <code>text_area</code>.</p>

<p>For these helpers the first argument is the name of an instance variable
and the second is the name of a method (usually an attribute) to call on
that object. <a href="../../../../classes/Rails.html">Rails</a> will set
the value of the input control to the return value of that method for the
object and set an appropriate input name. If your controller has defined
<code>@person</code> and that person&#39;s name is Henry then a form
containing:</p>

<pre><code>&lt;%= text_field(:person, :name) %&gt;</code></pre>

<p>will produce output similar to</p>

<pre><code>&lt;input id=&quot;person_name&quot; name=&quot;person[name]&quot; type=&quot;text&quot; value=&quot;Henry&quot;/&gt;</code></pre>

<p>Upon form submission the value entered by the user will be stored in
<code>params[:person][:name]</code>. The <code>params[:person]</code> hash
is suitable for passing to <code>Person.new</code> or, if
<code>@person</code> is an instance of <a
href="../../../../classes/Person.html">Person</a>,
<code>@person.update</code>. While the name of an attribute is the most
common second parameter to these helpers this is not compulsory. In the
example above, as long as person objects have a <code>name</code> and a
<code>name=</code> method <a
href="../../../../classes/Rails.html">Rails</a> will be happy.</p>

<p>WARNING: You must pass the name of an instance variable, i.e.
<code>:person</code> or <code>&quot;person&quot;</code>, not an actual
instance of your model object.</p>

<p><a href="../../../../classes/Rails.html">Rails</a> provides helpers for
displaying the validation errors associated with a model object. These are
covered in detail by the <a
href="http://./active_record_validations_callbacks.html#displaying-validation-errors-in-the-view">Active
Record Validations and Callbacks</a> guide.</p>

<h3 id="label-Binding+a+Form+to+an+Object">Binding a Form to an <a href="../../../../classes/Object.html">Object</a></h3>

<p>While this is an increase in comfort it is far from perfect. If <a
href="../../../../classes/Person.html">Person</a> has many attributes to
edit then we would be repeating the name of the edited object many times.
What we want to do is somehow bind a form to a model object, which is
exactly what <code>form_for</code> does.</p>

<p>Assume we have a controller for dealing with articles
<code>app/controllers/articles_controller.rb</code>:</p>

<pre><code>def new
  @article = Article.new
end
</code></pre>

<p>The corresponding view <code>app/views/articles/new.html.erb</code> using
<code>form_for</code> looks like this:</p>

<pre><code>&lt;%= form_for @article, url: {action: &quot;create&quot;}, html: {class: &quot;nifty_form&quot;} do |f| %&gt;
  &lt;%= f.text_field :title %&gt;
  &lt;%= f.text_area :body, size: &quot;60x12&quot; %&gt;
  &lt;%= f.submit &quot;Create&quot; %&gt;
&lt;% end %&gt;</code></pre>

<p>There are a few things to note here:</p>
<ul><li>
<p><code>@article</code> is the actual object being edited.</p>
</li><li>
<p>There is a single hash of options. Routing options are passed in the
<code>:url</code> hash, <a href="../../../../classes/HTML.html">HTML</a>
options are passed in the <code>:html</code> hash. Also you can provide a
<code>:namespace</code> option for your form to ensure uniqueness of id
attributes on form elements. The namespace attribute will be prefixed with
underscore on the generated <a
href="../../../../classes/HTML.html">HTML</a> id.</p>
</li><li>
<p>The <code>form_for</code> method yields a <strong>form builder</strong>
object (the <code>f</code> variable).</p>
</li><li>
<p>Methods to create form controls are called <strong>on</strong> the form
builder object <code>f</code></p>
</li></ul>

<p>The resulting <a href="../../../../classes/HTML.html">HTML</a> is:</p>

<pre><code>&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/articles/create&quot; method=&quot;post&quot; class=&quot;nifty_form&quot;&gt;
  &lt;input id=&quot;article_title&quot; name=&quot;article[title]&quot; type=&quot;text&quot; /&gt;
  &lt;textarea id=&quot;article_body&quot; name=&quot;article[body]&quot; cols=&quot;60&quot; rows=&quot;12&quot;&gt;&lt;/textarea&gt;
  &lt;input name=&quot;commit&quot; type=&quot;submit&quot; value=&quot;Create&quot; /&gt;
&lt;/form&gt;</code></pre>

<p>The name passed to <code>form_for</code> controls the key used in
<code>params</code> to access the form&#39;s values. Here the name is
<code>article</code> and so all the inputs have names of the form
<code>article[attribute_name]</code>. Accordingly, in the
<code>create</code> action <code>params[:article]</code> will be a hash
with keys <code>:title</code> and <code>:body</code>. You can read more
about the significance of input names in the parameter_names section.</p>

<p>The helper methods called on the form builder are identical to the model
object helpers except that it is not necessary to specify which object is
being edited since this is already managed by the form builder.</p>

<p>You can create a similar binding without actually creating
<code>&lt;form&gt;</code> tags with the <code>fields_for</code> helper.
This is useful for editing additional model objects with the same form. For
example if you had a <a href="../../../../classes/Person.html">Person</a>
model with an associated ContactDetail model you could create a form for
creating both like so:</p>

<pre><code>&lt;%= form_for @person, url: {action: &quot;create&quot;} do |person_form| %&gt;
  &lt;%= person_form.text_field :name %&gt;
  &lt;%= fields_for @person.contact_detail do |contact_details_form| %&gt;
    &lt;%= contact_details_form.text_field :phone_number %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;</code></pre>

<p>which produces the following output:</p>

<pre><code>&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/people/create&quot; class=&quot;new_person&quot; id=&quot;new_person&quot; method=&quot;post&quot;&gt;
  &lt;input id=&quot;person_name&quot; name=&quot;person[name]&quot; type=&quot;text&quot; /&gt;
  &lt;input id=&quot;contact_detail_phone_number&quot; name=&quot;contact_detail[phone_number]&quot; type=&quot;text&quot; /&gt;
&lt;/form&gt;</code></pre>

<p>The object yielded by <code>fields_for</code> is a form builder like the
one yielded by <code>form_for</code> (in fact <code>form_for</code> calls
<code>fields_for</code> internally).</p>

<h3 id="label-Relying+on+Record+Identification">Relying on Record Identification</h3>

<p>The Article model is directly available to users of the application, so —
following the best practices for developing with <a
href="../../../../classes/Rails.html">Rails</a> — you should declare it
<strong>a resource</strong>:</p>

<pre><code>resources :articles
</code></pre>

<p>TIP: Declaring a resource has a number of side-affects. See <a
href="http://routing.html#resource-routing-the-rails-default">Rails Routing
From the Outside In</a> for more information on setting up and using
resources.</p>

<p>When dealing with RESTful resources, calls to <code>form_for</code> can get
significantly easier if you rely on <strong>record identification</strong>.
In short, you can just pass the model instance and have <a
href="../../../../classes/Rails.html">Rails</a> figure out model name and
the rest:</p>

<pre><code>## Creating a new article
# long-style:
form_for(@article, url: articles_path)
# same thing, short-style (record identification gets used):
form_for(@article)

## Editing an existing article
# long-style:
form_for(@article, url: article_path(@article), html: {method: &quot;patch&quot;})
# short-style:
form_for(@article)
</code></pre>

<p>Notice how the short-style <code>form_for</code> invocation is conveniently
the same, regardless of the record being new or existing. Record
identification is smart enough to figure out if the record is new by asking
<code>record.new_record?</code>. It also selects the correct path to submit
to and the name based on the class of the object.</p>

<p><a href="../../../../classes/Rails.html">Rails</a> will also automatically
set the <code>class</code> and <code>id</code> of the form appropriately: a
form creating an article would have <code>id</code> and <code>class</code>
<code>new_article</code>. If you were editing the article with id 23, the
<code>class</code> would be set to <code>edit_article</code> and the id to
<code>edit_article_23</code>. These attributes will be omitted for brevity
in the rest of this guide.</p>

<p>WARNING: When you&#39;re using STI (single-table inheritance) with your
models, you can&#39;t rely on record identification on a subclass if only
their parent class is declared a resource. You will have to specify the
model name, <code>:url</code>, and <code>:method</code> explicitly.</p>

<h4 id="label-Dealing+with+Namespaces">Dealing with Namespaces</h4>

<p>If you have created namespaced routes, <code>form_for</code> has a nifty
shorthand for that too. If your application has an admin namespace then</p>

<pre><code>form_for [:admin, @article]
</code></pre>

<p>will create a form that submits to the articles controller inside the admin
namespace (submitting to <code>admin_article_path(@article)</code> in the
case of an update). If you have several levels of namespacing then the
syntax is similar:</p>

<pre><code>form_for [:admin, :management, @article]
</code></pre>

<p>For more information on Rails&#39; routing system and the associated
conventions, please see the <a href="http://routing.html">routing
guide</a>.</p>

<h3 id="label-How+do+forms+with+PATCH%2C+PUT%2C+or+DELETE+methods+work%3F">How do forms with PATCH, PUT, or DELETE methods work?</h3>

<p>The <a href="../../../../classes/Rails.html">Rails</a> framework encourages
RESTful design of your applications, which means you&#39;ll be making a lot
of “PATCH” and “DELETE” requests (besides “GET” and “POST”). However, most
browsers <em>don&#39;t support</em> methods other than “GET” and “POST”
when it comes to submitting forms.</p>

<p><a href="../../../../classes/Rails.html">Rails</a> works around this issue
by emulating other methods over POST with a hidden input named
<code>&quot;_method&quot;</code>, which is set to reflect the desired
method:</p>

<pre><code>form_tag(search_path, method: &quot;patch&quot;)
</code></pre>

<p>output:</p>

<pre><code>&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/search&quot; method=&quot;post&quot;&gt;
  &lt;div style=&quot;margin:0;padding:0&quot;&gt;
    &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;patch&quot; /&gt;
    &lt;input name=&quot;utf8&quot; type=&quot;hidden&quot; value=&quot;&amp;#x2713;&quot; /&gt;
    &lt;input name=&quot;authenticity_token&quot; type=&quot;hidden&quot; value=&quot;f755bb0ed134b76c432144748a6d4b7a7ddf2b71&quot; /&gt;
  &lt;/div&gt;
  ...</code></pre>

<p>When parsing POSTed data, <a
href="../../../../classes/Rails.html">Rails</a> will take into account the
special <code>_method</code> parameter and acts as if the HTTP method was
the one specified inside it (“PATCH” in this example).</p>

<h2 id="label-Making+Select+Boxes+with+Ease">Making <a href="../../../../classes/Select.html">Select</a> Boxes with Ease</h2>

<p><a href="../../../../classes/Select.html">Select</a> boxes in <a
href="../../../../classes/HTML.html">HTML</a> require a significant amount
of markup (one <code>OPTION</code> element for each option to choose from),
therefore it makes the most sense for them to be dynamically generated.</p>

<p>Here is what the markup might look like:</p>

<pre><code>&lt;select name=&quot;city_id&quot; id=&quot;city_id&quot;&gt;
  &lt;option value=&quot;1&quot;&gt;Lisbon&lt;/option&gt;
  &lt;option value=&quot;2&quot;&gt;Madrid&lt;/option&gt;
  ...
  &lt;option value=&quot;12&quot;&gt;Berlin&lt;/option&gt;
&lt;/select&gt;</code></pre>

<p>Here you have a list of cities whose names are presented to the user.
Internally the application only wants to handle their IDs so they are used
as the options&#39; value attribute. Let&#39;s see how <a
href="../../../../classes/Rails.html">Rails</a> can help out here.</p>

<h3 id="label-The+Select+and+Option+Tags">The <a href="../../../../classes/Select.html">Select</a> and Option Tags</h3>

<p>The most generic helper is <code>select_tag</code>, which — as the name
implies — simply generates the <code>SELECT</code> tag that encapsulates an
options string:</p>

<pre><code>&lt;%= select_tag(:city_id, &#39;&lt;option value=&quot;1&quot;&gt;Lisbon&lt;/option&gt;...&#39;) %&gt;</code></pre>

<p>This is a start, but it doesn&#39;t dynamically create the option tags. You
can generate option tags with the <code>options_for_select</code> helper:</p>

<pre><code>&lt;%= options_for_select([[&#39;Lisbon&#39;, 1], [&#39;Madrid&#39;, 2], ...]) %&gt;

output:

&lt;option value=&quot;1&quot;&gt;Lisbon&lt;/option&gt;
&lt;option value=&quot;2&quot;&gt;Madrid&lt;/option&gt;
...</code></pre>

<p>The first argument to <code>options_for_select</code> is a nested array
where each element has two elements: option text (city name) and option
value (city id). The option value is what will be submitted to your
controller. Often this will be the id of a corresponding database object
but this does not have to be the case.</p>

<p>Knowing this, you can combine <code>select_tag</code> and
<code>options_for_select</code> to achieve the desired, complete markup:</p>

<pre><code>&lt;%= select_tag(:city_id, options_for_select(...)) %&gt;</code></pre>

<p><code>options_for_select</code> allows you to pre-select an option by
passing its value.</p>

<pre><code>&lt;%= options_for_select([[&#39;Lisbon&#39;, 1], [&#39;Madrid&#39;, 2], ...], 2) %&gt;

output:

&lt;option value=&quot;1&quot;&gt;Lisbon&lt;/option&gt;
&lt;option value=&quot;2&quot; selected=&quot;selected&quot;&gt;Madrid&lt;/option&gt;
...</code></pre>

<p>Whenever <a href="../../../../classes/Rails.html">Rails</a> sees that the
internal value of an option being generated matches this value, it will add
the <code>selected</code> attribute to that option.</p>

<p>TIP: The second argument to <code>options_for_select</code> must be exactly
equal to the desired internal value. In particular if the value is the
integer 2 you cannot pass “2” to <code>options_for_select</code> — you must
pass 2. Be aware of values extracted from the <code>params</code> hash as
they are all strings.</p>

<p>WARNING: when <code>:inlude_blank</code> or <code>:prompt:</code> are not
present, <code>:include_blank</code> is forced true if the select attribute
<code>required</code> is true, display <code>size</code> is one and
<code>multiple</code> is not true.</p>

<p>You can add arbitrary attributes to the options using hashes:</p>

<pre><code>&lt;%= options_for_select([[&#39;Lisbon&#39;, 1, {&#39;data-size&#39; =&gt; &#39;2.8 million&#39;}], [&#39;Madrid&#39;, 2, {&#39;data-size&#39; =&gt; &#39;3.2 million&#39;}]], 2) %&gt;

output:

&lt;option value=&quot;1&quot; data-size=&quot;2.8 million&quot;&gt;Lisbon&lt;/option&gt;
&lt;option value=&quot;2&quot; selected=&quot;selected&quot; data-size=&quot;3.2 million&quot;&gt;Madrid&lt;/option&gt;
...</code></pre>

<h3 id="label-Select+Boxes+for+Dealing+with+Models"><a href="../../../../classes/Select.html">Select</a> Boxes for Dealing with Models</h3>

<p>In most cases form controls will be tied to a specific database model and
as you might expect <a href="../../../../classes/Rails.html">Rails</a>
provides helpers tailored for that purpose. Consistent with other form
helpers, when dealing with models you drop the <code>_tag</code> suffix
from <code>select_tag</code>:</p>

<pre><code># controller:
@person = Person.new(city_id: 2)
</code></pre>

<pre><code># view:
&lt;%= select(:person, :city_id, [[&#39;Lisbon&#39;, 1], [&#39;Madrid&#39;, 2], ...]) %&gt;</code></pre>

<p>Notice that the third parameter, the options array, is the same kind of
argument you pass to <code>options_for_select</code>. <a
href="../../../../classes/One.html">One</a> advantage here is that you
don&#39;t have to worry about pre-selecting the correct city if the user
already has one — <a href="../../../../classes/Rails.html">Rails</a> will
do this for you by reading from the <code>@person.city_id</code> attribute.</p>

<p>As with other helpers, if you were to use the <code>select</code> helper on
a form builder scoped to the <code>@person</code> object, the syntax would
be:</p>

<pre><code># select on a form builder
&lt;%= f.select(:city_id, ...) %&gt;</code></pre>

<p>WARNING: If you are using <code>select</code> (or similar helpers such as
<code>collection_select</code>, <code>select_tag</code>) to set a
<code>belongs_to</code> association you must pass the name of the foreign
key (in the example above <code>city_id</code>), not the name of
association itself. If you specify <code>city</code> instead of
<code>city_id</code> Active Record will raise an error along the lines of
<code>ActiveRecord::AssociationTypeMismatch: City(#17815740) expected, got
String(#1138750)</code> when you pass the <code>params</code> hash to
<code>Person.new</code> or <code>update</code>. <a
href="../../../../classes/Another.html">Another</a> way of looking at this
is that form helpers only edit attributes. You should also be aware of the
potential security ramifications of allowing users to edit foreign keys
directly.</p>

<h3 id="label-Option+Tags+from+a+Collection+of+Arbitrary+Objects">Option Tags from a Collection of Arbitrary Objects</h3>

<p>Generating options tags with <code>options_for_select</code> requires that
you create an array containing the text and value for each option. But what
if you had a City model (perhaps an Active Record one) and you wanted to
generate option tags from a collection of those objects? <a
href="../../../../classes/One.html">One</a> solution would be to make a
nested array by iterating over them:</p>

<pre><code>&lt;% cities_array = City.all.map { |city| [city.name, city.id] } %&gt;
&lt;%= options_for_select(cities_array) %&gt;</code></pre>

<p>This is a perfectly valid solution, but <a
href="../../../../classes/Rails.html">Rails</a> provides a less verbose
alternative: <code>options_from_collection_for_select</code>. This helper
expects a collection of arbitrary objects and two additional arguments: the
names of the methods to read the option <strong>value</strong> and
<strong>text</strong> from, respectively:</p>

<pre><code>&lt;%= options_from_collection_for_select(City.all, :id, :name) %&gt;</code></pre>

<p>As the name implies, this only generates option tags. To generate a working
select box you would need to use it in conjunction with
<code>select_tag</code>, just as you would with
<code>options_for_select</code>. When working with model objects, just as
<code>select</code> combines <code>select_tag</code> and
<code>options_for_select</code>, <code>collection_select</code> combines
<code>select_tag</code> with
<code>options_from_collection_for_select</code>.</p>

<pre><code>&lt;%= collection_select(:person, :city_id, City.all, :id, :name) %&gt;</code></pre>

<p>To recap, <code>options_from_collection_for_select</code> is to
<code>collection_select</code> what <code>options_for_select</code> is to
<code>select</code>.</p>

<p>NOTE: Pairs passed to <code>options_for_select</code> should have the name
first and the id second, however with
<code>options_from_collection_for_select</code> the first argument is the
value method and the second the text method.</p>

<h3 id="label-Time+Zone+and+Country+Select"><a href="../../../../classes/Time.html">Time</a> Zone and <a href="../../../../classes/Country.html">Country</a> <a href="../../../../classes/Select.html">Select</a></h3>

<p>To leverage time zone support in <a
href="../../../../classes/Rails.html">Rails</a>, you have to ask your users
what time zone they are in. Doing so would require generating select
options from a list of pre-defined TimeZone objects using
<code>collection_select</code>, but you can simply use the
<code>time_zone_select</code> helper that already wraps this:</p>

<pre><code>&lt;%= time_zone_select(:person, :time_zone) %&gt;</code></pre>

<p>There is also <code>time_zone_options_for_select</code> helper for a more
manual (therefore more customizable) way of doing this. Read the API
documentation to learn about the possible arguments for these two methods.</p>

<p><a href="../../../../classes/Rails.html">Rails</a> <em>used</em> to have a
<code>country_select</code> helper for choosing countries, but this has
been extracted to the <a
href="https://github.com/stefanpenner/country_select">country_select
plugin</a>. When using this, be aware that the exclusion or inclusion of
certain names from the list can be somewhat controversial (and was the
reason this functionality was extracted from <a
href="../../../../classes/Rails.html">Rails</a>).</p>

<h2 id="label-Using+Date+and+Time+Form+Helpers">Using <a href="../../../../classes/Date.html">Date</a> and <a href="../../../../classes/Time.html">Time</a> Form Helpers</h2>

<p>You can choose not to use the form helpers generating HTML5 date and time
input fields and use the alternative date and time helpers. These date and
time helpers differ from all the other form helpers in two important
respects:</p>
<ul><li>
<p>Dates and times are not representable by a single input element. Instead
you have several, one for each component (year, month, day etc.) and so
there is no single value in your <code>params</code> hash with your date or
time.</p>
</li><li>
<p>Other helpers use the <code>_tag</code> suffix to indicate whether a helper
is a barebones helper or one that operates on model objects. With dates and
times, <code>select_date</code>, <code>select_time</code> and
<code>select_datetime</code> are the barebones helpers,
<code>date_select</code>, <code>time_select</code> and
<code>datetime_select</code> are the equivalent model object helpers.</p>
</li></ul>

<p>Both of these families of helpers will create a series of select boxes for
the different components (year, month, day etc.).</p>

<h3 id="label-Barebones+Helpers">Barebones Helpers</h3>

<p>The <code>select_*</code> family of helpers take as their first argument an
instance of <a href="../../../../classes/Date.html">Date</a>, <a
href="../../../../classes/Time.html">Time</a> or <a
href="../../../../classes/DateTime.html">DateTime</a> that is used as the
currently selected value. You may omit this parameter, in which case the
current date is used. For example</p>

<pre><code>&lt;%= select_date Date.today, prefix: :start_date %&gt;</code></pre>

<p>outputs (with actual option values omitted for brevity)</p>

<pre><code>&lt;select id=&quot;start_date_year&quot; name=&quot;start_date[year]&quot;&gt; ... &lt;/select&gt;
&lt;select id=&quot;start_date_month&quot; name=&quot;start_date[month]&quot;&gt; ... &lt;/select&gt;
&lt;select id=&quot;start_date_day&quot; name=&quot;start_date[day]&quot;&gt; ... &lt;/select&gt;</code></pre>

<p>The above inputs would result in <code>params[:start_date]</code> being a
hash with keys <code>:year</code>, <code>:month</code>, <code>:day</code>.
To get an actual <a href="../../../../classes/Time.html">Time</a> or <a
href="../../../../classes/Date.html">Date</a> object you would have to
extract these values and pass them to the appropriate constructor, for
example</p>

<pre><code>Date.civil(params[:start_date][:year].to_i, params[:start_date][:month].to_i, params[:start_date][:day].to_i)
</code></pre>

<p>The <code>:prefix</code> option is the key used to retrieve the hash of
date components from the <code>params</code> hash. Here it was set to
<code>start_date</code>, if omitted it will default to <code>date</code>.</p>

<h3 id="label-Model+Object+Helpers">Model <a href="../../../../classes/Object.html">Object</a> Helpers</h3>

<p><code>select_date</code> does not work well with forms that update or
create Active Record objects as Active Record expects each element of the
<code>params</code> hash to correspond to one attribute. The model object
helpers for dates and times submit parameters with special names; when
Active Record sees parameters with such names it knows they must be
combined with the other parameters and given to a constructor appropriate
to the column type. For example:</p>

<pre><code>&lt;%= date_select :person, :birth_date %&gt;</code></pre>

<p>outputs (with actual option values omitted for brevity)</p>

<pre><code>&lt;select id=&quot;person_birth_date_1i&quot; name=&quot;person[birth_date(1i)]&quot;&gt; ... &lt;/select&gt;
&lt;select id=&quot;person_birth_date_2i&quot; name=&quot;person[birth_date(2i)]&quot;&gt; ... &lt;/select&gt;
&lt;select id=&quot;person_birth_date_3i&quot; name=&quot;person[birth_date(3i)]&quot;&gt; ... &lt;/select&gt;</code></pre>

<p>which results in a <code>params</code> hash like</p>

<pre><code>{:person =&gt; {&#39;birth_date(1i)&#39; =&gt; &#39;2008&#39;, &#39;birth_date(2i)&#39; =&gt; &#39;11&#39;, &#39;birth_date(3i)&#39; =&gt; &#39;22&#39;}}
</code></pre>

<p>When this is passed to <code>Person.new</code> (or <code>update</code>),
Active Record spots that these parameters should all be used to construct
the <code>birth_date</code> attribute and uses the suffixed information to
determine in which order it should pass these parameters to functions such
as <code>Date.civil</code>.</p>

<h3 id="label-Common+Options">Common Options</h3>

<p>Both families of helpers use the same core set of functions to generate the
individual select tags and so both accept largely the same options. In
particular, by default <a href="../../../../classes/Rails.html">Rails</a>
will generate year options 5 years either side of the current year. If this
is not an appropriate range, the <code>:start_year</code> and
<code>:end_year</code> options override this. For an exhaustive list of the
available options, refer to the <a
href="http://api.rubyonrails.org/classes/ActionView/Helpers/DateHelper.html">API
documentation</a>.</p>

<p>As a rule of thumb you should be using <code>date_select</code> when
working with model objects and <code>select_date</code> in other cases,
such as a search form which filters results by date.</p>

<p>NOTE: In many cases the built-in date pickers are clumsy as they do not aid
the user in working out the relationship between the date and the day of
the week.</p>

<h3 id="label-Individual+Components">Individual Components</h3>

<p>Occasionally you need to display just a single date component such as a
year or a month. <a href="../../../../classes/Rails.html">Rails</a>
provides a series of helpers for this, one for each component
<code>select_year</code>, <code>select_month</code>,
<code>select_day</code>, <code>select_hour</code>,
<code>select_minute</code>, <code>select_second</code>. These helpers are
fairly straightforward. By default they will generate an input field named
after the time component (for example “year” for <code>select_year</code>,
“month” for <code>select_month</code> etc.) although this can be overridden
with the <code>:field_name</code> option. The <code>:prefix</code> option
works in the same way that it does for <code>select_date</code> and
<code>select_time</code> and has the same default value.</p>

<p>The first parameter specifies which value should be selected and can either
be an instance of a <a href="../../../../classes/Date.html">Date</a>, <a
href="../../../../classes/Time.html">Time</a> or <a
href="../../../../classes/DateTime.html">DateTime</a>, in which case the
relevant component will be extracted, or a numerical value. For example</p>

<pre><code>&lt;%= select_year(2009) %&gt;
&lt;%= select_year(Time.now) %&gt;</code></pre>

<p>will produce the same output if the current year is 2009 and the value
chosen by the user can be retrieved by <code>params[:date][:year]</code>.</p>

<h2 id="label-Uploading+Files">Uploading Files</h2>

<p><a href="../../../../classes/A.html">A</a> common task is uploading some
sort of file, whether it&#39;s a picture of a person or a CSV file
containing data to process. The most important thing to remember with file
uploads is that the rendered form&#39;s encoding <strong>MUST</strong> be
set to “multipart/form-data”. If you use <code>form_for</code>, this is
done automatically. If you use <code>form_tag</code>, you must set it
yourself, as per the following example.</p>

<p>The following two forms both upload a file.</p>

<pre><code>&lt;%= form_tag({action: :upload}, multipart: true) do %&gt;
  &lt;%= file_field_tag &#39;picture&#39; %&gt;
&lt;% end %&gt;

&lt;%= form_for @person do |f| %&gt;
  &lt;%= f.file_field :picture %&gt;
&lt;% end %&gt;</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> provides the usual pair
of helpers: the barebones <code>file_field_tag</code> and the model
oriented <code>file_field</code>. The only difference with other helpers is
that you cannot set a default value for file inputs as this would have no
meaning. As you would expect in the first case the uploaded file is in
<code>params[:picture]</code> and in the second case in
<code>params[:person][:picture]</code>.</p>

<h3 id="label-What+Gets+Uploaded">What Gets Uploaded</h3>

<p>The object in the <code>params</code> hash is an instance of a subclass of
IO. Depending on the size of the uploaded file it may in fact be a StringIO
or an instance of <a href="../../../../classes/File.html">File</a> backed
by a temporary file. In both cases the object will have an
<code>original_filename</code> attribute containing the name the file had
on the user&#39;s computer and a <code>content_type</code> attribute
containing the MIME type of the uploaded file. The following snippet saves
the uploaded content in <code>#{Rails.root}/public/uploads</code> under the
same name as the original file (assuming the form was the one in the
previous example).</p>

<pre><code>def upload
  uploaded_io = params[:person][:picture]
  File.open(Rails.root.join(&#39;public&#39;, &#39;uploads&#39;, uploaded_io.original_filename), &#39;w&#39;) do |file|
    file.write(uploaded_io.read)
  end
end
</code></pre>

<p>Once a file has been uploaded, there are a multitude of potential tasks,
ranging from where to store the files (on disk, Amazon S3, etc) and
associating them with models to resizing image files and generating
thumbnails. The intricacies of this are beyond the scope of this guide, but
there are several libraries designed to assist with these. Two of the
better known ones are <a
href="https://github.com/jnicklas/carrierwave">CarrierWave</a> and <a
href="http://www.thoughtbot.com/projects/paperclip">Paperclip</a>.</p>

<p>NOTE: If the user has not selected a file the corresponding parameter will
be an empty string.</p>

<h3 id="label-Dealing+with+Ajax">Dealing with Ajax</h3>

<p>Unlike other forms making an asynchronous file upload form is not as simple
as providing <code>form_for</code> with <code>remote: true</code>. With an
Ajax form the serialization is done by JavaScript running inside the
browser and since JavaScript cannot read files from your hard drive the
file cannot be uploaded. The most common workaround is to use an invisible
iframe that serves as the target for the form submission.</p>

<h2 id="label-Customizing+Form+Builders">Customizing Form Builders</h2>

<p>As mentioned previously the object yielded by <code>form_for</code> and
<code>fields_for</code> is an instance of FormBuilder (or a subclass
thereof). Form builders encapsulate the notion of displaying form elements
for a single object. While you can of course write helpers for your forms
in the usual way, you can also subclass FormBuilder and add the helpers
there. For example</p>

<pre><code>&lt;%= form_for @person do |f| %&gt;
  &lt;%= text_field_with_label f, :first_name %&gt;
&lt;% end %&gt;</code></pre>

<p>can be replaced with</p>

<pre><code>&lt;%= form_for @person, builder: LabellingFormBuilder do |f| %&gt;
  &lt;%= f.text_field :first_name %&gt;
&lt;% end %&gt;</code></pre>

<p>by defining a LabellingFormBuilder class similar to the following:</p>

<pre><code>class LabellingFormBuilder &lt; ActionView::Helpers::FormBuilder
  def text_field(attribute, options={})
    label(attribute) + super
  end
end
</code></pre>

<p>If you reuse this frequently you could define a
<code>labeled_form_for</code> helper that automatically applies the
<code>builder: LabellingFormBuilder</code> option.</p>

<p>The form builder used also determines what happens when you do</p>

<pre><code>&lt;%= render partial: f %&gt;</code></pre>

<p>If <code>f</code> is an instance of FormBuilder then this will render the
<code>form</code> partial, setting the partial&#39;s object to the form
builder. If the form builder is of class LabellingFormBuilder then the
<code>labelling_form</code> partial would be rendered instead.</p>

<h2 id="label-Understanding+Parameter+Naming+Conventions">Understanding Parameter Naming Conventions</h2>

<p>As you&#39;ve seen in the previous sections, values from forms can be at
the top level of the <code>params</code> hash or nested in another hash.
For example in a standard <code>create</code> action for a <a
href="../../../../classes/Person.html">Person</a> model,
<code>params[:person]</code> would usually be a hash of all the attributes
for the person to create. The <code>params</code> hash can also contain
arrays, arrays of hashes and so on.</p>

<p>Fundamentally <a href="../../../../classes/HTML.html">HTML</a> forms
don&#39;t know about any sort of structured data, all they generate is
name–value pairs, where pairs are just plain strings. The arrays and hashes
you see in your application are the result of some parameter naming
conventions that <a href="../../../../classes/Rails.html">Rails</a> uses.</p>

<p>TIP: You may find you can try out examples in this section faster by using
the console to directly invoke Racks&#39; parameter parser. For example,</p>

<pre><code>Rack::Utils.parse_query &quot;name=fred&amp;phone=0123456789&quot;
# =&gt; {&quot;name&quot;=&gt;&quot;fred&quot;, &quot;phone&quot;=&gt;&quot;0123456789&quot;}
</code></pre>

<h3 id="label-Basic+Structures">Basic Structures</h3>

<p>The two basic structures are arrays and hashes. Hashes mirror the syntax
used for accessing the value in <code>params</code>. For example if a form
contains</p>

<pre><code>&lt;input id=&quot;person_name&quot; name=&quot;person[name]&quot; type=&quot;text&quot; value=&quot;Henry&quot;/&gt;</code></pre>

<p>the <code>params</code> hash will contain</p>

<pre><code>{&#39;person&#39; =&gt; {&#39;name&#39; =&gt; &#39;Henry&#39;}}
</code></pre>

<p>and <code>params[:person][:name]</code> will retrieve the submitted value
in the controller.</p>

<p>Hashes can be nested as many levels as required, for example</p>

<pre><code>&lt;input id=&quot;person_address_city&quot; name=&quot;person[address][city]&quot; type=&quot;text&quot; value=&quot;New York&quot;/&gt;</code></pre>

<p>will result in the <code>params</code> hash being</p>

<pre><code>{&#39;person&#39; =&gt; {&#39;address&#39; =&gt; {&#39;city&#39; =&gt; &#39;New York&#39;}}}
</code></pre>

<p>Normally <a href="../../../../classes/Rails.html">Rails</a> ignores
duplicate parameter names. If the parameter name contains an empty set of
square brackets [] then they will be accumulated in an array. If you wanted
people to be able to input multiple phone numbers, you could place this in
the form:</p>

<pre><code>&lt;input name=&quot;person[phone_number][]&quot; type=&quot;text&quot;/&gt;
&lt;input name=&quot;person[phone_number][]&quot; type=&quot;text&quot;/&gt;
&lt;input name=&quot;person[phone_number][]&quot; type=&quot;text&quot;/&gt;</code></pre>

<p>This would result in <code>params[:person][:phone_number]</code> being an
array.</p>

<h3 id="label-Combining+Them">Combining Them</h3>

<p>We can mix and match these two concepts. For example, one element of a hash
might be an array as in the previous example, or you can have an array of
hashes. For example a form might let you create any number of addresses by
repeating the following form fragment</p>

<pre><code>&lt;input name=&quot;addresses[][line1]&quot; type=&quot;text&quot;/&gt;
&lt;input name=&quot;addresses[][line2]&quot; type=&quot;text&quot;/&gt;
&lt;input name=&quot;addresses[][city]&quot; type=&quot;text&quot;/&gt;</code></pre>

<p>This would result in <code>params[:addresses]</code> being an array of
hashes with keys <code>line1</code>, <code>line2</code> and
<code>city</code>. <a href="../../../../classes/Rails.html">Rails</a>
decides to start accumulating values in a new hash whenever it encounters
an input name that already exists in the current hash.</p>

<p>There&#39;s a restriction, however, while hashes can be nested arbitrarily,
only one level of “arrayness” is allowed. Arrays can be usually replaced by
hashes, for example instead of having an array of model objects one can
have a hash of model objects keyed by their id, an array index or some
other parameter.</p>

<p>WARNING: <a href="../../../../classes/Array.html">Array</a> parameters do
not play well with the <code>check_box</code> helper. According to the <a
href="../../../../classes/HTML.html">HTML</a> specification unchecked
checkboxes submit no value. However it is often convenient for a checkbox
to always submit a value. The <code>check_box</code> helper fakes this by
creating an auxiliary hidden input with the same name. If the checkbox is
unchecked only the hidden input is submitted and if it is checked then both
are submitted but the value submitted by the checkbox takes precedence.
When working with array parameters this duplicate submission will confuse
<a href="../../../../classes/Rails.html">Rails</a> since duplicate input
names are how it decides when to start a new array element. It is
preferable to either use <code>check_box_tag</code> or to use hashes
instead of arrays.</p>

<h3 id="label-Using+Form+Helpers">Using Form Helpers</h3>

<p>The previous sections did not use the <a
href="../../../../classes/Rails.html">Rails</a> form helpers at all. While
you can craft the input names yourself and pass them directly to helpers
such as <code>text_field_tag</code> <a
href="../../../../classes/Rails.html">Rails</a> also provides higher level
support. The two tools at your disposal here are the name parameter to
<code>form_for</code> and <code>fields_for</code> and the
<code>:index</code> option that helpers take.</p>

<p>You might want to render a form with a set of edit fields for each of a
person&#39;s addresses. For example:</p>

<pre><code>&lt;%= form_for @person do |person_form| %&gt;
  &lt;%= person_form.text_field :name %&gt;
  &lt;% @person.addresses.each do |address| %&gt;
    &lt;%= person_form.fields_for address, index: address do |address_form|%&gt;
      &lt;%= address_form.text_field :city %&gt;
    &lt;% end %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;</code></pre>

<p>Assuming the person had two addresses, with ids 23 and 45 this would create
output similar to this:</p>

<pre><code>&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/people/1&quot; class=&quot;edit_person&quot; id=&quot;edit_person_1&quot; method=&quot;post&quot;&gt;
  &lt;input id=&quot;person_name&quot; name=&quot;person[name]&quot; type=&quot;text&quot; /&gt;
  &lt;input id=&quot;person_address_23_city&quot; name=&quot;person[address][23][city]&quot; type=&quot;text&quot; /&gt;
  &lt;input id=&quot;person_address_45_city&quot; name=&quot;person[address][45][city]&quot; type=&quot;text&quot; /&gt;
&lt;/form&gt;</code></pre>

<p>This will result in a <code>params</code> hash that looks like</p>

<pre><code>{&#39;person&#39; =&gt; {&#39;name&#39; =&gt; &#39;Bob&#39;, &#39;address&#39; =&gt; {&#39;23&#39; =&gt; {&#39;city&#39; =&gt; &#39;Paris&#39;}, &#39;45&#39; =&gt; {&#39;city&#39; =&gt; &#39;London&#39;}}}}
</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> knows that all these
inputs should be part of the person hash because you called
<code>fields_for</code> on the first form builder. By specifying an
<code>:index</code> option you&#39;re telling <a
href="../../../../classes/Rails.html">Rails</a> that instead of naming the
inputs <code>person[address][city]</code> it should insert that index
surrounded by [] between the address and the city. If you pass an Active
Record object as we did then <a
href="../../../../classes/Rails.html">Rails</a> will call
<code>to_param</code> on it, which by default returns the database id. This
is often useful as it is then easy to locate which <a
href="../../../../classes/Address.html">Address</a> record should be
modified. You can pass numbers with some other significance, strings or
even <code>nil</code> (which will result in an array parameter being
created).</p>

<p>To create more intricate nestings, you can specify the first part of the
input name (<code>person[address]</code> in the previous example)
explicitly, for example</p>

<pre><code>&lt;%= fields_for &#39;person[address][primary]&#39;, address, index: address do |address_form| %&gt;
  &lt;%= address_form.text_field :city %&gt;
&lt;% end %&gt;</code></pre>

<p>will create inputs like</p>

<pre><code>&lt;input id=&quot;person_address_primary_1_city&quot; name=&quot;person[address][primary][1][city]&quot; type=&quot;text&quot; value=&quot;bologna&quot; /&gt;</code></pre>

<p>As a general rule the final input name is the concatenation of the name
given to <code>fields_for</code>/<code>form_for</code>, the index value and
the name of the attribute. You can also pass an <code>:index</code> option
directly to helpers such as <code>text_field</code>, but it is usually less
repetitive to specify this at the form builder level rather than on
individual input controls.</p>

<p>As a shortcut you can append [] to the name and omit the
<code>:index</code> option. This is the same as specifying <code>index:
address</code> so</p>

<pre><code>&lt;%= fields_for &#39;person[address][primary][]&#39;, address do |address_form| %&gt;
  &lt;%= address_form.text_field :city %&gt;
&lt;% end %&gt;</code></pre>

<p>produces exactly the same output as the previous example.</p>

<h2 id="label-Forms+to+external+resources">Forms to external resources</h2>

<p>If you need to post some data to an external resource it is still great to
build your form using rails form helpers. But sometimes you need to set an
<code>authenticity_token</code> for this resource. You can do it by passing
an <code>authenticity_token: &#39;your_external_token&#39;</code> parameter
to the <code>form_tag</code> options:</p>

<pre><code>&lt;%= form_tag &#39;http://farfar.away/form&#39;, authenticity_token: &#39;external_token&#39;) do %&gt;
  Form contents
&lt;% end %&gt;</code></pre>

<p>Sometimes when you submit data to an external resource, like payment
gateway, fields you can use in your form are limited by an external API. So
you may want not to generate an <code>authenticity_token</code> hidden
field at all. For doing this just pass <code>false</code> to the
<code>:authenticity_token</code> option:</p>

<pre><code>&lt;%= form_tag &#39;http://farfar.away/form&#39;, authenticity_token: false) do %&gt;
  Form contents
&lt;% end %&gt;</code></pre>

<p>The same technique is also available for <code>form_for</code>:</p>

<pre><code>&lt;%= form_for @invoice, url: external_url, authenticity_token: &#39;external_token&#39; do |f| %&gt;
  Form contents
&lt;% end %&gt;</code></pre>

<p>Or if you don&#39;t want to render an <code>authenticity_token</code>
field:</p>

<pre><code>&lt;%= form_for @invoice, url: external_url, authenticity_token: false do |f| %&gt;
  Form contents
&lt;% end %&gt;</code></pre>

<h2 id="label-Building+Complex+Forms">Building Complex Forms</h2>

<p>Many apps grow beyond simple forms editing a single object. For example
when creating a <a href="../../../../classes/Person.html">Person</a> you
might want to allow the user to (on the same form) create multiple address
records (home, work, etc.). When later editing that person the user should
be able to add, remove or amend addresses as necessary.</p>

<h3 id="label-Configuring+the+Model">Configuring the Model</h3>

<p>Active Record provides model level support via the
<code>accepts_nested_attributes_for</code> method:</p>

<pre><code>class Person &lt; ActiveRecord::Base
  has_many :addresses
  accepts_nested_attributes_for :addresses

  attr_accessible :name, :addresses_attributes
end

class Address &lt; ActiveRecord::Base
  belongs_to :person
  attr_accessible :kind, :street
end
</code></pre>

<p>This creates an <code>addresses_attributes=</code> method on
<code>Person</code> that allows you to create, update and (optionally)
destroy addresses. When using <code>attr_accessible</code> or
<code>attr_protected</code> you must mark <code>addresses_attributes</code>
as accessible as well as the other attributes of <code>Person</code> and
<code>Address</code> that should be mass assigned.</p>

<h3 id="label-Building+the+Form">Building the Form</h3>

<p>The following form allows a user to create a <code>Person</code> and its
associated addresses.</p>

<pre><code>&lt;%= form_for @person do |f| %&gt;
  Addresses:
  &lt;ul&gt;
    &lt;%= f.fields_for :addresses do |addresses_form| %&gt;
      &lt;li&gt;
        &lt;%= addresses_form.label :kind %&gt;
        &lt;%= addresses_form.text_field :kind %&gt;

        &lt;%= addresses_form.label :street %&gt;
        &lt;%= addresses_form.text_field :street %&gt;
        ...
      &lt;/li&gt;
    &lt;% end %&gt;
  &lt;/ul&gt;
&lt;% end %&gt;</code></pre>

<p>When an association accepts nested attributes <code>fields_for</code>
renders its block once for every element of the association. In particular,
if a person has no addresses it renders nothing. <a
href="../../../../classes/A.html">A</a> common pattern is for the
controller to build one or more empty children so that at least one set of
fields is shown to the user. The example below would result in 3 sets of
address fields being rendered on the new person form.</p>

<pre><code>def new
  @person = Person.new
  3.times { @person.addresses.build}
end
</code></pre>

<p><code>fields_for</code> yields a form builder that names parameters in the
format expected the accessor generated by
<code>accepts_nested_attributes_for</code>. For example when creating a
user with 2 addresses, the submitted parameters would look like</p>

<pre><code>{
    :person =&gt; {
        :name =&gt; &#39;John Doe&#39;,
        :addresses_attributes =&gt; {
            &#39;0&#39; =&gt; {
                :kind  =&gt; &#39;Home&#39;,
                :street =&gt; &#39;221b Baker Street&#39;,
            },
            &#39;1&#39; =&gt; {
                :kind =&gt; &#39;Office&#39;,
                :street =&gt; &#39;31 Spooner Street&#39;
            }
        }
    }
}
</code></pre>

<p>The keys of the <code>:addresses_attributes</code> hash are unimportant,
they need merely be different for each address.</p>

<p>If the associated object is already saved, <code>fields_for</code>
autogenerates a hidden input with the <code>id</code> of the saved record.
You can disable this by passing <code>include_id: false</code> to
<code>fields_for</code>. You may wish to do this if the autogenerated input
is placed in a location where an input tag is not valid <a
href="../../../../classes/HTML.html">HTML</a> or when using an ORM where
children do not have an id.</p>

<h3 id="label-The+Controller">The Controller</h3>

<p>You do not need to write any specific controller code to use nested
attributes. Create and update records as you would with a simple form.</p>

<h3 id="label-Removing+Objects">Removing Objects</h3>

<p>You can allow users to delete associated objects by passing
<code>allow_destroy: true</code> to
<code>accepts_nested_attributes_for</code></p>

<pre><code>class Person &lt; ActiveRecord::Base
  has_many :addresses
  accepts_nested_attributes_for :addresses, allow_destroy: true
end
</code></pre>

<p>If the hash of attributes for an object contains the key
<code>_destroy</code> with a value of &#39;1&#39; or &#39;true&#39; then
the object will be destroyed. This form allows users to remove addresses:</p>

<pre><code>&lt;%= form_for @person do |f| %&gt;
  Addresses:
  &lt;ul&gt;
    &lt;%= f.fields_for :addresses do |addresses_form| %&gt;
      &lt;li&gt;
        &lt;%= check_box :_destroy%&gt;
        &lt;%= addresses_form.label :kind %&gt;
        &lt;%= addresses_form.text_field :kind %&gt;
        ...
      &lt;/li&gt;
    &lt;% end %&gt;
  &lt;/ul&gt;
&lt;% end %&gt;</code></pre>

<h3 id="label-Preventing+Empty+Records">Preventing Empty Records</h3>

<p>It is often useful to ignore sets of fields that the user has not filled
in. You can control this by passing a <code>:reject_if</code> proc to
<code>accepts_nested_attributes_for</code>. This proc will be called with
each hash of attributes submitted by the form. If the proc returns
<code>false</code> then Active Record will not build an associated object
for that hash. The example below only tries to build an address if the
<code>kind</code> attribute is set.</p>

<pre><code>class Person &lt; ActiveRecord::Base
  has_many :addresses
  accepts_nested_attributes_for :addresses, reject_if: lambda {|attributes| attributes[&#39;kind&#39;].blank?}
end
</code></pre>

<p>As a convenience you can instead pass the symbol <code>:all_blank</code>
which will create a proc that will reject records where all the attributes
are blank excluding any value for <code>_destroy</code>.</p>

<h3 id="label-Adding+Fields+on+the+Fly">Adding Fields on the Fly</h3>

<p>Rather than rendering multiple sets of fields ahead of time you may wish to
add them only when a user clicks on an &#39;Add new child&#39; button. <a
href="../../../../classes/Rails.html">Rails</a> does not provide any
builtin support for this. When generating new sets of fields you must
ensure the the key of the associated array is unique - the current
javascript date (milliseconds after the epoch) is a common choice.</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>