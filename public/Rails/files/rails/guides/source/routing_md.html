<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>routing.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            routing.md
        </h1>
        <ul class="files">
            <li>rails/guides/source/routing.md</li>
            <li>Last modified: 2013-04-26 19:51:18 +0300</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-Rails+Routing+from+the+Outside+In"><a href="../../../../classes/Rails.html">Rails</a> Routing from the Outside In</h1>

<p>This guide covers the user-facing features of <a
href="../../../../classes/Rails.html">Rails</a> routing.</p>

<p>After reading this guide, you will know:</p>
<ul><li>
<p>How to interpret the code in <code>routes.rb</code>.</p>
</li><li>
<p>How to construct your own routes, using either the preferred resourceful
style or the <code>match</code> method.</p>
</li><li>
<p>What parameters to expect an action to receive.</p>
</li><li>
<p>How to automatically create paths and URLs using route helpers.</p>
</li><li>
<p>Advanced techniques such as constraints and <a
href="../../../../classes/Rack.html">Rack</a> endpoints.</p>
</li></ul>
<hr style="height: 1px">

<h2 id="label-The+Purpose+of+the+Rails+Router">The Purpose of the <a href="../../../../classes/Rails.html">Rails</a> Router</h2>

<p>The <a href="../../../../classes/Rails.html">Rails</a> router recognizes
URLs and dispatches them to a controller&#39;s action. It can also generate
paths and URLs, avoiding the need to hardcode strings in your views.</p>

<h3 id="label-Connecting+URLs+to+Code">Connecting URLs to Code</h3>

<p>When your <a href="../../../../classes/Rails.html">Rails</a> application
receives an incoming request for:</p>

<pre><code>GET /patients/17</code></pre>

<p>it asks the router to match it to a controller action. If the first
matching route is:</p>

<pre><code>get &#39;/patients/:id&#39;, to: &#39;patients#show&#39;
</code></pre>

<p>the request is dispatched to the <code>patients</code> controller&#39;s
<code>show</code> action with <code>{ id: &#39;17&#39; }</code> in
<code>params</code>.</p>

<h3 id="label-Generating+Paths+and+URLs+from+Code">Generating Paths and URLs from Code</h3>

<p>You can also generate paths and URLs. If the route above is modified to be:</p>

<pre><code>get &#39;/patients/:id&#39;, to: &#39;patients#show&#39;, as: &#39;patient&#39;
</code></pre>

<p>and your application contains this code in the controller:</p>

<pre><code>@patient = Patient.find(17)
</code></pre>

<p>and this in the corresponding view:</p>

<pre><code>&lt;%= link_to &#39;Patient Record&#39;, patient_path(@patient) %&gt;</code></pre>

<p>then the router will generate the path <code>/patients/17</code>. This
reduces the brittleness of your view and makes your code easier to
understand. Note that the id does not need to be specified in the route
helper.</p>

<h2 id="label-Resource+Routing%3A+the+Rails+Default">Resource Routing: the <a href="../../../../classes/Rails.html">Rails</a> <a href="../../../../classes/Default.html">Default</a></h2>

<p>Resource routing allows you to quickly declare all of the common routes for
a given resourceful controller. Instead of declaring separate routes for
your <code>index</code>, <code>show</code>, <code>new</code>,
<code>edit</code>, <code>create</code>, <code>update</code> and
<code>destroy</code> actions, a resourceful route declares them in a single
line of code.</p>

<h3 id="label-Resources+on+the+Web">Resources on the <a href="../../../../classes/Web.html">Web</a></h3>

<p>Browsers request pages from <a
href="../../../../classes/Rails.html">Rails</a> by making a request for a
URL using a specific HTTP method, such as <code>GET</code>,
<code>POST</code>, <code>PATCH</code>, <code>PUT</code> and
<code>DELETE</code>. Each method is a request to perform an operation on
the resource. <a href="../../../../classes/A.html">A</a> resource route
maps a number of related requests to actions in a single controller.</p>

<p>When your <a href="../../../../classes/Rails.html">Rails</a> application
receives an incoming request for:</p>

<pre><code>DELETE /photos/17</code></pre>

<p>it asks the router to map it to a controller action. If the first matching
route is:</p>

<pre><code>resources :photos
</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> would dispatch that
request to the <code>destroy</code> method on the <code>photos</code>
controller with <code>{ id: &#39;17&#39; }</code> in <code>params</code>.</p>

<h3 id="label-CRUD%2C+Verbs%2C+and+Actions">CRUD, Verbs, and Actions</h3>

<p>In <a href="../../../../classes/Rails.html">Rails</a>, a resourceful route
provides a mapping between HTTP verbs and URLs to controller actions. By
convention, each action also maps to particular CRUD operations in a
database. <a href="../../../../classes/A.html">A</a> single entry in the
routing file, such as:</p>

<pre><code>resources :photos
</code></pre>

<p>creates seven different routes in your application, all mapping to the
<code>Photos</code> controller:</p>

<p>| HTTP Verb | Path | Action | Used for | | ——— | —————- | ——- |
——————————————– | | GET | /photos | index | display a list of all photos |
| GET | /photos/new | new | return an <a
href="../../../../classes/HTML.html">HTML</a> form for creating a new photo
| | POST | /photos | create | create a new photo | | GET | /photos/:id |
show | display a specific photo | | GET | /photos/:id/edit | edit | return
an <a href="../../../../classes/HTML.html">HTML</a> form for editing a
photo | | PATCH/PUT | /photos/:id | update | update a specific photo | |
DELETE | /photos/:id | destroy | delete a specific photo |</p>

<p>NOTE: Because the router uses the HTTP verb and URL to match inbound
requests, four URLs map to seven different actions.</p>

<p>NOTE: <a href="../../../../classes/Rails.html">Rails</a> routes are matched
in the order they are specified, so if you have a <code>resources
:photos</code> above a <code>get &#39;photos/poll&#39;</code> the
<code>show</code> action&#39;s route for the <code>resources</code> line
will be matched before the <code>get</code> line. To fix this, move the
<code>get</code> line <strong>above</strong> the <code>resources</code>
line so that it is matched first.</p>

<h3 id="label-Path+and+URL+Helpers">Path and URL Helpers</h3>

<p>Creating a resourceful route will also expose a number of helpers to the
controllers in your application. In the case of <code>resources
:photos</code>:</p>
<ul><li>
<p><code>photos_path</code> returns <code>/photos</code></p>
</li><li>
<p><code>new_photo_path</code> returns <code>/photos/new</code></p>
</li><li>
<p><code>edit_photo_path(:id)</code> returns <code>/photos/:id/edit</code>
(for instance, <code>edit_photo_path(10)</code> returns
<code>/photos/10/edit</code>)</p>
</li><li>
<p><code>photo_path(:id)</code> returns <code>/photos/:id</code> (for
instance, <code>photo_path(10)</code> returns <code>/photos/10</code>)</p>
</li></ul>

<p>Each of these helpers has a corresponding <code>_url</code> helper (such as
<code>photos_url</code>) which returns the same path prefixed with the
current host, port and path prefix.</p>

<h3 id="label-Defining+Multiple+Resources+at+the+Same+Time">Defining Multiple Resources at the Same <a href="../../../../classes/Time.html">Time</a></h3>

<p>If you need to create routes for more than one resource, you can save a bit
of typing by defining them all with a single call to
<code>resources</code>:</p>

<pre><code>resources :photos, :books, :videos
</code></pre>

<p>This works exactly the same as:</p>

<pre><code>resources :photos
resources :books
resources :videos
</code></pre>

<h3 id="label-Singular+Resources">Singular Resources</h3>

<p>Sometimes, you have a resource that clients always look up without
referencing an ID. For example, you would like <code>/profile</code> to
always show the profile of the currently logged in user. In this case, you
can use a singular resource to map <code>/profile</code> (rather than
<code>/profile/:id</code>) to the <code>show</code> action:</p>

<pre><code>get &#39;profile&#39;, to: &#39;users#show&#39;
</code></pre>

<p>This resourceful route:</p>

<pre><code>resource :geocoder
</code></pre>

<p>creates six different routes in your application, all mapping to the
<code>Geocoders</code> controller:</p>

<p>| HTTP Verb | Path | Action | Used for | | ——— | ————– | ——- |
——————————————— | | GET | /geocoder/new | new | return an <a
href="../../../../classes/HTML.html">HTML</a> form for creating the
geocoder | | POST | /geocoder | create | create the new geocoder | | GET |
/geocoder | show | display the one and only geocoder resource | | GET |
/geocoder/edit | edit | return an <a
href="../../../../classes/HTML.html">HTML</a> form for editing the geocoder
| | PATCH/PUT | /geocoder | update | update the one and only geocoder
resource | | DELETE | /geocoder | destroy | delete the geocoder resource |</p>

<p>NOTE: Because you might want to use the same controller for a singular
route (<code>/account</code>) and a plural route
(<code>/accounts/45</code>), singular resources map to plural controllers.</p>

<p><a href="../../../../classes/A.html">A</a> singular resourceful route
generates these helpers:</p>
<ul><li>
<p><code>new_geocoder_path</code> returns <code>/geocoder/new</code></p>
</li><li>
<p><code>edit_geocoder_path</code> returns <code>/geocoder/edit</code></p>
</li><li>
<p><code>geocoder_path</code> returns <code>/geocoder</code></p>
</li></ul>

<p>As with plural resources, the same helpers ending in <code>_url</code> will
also include the host, port and path prefix.</p>

<h3 id="label-Controller+Namespaces+and+Routing">Controller Namespaces and Routing</h3>

<p>You may wish to organize groups of controllers under a namespace. Most
commonly, you might group a number of administrative controllers under an
<code>Admin::</code> namespace. You would place these controllers under the
<code>app/controllers/admin</code> directory, and you can group them
together in your router:</p>

<pre><code>namespace :admin do
  resources :posts, :comments
end
</code></pre>

<p>This will create a number of routes for each of the <code>posts</code> and
<code>comments</code> controller. For <code>Admin::PostsController</code>,
<a href="../../../../classes/Rails.html">Rails</a> will create:</p>

<p>| HTTP Verb | Path | Action | Used for | | ——— | ——————— | ——- | ————————-
| | GET | /admin/posts | index | admin_posts_path | | GET |
/admin/posts/new | new | new_admin_post_path | | POST | /admin/posts |
create | admin_posts_path | | GET | /admin/posts/:id | show |
admin_post_path(:id) | | GET | /admin/posts/:id/edit | edit |
edit_admin_post_path(:id) | | PATCH/PUT | /admin/posts/:id | update |
admin_post_path(:id) | | DELETE | /admin/posts/:id | destroy |
admin_post_path(:id) |</p>

<p>If you want to route <code>/posts</code> (without the prefix
<code>/admin</code>) to <code>Admin::PostsController</code>, you could use:</p>

<pre><code>scope module: &#39;admin&#39; do
  resources :posts, :comments
end
</code></pre>

<p>or, for a single case:</p>

<pre><code>resources :posts, module: &#39;admin&#39;
</code></pre>

<p>If you want to route <code>/admin/posts</code> to
<code>PostsController</code> (without the <code>Admin::</code> module
prefix), you could use:</p>

<pre><code>scope &#39;/admin&#39; do
  resources :posts, :comments
end
</code></pre>

<p>or, for a single case:</p>

<pre><code>resources :posts, path: &#39;/admin/posts&#39;
</code></pre>

<p>In each of these cases, the named routes remain the same as if you did not
use <code>scope</code>. In the last case, the following paths map to
<code>PostsController</code>:</p>

<p>| HTTP Verb | Path | Action | Named Helper | | ——— | ——————— | ——- |
——————- | | GET | /admin/posts | index | posts_path | | GET |
/admin/posts/new | new | new_post_path | | POST | /admin/posts | create |
posts_path | | GET | /admin/posts/:id | show | post_path(:id) | | GET |
/admin/posts/:id/edit | edit | edit_post_path(:id) | | PATCH/PUT |
/admin/posts/:id | update | post_path(:id) | | DELETE | /admin/posts/:id |
destroy | post_path(:id) |</p>

<h3 id="label-Nested+Resources"><a href="../../../../classes/Nested.html">Nested</a> Resources</h3>

<p>It&#39;s common to have resources that are logically children of other
resources. For example, suppose your application includes these models:</p>

<pre><code>class Magazine &lt; ActiveRecord::Base
  has_many :ads
end

class Ad &lt; ActiveRecord::Base
  belongs_to :magazine
end
</code></pre>

<p><a href="../../../../classes/Nested.html">Nested</a> routes allow you to
capture this relationship in your routing. In this case, you could include
this route declaration:</p>

<pre><code>resources :magazines do
  resources :ads
end
</code></pre>

<p>In addition to the routes for magazines, this declaration will also route
ads to an <code>AdsController</code>. The ad URLs require a magazine:</p>

<p>| HTTP Verb | Path | Action | Used for | | ——— | ———————————— | ——- |
————————————————————————– | | GET | /magazines/:magazine_id/ads | index |
display a list of all ads for a specific magazine | | GET |
/magazines/:magazine_id/ads/new | new | return an <a
href="../../../../classes/HTML.html">HTML</a> form for creating a new ad
belonging to a specific magazine | | POST | /magazines/:magazine_id/ads |
create | create a new ad belonging to a specific magazine | | GET |
/magazines/:magazine_id/ads/:id | show | display a specific ad belonging to
a specific magazine | | GET | /magazines/:magazine_id/ads/:id/edit | edit |
return an <a href="../../../../classes/HTML.html">HTML</a> form for editing
an ad belonging to a specific magazine | | PATCH/PUT |
/magazines/:magazine_id/ads/:id | update | update a specific ad belonging
to a specific magazine | | DELETE | /magazines/:magazine_id/ads/:id |
destroy | delete a specific ad belonging to a specific magazine |</p>

<p>This will also create routing helpers such as <code>magazine_ads_url</code>
and <code>edit_magazine_ad_path</code>. These helpers take an instance of
Magazine as the first parameter (<code>magazine_ads_url(@magazine)</code>).</p>

<h4 id="label-Limits+to+Nesting">Limits to Nesting</h4>

<p>You can nest resources within other nested resources if you like. For
example:</p>

<pre><code>resources :publishers do
  resources :magazines do
    resources :photos
  end
end
</code></pre>

<p>Deeply-nested resources quickly become cumbersome. In this case, for
example, the application would recognize paths such as:</p>

<pre><code>/publishers/1/magazines/2/photos/3</code></pre>

<p>The corresponding route helper would be
<code>publisher_magazine_photo_url</code>, requiring you to specify objects
at all three levels. Indeed, this situation is confusing enough that a
popular <a
href="http://weblog.jamisbuck.org/2007/2/5/nesting-resources">article</a>
by Jamis Buck proposes a rule of thumb for good <a
href="../../../../classes/Rails.html">Rails</a> design:</p>

<p>TIP: <em>Resources should never be nested more than 1 level deep.</em></p>

<h4 id="label-Shallow+Nesting">Shallow Nesting</h4>

<p><a href="../../../../classes/One.html">One</a> way to avoid deep nesting
(as recommended above) is to generate the collection actions scoped under
the parent, so as to get a sense of the hierarchy, but to not nest the
member actions. In other words, to only build routes with the minimal
amount of information to uniquely identify the resource, like this:</p>

<pre><code>resources :posts do
  resources :comments, only: [:index, :new, :create]
end
resources :comments, only: [:show, :edit, :update, :destroy]
</code></pre>

<p>This idea strikes a balance between descriptive routes and deep nesting.
There exists shorthand syntax to achieve just that, via the
<code>:shallow</code> option:</p>

<pre><code>resources :posts do
  resources :comments, shallow: true
end
</code></pre>

<p>This will generate the exact same routes as the first example. You can also
specify the <code>:shallow</code> option in the parent resource, in which
case all of the nested resources will be shallow:</p>

<pre><code>resources :posts, shallow: true do
  resources :comments
  resources :quotes
  resources :drafts
end
</code></pre>

<p>The <code>shallow</code> method of the DSL creates a scope inside of which
every nesting is shallow. This generates the same routes as the previous
example:</p>

<pre><code>shallow do
  resources :posts do
    resources :comments
    resources :quotes
    resources :drafts
  end
end
</code></pre>

<p>There exists two options for <code>scope</code> to customize shallow
routes. <code>:shallow_path</code> prefixes member paths with the specified
parameter:</p>

<pre><code>scope shallow_path: &quot;sekret&quot; do
  resources :posts do
    resources :comments, shallow: true
  end
end
</code></pre>

<p>The comments resource here will have the following routes generated for it:</p>

<p>| HTTP Verb | Path | Named Helper | | ——— | ————————————– | ——————- | | GET
| /posts/:post_id/comments(.:format) | post_comments | | POST |
/posts/:post_id/comments(.:format) | post_comments | | GET |
/posts/:post_id/comments/new(.:format) | new_post_comment | | GET |
/sekret/comments/:id/edit(.:format) | edit_comment | | GET |
/sekret/comments/:id(.:format) | comment | | PATCH/PUT |
/sekret/comments/:id(.:format) | comment | | DELETE |
/sekret/comments/:id(.:format) | comment |</p>

<p>The <code>:shallow_prefix</code> option adds the specified parameter to the
named helpers:</p>

<pre><code>scope shallow_prefix: &quot;sekret&quot; do
  resources :posts do
    resources :comments, shallow: true
  end
end
</code></pre>

<p>The comments resource here will have the following routes generated for it:</p>

<p>| HTTP Verb | Path | Named Helper | | ——— | ————————————– | ——————- | | GET
| /posts/:post_id/comments(.:format) | post_comments | | POST |
/posts/:post_id/comments(.:format) | post_comments | | GET |
/posts/:post_id/comments/new(.:format) | new_post_comment | | GET |
/comments/:id/edit(.:format) | edit_sekret_comment | | GET |
/comments/:id(.:format) | sekret_comment | | PATCH/PUT |
/comments/:id(.:format) | sekret_comment | | DELETE |
/comments/:id(.:format) | sekret_comment |</p>

<h3 id="label-Routing+concerns">Routing concerns</h3>

<p>Routing Concerns allows you to declare common routes that can be reused
inside others resources and routes. To define a concern:</p>

<pre><code>concern :commentable do
  resources :comments
end

concern :image_attachable do
  resources :images, only: :index
end
</code></pre>

<p>These concerns can be used in resources to avoid code duplication and share
behavior across routes:</p>

<pre><code>resources :messages, concerns: :commentable

resources :posts, concerns: [:commentable, :image_attachable]
</code></pre>

<p>The above is equivalent to:</p>

<pre><code>resources :messages do
  resources :comments
end

resources :posts do
  resources :comments
  resources :images, only: :index
end
</code></pre>

<p>Also you can use them in any place that you want inside the routes, for
example in a scope or namespace call:</p>

<pre><code>namespace :posts do
  concerns :commentable
end
</code></pre>

<h3 id="label-Creating+Paths+and+URLs+From+Objects">Creating Paths and URLs From Objects</h3>

<p>In addition to using the routing helpers, <a
href="../../../../classes/Rails.html">Rails</a> can also create paths and
URLs from an array of parameters. For example, suppose you have this set of
routes:</p>

<pre><code>resources :magazines do
  resources :ads
end
</code></pre>

<p>When using <code>magazine_ad_path</code>, you can pass in instances of
<code>Magazine</code> and <code>Ad</code> instead of the numeric IDs:</p>

<pre><code>&lt;%= link_to &#39;Ad details&#39;, magazine_ad_path(@magazine, @ad) %&gt;</code></pre>

<p>You can also use <code>url_for</code> with a set of objects, and <a
href="../../../../classes/Rails.html">Rails</a> will automatically
determine which route you want:</p>

<pre><code>&lt;%= link_to &#39;Ad details&#39;, url_for([@magazine, @ad]) %&gt;</code></pre>

<p>In this case, <a href="../../../../classes/Rails.html">Rails</a> will see
that <code>@magazine</code> is a <code>Magazine</code> and <code>@ad</code>
is an <code>Ad</code> and will therefore use the
<code>magazine_ad_path</code> helper. In helpers like <code>link_to</code>,
you can specify just the object in place of the full <code>url_for</code>
call:</p>

<pre><code>&lt;%= link_to &#39;Ad details&#39;, [@magazine, @ad] %&gt;</code></pre>

<p>If you wanted to link to just a magazine:</p>

<pre><code>&lt;%= link_to &#39;Magazine details&#39;, @magazine %&gt;</code></pre>

<p>For other actions, you just need to insert the action name as the first
element of the array:</p>

<pre><code>&lt;%= link_to &#39;Edit Ad&#39;, [:edit, @magazine, @ad] %&gt;</code></pre>

<p>This allows you to treat instances of your models as URLs, and is a key
advantage to using the resourceful style.</p>

<h3 id="label-Adding+More+RESTful+Actions">Adding More RESTful Actions</h3>

<p>You are not limited to the seven routes that RESTful routing creates by
default. If you like, you may add additional routes that apply to the
collection or individual members of the collection.</p>

<h4 id="label-Adding+Member+Routes">Adding <a href="../../../../classes/Member.html">Member</a> Routes</h4>

<p>To add a member route, just add a <code>member</code> block into the
resource block:</p>

<pre><code>resources :photos do
  member do
    get &#39;preview&#39;
  end
end
</code></pre>

<p>This will recognize <code>/photos/1/preview</code> with GET, and route to
the <code>preview</code> action of <code>PhotosController</code>, with the
resource id value passed in <code>params[:id]</code>. It will also create
the <code>preview_photo_url</code> and <code>preview_photo_path</code>
helpers.</p>

<p>Within the block of member routes, each route name specifies the HTTP verb
that it will recognize. You can use <code>get</code>, <code>patch</code>,
<code>put</code>, <code>post</code>, or <code>delete</code> here. If you
don&#39;t have multiple <code>member</code> routes, you can also pass
<code>:on</code> to a route, eliminating the block:</p>

<pre><code>resources :photos do
  get &#39;preview&#39;, on: :member
end
</code></pre>

<p>You can leave out the <code>:on</code> option, this will create the same
member route except that the resource id value will be available in
<code>params[:photo_id]</code> instead of <code>params[:id]</code>.</p>

<h4 id="label-Adding+Collection+Routes">Adding Collection Routes</h4>

<p>To add a route to the collection:</p>

<pre><code>resources :photos do
  collection do
    get &#39;search&#39;
  end
end
</code></pre>

<p>This will enable <a href="../../../../classes/Rails.html">Rails</a> to
recognize paths such as <code>/photos/search</code> with GET, and route to
the <code>search</code> action of <code>PhotosController</code>. It will
also create the <code>search_photos_url</code> and
<code>search_photos_path</code> route helpers.</p>

<p>Just as with member routes, you can pass <code>:on</code> to a route:</p>

<pre><code>resources :photos do
  get &#39;search&#39;, on: :collection
end
</code></pre>

<h4 id="label-Adding+Routes+for+Additional+New+Actions">Adding Routes for Additional New Actions</h4>

<p>To add an alternate new action using the <code>:on</code> shortcut:</p>

<pre><code>resources :comments do
  get &#39;preview&#39;, on: :new
end
</code></pre>

<p>This will enable <a href="../../../../classes/Rails.html">Rails</a> to
recognize paths such as <code>/comments/new/preview</code> with GET, and
route to the <code>preview</code> action of
<code>CommentsController</code>. It will also create the
<code>preview_new_comment_url</code> and
<code>preview_new_comment_path</code> route helpers.</p>

<p>TIP: If you find yourself adding many extra actions to a resourceful route,
it&#39;s time to stop and ask yourself whether you&#39;re disguising the
presence of another resource.</p>

<h2 id="label-Non-Resourceful+Routes">Non-Resourceful Routes</h2>

<p>In addition to resource routing, <a
href="../../../../classes/Rails.html">Rails</a> has powerful support for
routing arbitrary URLs to actions. Here, you don&#39;t get groups of routes
automatically generated by resourceful routing. Instead, you set up each
route within your application separately.</p>

<p>While you should usually use resourceful routing, there are still many
places where the simpler routing is more appropriate. There&#39;s no need
to try to shoehorn every last piece of your application into a resourceful
framework if that&#39;s not a good fit.</p>

<p>In particular, simple routing makes it very easy to map legacy URLs to new
<a href="../../../../classes/Rails.html">Rails</a> actions.</p>

<h3 id="label-Bound+Parameters">Bound Parameters</h3>

<p>When you set up a regular route, you supply a series of symbols that <a
href="../../../../classes/Rails.html">Rails</a> maps to parts of an
incoming HTTP request. Two of these symbols are special:
<code>:controller</code> maps to the name of a controller in your
application, and <code>:action</code> maps to the name of an action within
that controller. For example, consider one of the default <a
href="../../../../classes/Rails.html">Rails</a> routes:</p>

<pre><code>get &#39;:controller(/:action(/:id))&#39;
</code></pre>

<p>If an incoming request of <code>/photos/show/1</code> is processed by this
route (because it hasn&#39;t matched any previous route in the file), then
the result will be to invoke the <code>show</code> action of the
<code>PhotosController</code>, and to make the final parameter
<code>&quot;1&quot;</code> available as <code>params[:id]</code>. This
route will also route the incoming request of <code>/photos</code> to
<code>PhotosController#index</code>, since <code>:action</code> and
<code>:id</code> are optional parameters, denoted by parentheses.</p>

<h3 id="label-Dynamic+Segments">Dynamic Segments</h3>

<p>You can set up as many dynamic segments within a regular route as you like.
Anything other than <code>:controller</code> or <code>:action</code> will
be available to the action as part of <code>params</code>. If you set up
this route:</p>

<pre><code>get &#39;:controller/:action/:id/:user_id&#39;
</code></pre>

<p>An incoming path of <code>/photos/show/1/2</code> will be dispatched to the
<code>show</code> action of the <code>PhotosController</code>.
<code>params[:id]</code> will be <code>&quot;1&quot;</code>, and
<code>params[:user_id]</code> will be <code>&quot;2&quot;</code>.</p>

<p>NOTE: You can&#39;t use <code>:namespace</code> or <code>:module</code>
with a <code>:controller</code> path segment. If you need to do this then
use a constraint on :controller that matches the namespace you require.
e.g:</p>

<pre><code>get &#39;:controller(/:action(/:id))&#39;, controller: /admin\/[^\/]+/
</code></pre>

<p>TIP: By default, dynamic segments don&#39;t accept dots - this is because
the dot is used as a separator for formatted routes. If you need to use a
dot within a dynamic segment, add a constraint that overrides this – for
example, <code>id: /[^\/]+/</code> allows anything except a slash.</p>

<h3 id="label-Static+Segments">Static Segments</h3>

<p>You can specify static segments when creating a route by not prepending a
colon to a fragment:</p>

<pre><code>get &#39;:controller/:action/:id/with_user/:user_id&#39;
</code></pre>

<p>This route would respond to paths such as
<code>/photos/show/1/with_user/2</code>. In this case, <code>params</code>
would be <code>{ controller: &#39;photos&#39;, action: &#39;show&#39;, id:
&#39;1&#39;, user_id: &#39;2&#39; }</code>.</p>

<h3 id="label-The+Query+String">The Query <a href="../../../../classes/String.html">String</a></h3>

<p>The <code>params</code> will also include any parameters from the query
string. For example, with this route:</p>

<pre><code>get &#39;:controller/:action/:id&#39;
</code></pre>

<p>An incoming path of <code>/photos/show/1?user_id=2</code> will be
dispatched to the <code>show</code> action of the <code>Photos</code>
controller. <code>params</code> will be <code>{ controller:
&#39;photos&#39;, action: &#39;show&#39;, id: &#39;1&#39;, user_id:
&#39;2&#39; }</code>.</p>

<h3 id="label-Defining+Defaults">Defining Defaults</h3>

<p>You do not need to explicitly use the <code>:controller</code> and
<code>:action</code> symbols within a route. You can supply them as
defaults:</p>

<pre><code>get &#39;photos/:id&#39;, to: &#39;photos#show&#39;
</code></pre>

<p>With this route, <a href="../../../../classes/Rails.html">Rails</a> will
match an incoming path of <code>/photos/12</code> to the <code>show</code>
action of <code>PhotosController</code>.</p>

<p>You can also define other defaults in a route by supplying a hash for the
<code>:defaults</code> option. This even applies to parameters that you do
not specify as dynamic segments. For example:</p>

<pre><code>get &#39;photos/:id&#39;, to: &#39;photos#show&#39;, defaults: { format: &#39;jpg&#39; }
</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> would match
<code>photos/12</code> to the <code>show</code> action of
<code>PhotosController</code>, and set <code>params[:format]</code> to
<code>&quot;jpg&quot;</code>.</p>

<h3 id="label-Naming+Routes">Naming Routes</h3>

<p>You can specify a name for any route using the <code>:as</code> option:</p>

<pre><code>get &#39;exit&#39;, to: &#39;sessions#destroy&#39;, as: :logout
</code></pre>

<p>This will create <code>logout_path</code> and <code>logout_url</code> as
named helpers in your application. Calling <code>logout_path</code> will
return <code>/exit</code></p>

<p>You can also use this to override routing methods defined by resources,
like this:</p>

<pre><code>get &#39;:username&#39;, to: &#39;users#show&#39;, as: :user
</code></pre>

<p>This will define a <code>user_path</code> method that will be available in
controllers, helpers and views that will go to a route such as
<code>/bob</code>. Inside the <code>show</code> action of
<code>UsersController</code>, <code>params[:username]</code> will contain
the username for the user. Change <code>:username</code> in the route
definition if you do not want your parameter name to be
<code>:username</code>.</p>

<h3 id="label-HTTP+Verb+Constraints">HTTP Verb Constraints</h3>

<p>In general, you should use the <code>get</code>, <code>post</code>,
<code>put</code> and <code>delete</code> methods to constrain a route to a
particular verb. You can use the <code>match</code> method with the
<code>:via</code> option to match multiple verbs at once:</p>

<pre><code>match &#39;photos&#39;, to: &#39;photos#show&#39;, via: [:get, :post]
</code></pre>

<p>You can match all verbs to a particular route using <code>via: :all</code>:</p>

<pre><code>match &#39;photos&#39;, to: &#39;photos#show&#39;, via: :all
</code></pre>

<p>NOTE: Routing both <code>GET</code> and <code>POST</code> requests to a
single action has security implications. In general, you should avoid
routing all verbs to an action unless you have a good reason to.</p>

<h3 id="label-Segment+Constraints">Segment Constraints</h3>

<p>You can use the <code>:constraints</code> option to enforce a format for a
dynamic segment:</p>

<pre><code>get &#39;photos/:id&#39;, to: &#39;photos#show&#39;, constraints: { id: /[A-Z]\d{5}/ }
</code></pre>

<p>This route would match paths such as <code>/photos/A12345</code>, but not
<code>/photos/893</code>. You can more succinctly express the same route
this way:</p>

<pre><code>get &#39;photos/:id&#39;, to: &#39;photos#show&#39;, id: /[A-Z]\d{5}/
</code></pre>

<p><code>:constraints</code> takes regular expressions with the restriction
that regexp anchors can&#39;t be used. For example, the following route
will not work:</p>

<pre><code>get &#39;/:id&#39;, to: &#39;posts#show&#39;, constraints: {id: /^\d/}
</code></pre>

<p>However, note that you don&#39;t need to use anchors because all routes are
anchored at the start.</p>

<p>For example, the following routes would allow for <code>posts</code> with
<code>to_param</code> values like <code>1-hello-world</code> that always
begin with a number and <code>users</code> with <code>to_param</code>
values like <code>david</code> that never begin with a number to share the
root namespace:</p>

<pre><code>get &#39;/:id&#39;, to: &#39;posts#show&#39;, constraints: { id: /\d.+/ }
get &#39;/:username&#39;, to: &#39;users#show&#39;
</code></pre>

<h3 id="label-Request-Based+Constraints">Request-Based Constraints</h3>

<p>You can also constrain a route based on any method on the &lt;a
href=“action_controller_overview.html#the-request-object”&gt;Request&lt;/a&gt;
object that returns a <code>String</code>.</p>

<p>You specify a request-based constraint the same way that you specify a
segment constraint:</p>

<pre><code>get &#39;photos&#39;, constraints: {subdomain: &#39;admin&#39;}
</code></pre>

<p>You can also specify constraints in a block form:</p>

<pre><code>namespace :admin do
  constraints subdomain: &#39;admin&#39; do
    resources :photos
  end
end
</code></pre>

<h3 id="label-Advanced+Constraints">Advanced Constraints</h3>

<p>If you have a more advanced constraint, you can provide an object that
responds to <code>matches?</code> that <a
href="../../../../classes/Rails.html">Rails</a> should use. Let&#39;s say
you wanted to route all users on a blacklist to the
<code>BlacklistController</code>. You could do:</p>

<pre><code>class BlacklistConstraint
  def initialize
    @ips = Blacklist.retrieve_ips
  end

  def matches?(request)
    @ips.include?(request.remote_ip)
  end
end

TwitterClone::Application.routes.draw do
  get &#39;*path&#39;, to: &#39;blacklist#index&#39;,
    constraints: BlacklistConstraint.new
end
</code></pre>

<p>You can also specify constraints as a lambda:</p>

<pre><code>TwitterClone::Application.routes.draw do
  get &#39;*path&#39;, to: &#39;blacklist#index&#39;,
    constraints: lambda { |request| Blacklist.retrieve_ips.include?(request.remote_ip) }
end
</code></pre>

<p>Both the <code>matches?</code> method and the lambda gets the
<code>request</code> object as an argument.</p>

<h3 id="label-Route+Globbing+and+Wildcard+Segments">Route Globbing and Wildcard Segments</h3>

<p>Route globbing is a way to specify that a particular parameter should be
matched to all the remaining parts of a route. For example:</p>

<pre><code>get &#39;photos/*other&#39;, to: &#39;photos#unknown&#39;
</code></pre>

<p>This route would match <code>photos/12</code> or
<code>/photos/long/path/to/12</code>, setting <code>params[:other]</code>
to <code>&quot;12&quot;</code> or <code>&quot;long/path/to/12&quot;</code>.
The fragments prefixed with a star are called “wildcard segments”.</p>

<p>Wildcard segments can occur anywhere in a route. For example:</p>

<pre><code>get &#39;books/*section/:title&#39;, to: &#39;books#show&#39;
</code></pre>

<p>would match <code>books/some/section/last-words-a-memoir</code> with
<code>params[:section]</code> equals <code>&#39;some/section&#39;</code>,
and <code>params[:title]</code> equals
<code>&#39;last-words-a-memoir&#39;</code>.</p>

<p>Technically, a route can have even more than one wildcard segment. The
matcher assigns segments to parameters in an intuitive way. For example:</p>

<pre><code>get &#39;*a/foo/*b&#39;, to: &#39;test#index&#39;
</code></pre>

<p>would match <code>zoo/woo/foo/bar/baz</code> with <code>params[:a]</code>
equals <code>&#39;zoo/woo&#39;</code>, and <code>params[:b]</code> equals
<code>&#39;bar/baz&#39;</code>.</p>

<p>NOTE: By requesting <code>&#39;/foo/bar.json&#39;</code>, your
<code>params[:pages]</code> will be equals to
<code>&#39;foo/bar&#39;</code> with the request format of JSON. If you want
the old 3.0.x behavior back, you could supply <code>format: false</code>
like this:</p>

<pre><code>get &#39;*pages&#39;, to: &#39;pages#show&#39;, format: false
</code></pre>

<p>NOTE: If you want to make the format segment mandatory, so it cannot be
omitted, you can supply <code>format: true</code> like this:</p>

<pre><code>get &#39;*pages&#39;, to: &#39;pages#show&#39;, format: true
</code></pre>

<h3 id="label-Redirection">Redirection</h3>

<p>You can redirect any path to another path using the <code>redirect</code>
helper in your router:</p>

<pre><code>get &#39;/stories&#39;, to: redirect(&#39;/posts&#39;)
</code></pre>

<p>You can also reuse dynamic segments from the match in the path to redirect
to:</p>

<pre><code>get &#39;/stories/:name&#39;, to: redirect(&#39;/posts/%{name}&#39;)
</code></pre>

<p>You can also provide a block to redirect, which receives the params and the
request object:</p>

<pre><code>get &#39;/stories/:name&#39;, to: redirect {|params, req| &quot;/posts/#{params[:name].pluralize}&quot; }
get &#39;/stories&#39;, to: redirect {|p, req| &quot;/posts/#{req.subdomain}&quot; }
</code></pre>

<p>Please note that this redirection is a 301 “Moved Permanently” redirect.
Keep in mind that some web browsers or proxy servers will cache this type
of redirect, making the old page inaccessible.</p>

<p>In all of these cases, if you don&#39;t provide the leading host
(<code>http://www.example.com</code>), <a
href="../../../../classes/Rails.html">Rails</a> will take those details
from the current request.</p>

<h3 id="label-Routing+to+Rack+Applications">Routing to <a href="../../../../classes/Rack.html">Rack</a> Applications</h3>

<p>Instead of a <a href="../../../../classes/String.html">String</a> like
<code>&#39;posts#index&#39;</code>, which corresponds to the
<code>index</code> action in the <code>PostsController</code>, you can
specify any &lt;a href=“rails_on_rack.html”&gt;Rack application&lt;/a&gt;
as the endpoint for a matcher:</p>

<pre><code>match &#39;/application.js&#39;, to: Sprockets, via: :all
</code></pre>

<p>As long as <code>Sprockets</code> responds to <code>call</code> and returns
a <code>[status, headers, body]</code>, the router won&#39;t know the
difference between the <a href="../../../../classes/Rack.html">Rack</a>
application and an action. This is an appropriate use of <code>via:
:all</code>, as you will want to allow your <a
href="../../../../classes/Rack.html">Rack</a> application to handle all
verbs as it considers appropriate.</p>

<p>NOTE: For the curious, <code>&#39;posts#index&#39;</code> actually expands
out to <code>PostsController.action(:index)</code>, which returns a valid
<a href="../../../../classes/Rack.html">Rack</a> application.</p>

<h3 id="label-Using+root">Using <code>root</code></h3>

<p>You can specify what <a href="../../../../classes/Rails.html">Rails</a>
should route <code>&#39;/&#39;</code> to with the <code>root</code> method:</p>

<pre><code>root to: &#39;pages#main&#39;
root &#39;pages#main&#39; # shortcut for the above
</code></pre>

<p>You should put the <code>root</code> route at the top of the file, because
it is the most popular route and should be matched first.</p>

<p>NOTE: The <code>root</code> route only routes <code>GET</code> requests to
the action.</p>

<h3 id="label-Unicode+character+routes">Unicode character routes</h3>

<p>You can specify unicode character routes directly. For example:</p>

<pre><code>get &#39;こんにちは&#39;, to: &#39;welcome#index&#39;
</code></pre>

<h2 id="label-Customizing+Resourceful+Routes">Customizing Resourceful Routes</h2>

<p>While the default routes and helpers generated by <code>resources
:posts</code> will usually serve you well, you may want to customize them
in some way. <a href="../../../../classes/Rails.html">Rails</a> allows you
to customize virtually any generic part of the resourceful helpers.</p>

<h3 id="label-Specifying+a+Controller+to+Use">Specifying a Controller to Use</h3>

<p>The <code>:controller</code> option lets you explicitly specify a
controller to use for the resource. For example:</p>

<pre><code>resources :photos, controller: &#39;images&#39;
</code></pre>

<p>will recognize incoming paths beginning with <code>/photos</code> but route
to the <code>Images</code> controller:</p>

<p>| HTTP Verb | Path | Action | Named Helper | | ——— | —————- | ——- | ——————–
| | GET | /photos | index | photos_path | | GET | /photos/new | new |
new_photo_path | | POST | /photos | create | photos_path | | GET |
/photos/:id | show | photo_path(:id) | | GET | /photos/:id/edit | edit |
edit_photo_path(:id) | | PATCH/PUT | /photos/:id | update | photo_path(:id)
| | DELETE | /photos/:id | destroy | photo_path(:id) |</p>

<p>NOTE: Use <code>photos_path</code>, <code>new_photo_path</code>, etc. to
generate paths for this resource.</p>

<p>For namespaced controllers you can use the directory notation. For example:</p>

<pre><code>resources :user_permissions, controller: &#39;admin/user_permissions&#39;
</code></pre>

<p>This will route to the <code>Admin::UserPermissions</code> controller.</p>

<p>NOTE: Only the directory notation is supported. specifying the controller
with ruby constant notation (eg. <code>:controller =&gt;
&#39;Admin::UserPermissions&#39;</code>) can lead to routing problems and
results in a warning.</p>

<h3 id="label-Specifying+Constraints">Specifying Constraints</h3>

<p>You can use the <code>:constraints</code> option to specify a required
format on the implicit <code>id</code>. For example:</p>

<pre><code>resources :photos, constraints: {id: /[A-Z][A-Z][0-9]+/}
</code></pre>

<p>This declaration constrains the <code>:id</code> parameter to match the
supplied regular expression. So, in this case, the router would no longer
match <code>/photos/1</code> to this route. Instead,
<code>/photos/RR27</code> would match.</p>

<p>You can specify a single constraint to apply to a number of routes by using
the block form:</p>

<pre><code>constraints(id: /[A-Z][A-Z][0-9]+/) do
  resources :photos
  resources :accounts
end
</code></pre>

<p>NOTE: Of course, you can use the more advanced constraints available in
non-resourceful routes in this context.</p>

<p>TIP: By default the <code>:id</code> parameter doesn&#39;t accept dots -
this is because the dot is used as a separator for formatted routes. If you
need to use a dot within an <code>:id</code> add a constraint which
overrides this - for example <code>id: /[^\/]+/</code> allows anything
except a slash.</p>

<h3 id="label-Overriding+the+Named+Helpers">Overriding the Named Helpers</h3>

<p>The <code>:as</code> option lets you override the normal naming for the
named route helpers. For example:</p>

<pre><code>resources :photos, as: &#39;images&#39;
</code></pre>

<p>will recognize incoming paths beginning with <code>/photos</code> and route
the requests to <code>PhotosController</code>, but use the value of the :as
option to name the helpers.</p>

<p>| HTTP Verb | Path | Action | Named Helper | | ——— | —————- | ——- | ——————–
| | GET | /photos | index | images_path | | GET | /photos/new | new |
new_image_path | | POST | /photos | create | images_path | | GET |
/photos/:id | show | image_path(:id) | | GET | /photos/:id/edit | edit |
edit_image_path(:id) | | PATCH/PUT | /photos/:id | update | image_path(:id)
| | DELETE | /photos/:id | destroy | image_path(:id) |</p>

<h3 id="label-Overriding+the+new+and+edit+Segments">Overriding the <code>new</code> and <code>edit</code> Segments</h3>

<p>The <code>:path_names</code> option lets you override the
automatically-generated “new” and “edit” segments in paths:</p>

<pre><code>resources :photos, path_names: { new: &#39;make&#39;, edit: &#39;change&#39; }
</code></pre>

<p>This would cause the routing to recognize paths such as:</p>

<pre><code>/photos/make
/photos/1/change</code></pre>

<p>NOTE: The actual action names aren&#39;t changed by this option. The two
paths shown would still route to the <code>new</code> and <code>edit</code>
actions.</p>

<p>TIP: If you find yourself wanting to change this option uniformly for all
of your routes, you can use a scope.</p>

<pre><code>scope path_names: { new: &#39;make&#39; } do
  # rest of your routes
end
</code></pre>

<h3 id="label-Prefixing+the+Named+Route+Helpers">Prefixing the Named Route Helpers</h3>

<p>You can use the <code>:as</code> option to prefix the named route helpers
that <a href="../../../../classes/Rails.html">Rails</a> generates for a
route. Use this option to prevent name collisions between routes using a
path scope. For example:</p>

<pre><code>scope &#39;admin&#39; do
  resources :photos, as: &#39;admin_photos&#39;
end

resources :photos
</code></pre>

<p>This will provide route helpers such as <code>admin_photos_path</code>,
<code>new_admin_photo_path</code> etc.</p>

<p>To prefix a group of route helpers, use <code>:as</code> with
<code>scope</code>:</p>

<pre><code>scope &#39;admin&#39;, as: &#39;admin&#39; do
  resources :photos, :accounts
end

resources :photos, :accounts
</code></pre>

<p>This will generate routes such as <code>admin_photos_path</code> and
<code>admin_accounts_path</code> which map to <code>/admin/photos</code>
and <code>/admin/accounts</code> respectively.</p>

<p>NOTE: The <code>namespace</code> scope will automatically add
<code>:as</code> as well as <code>:module</code> and <code>:path</code>
prefixes.</p>

<p>You can prefix routes with a named parameter also:</p>

<pre><code>scope &#39;:username&#39; do
  resources :posts
end
</code></pre>

<p>This will provide you with URLs such as <code>/bob/posts/1</code> and will
allow you to reference the <code>username</code> part of the path as
<code>params[:username]</code> in controllers, helpers and views.</p>

<h3 id="label-Restricting+the+Routes+Created">Restricting the Routes Created</h3>

<p>By default, <a href="../../../../classes/Rails.html">Rails</a> creates
routes for the seven default actions (index, show, new, create, edit,
update, and destroy) for every RESTful route in your application. You can
use the <code>:only</code> and <code>:except</code> options to fine-tune
this behavior. The <code>:only</code> option tells <a
href="../../../../classes/Rails.html">Rails</a> to create only the
specified routes:</p>

<pre><code>resources :photos, only: [:index, :show]
</code></pre>

<p>Now, a <code>GET</code> request to <code>/photos</code> would succeed, but
a <code>POST</code> request to <code>/photos</code> (which would ordinarily
be routed to the <code>create</code> action) will fail.</p>

<p>The <code>:except</code> option specifies a route or list of routes that <a
href="../../../../classes/Rails.html">Rails</a> should <em>not</em> create:</p>

<pre><code>resources :photos, except: :destroy
</code></pre>

<p>In this case, <a href="../../../../classes/Rails.html">Rails</a> will
create all of the normal routes except the route for <code>destroy</code>
(a <code>DELETE</code> request to <code>/photos/:id</code>).</p>

<p>TIP: If your application has many RESTful routes, using <code>:only</code>
and <code>:except</code> to generate only the routes that you actually need
can cut down on memory use and speed up the routing process.</p>

<h3 id="label-Translated+Paths">Translated Paths</h3>

<p>Using <code>scope</code>, we can alter path names generated by resources:</p>

<pre><code>scope(path_names: { new: &#39;neu&#39;, edit: &#39;bearbeiten&#39; }) do
  resources :categories, path: &#39;kategorien&#39;
end
</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> now creates routes to
the <code>CategoriesController</code>.</p>

<p>| HTTP Verb | Path | Action | Used for | | ——— | ————————– | ——- | ———————–
| | GET | /kategorien | index | categories_path | | GET | /kategorien/neu |
new | new_category_path | | POST | /kategorien | create | categories_path |
| GET | /kategorien/:id | show | category_path(:id) | | GET |
/kategorien/:id/bearbeiten | edit | edit_category_path(:id) | | PATCH/PUT |
/kategorien/:id | update | category_path(:id) | | DELETE | /kategorien/:id
| destroy | category_path(:id) |</p>

<h3 id="label-Overriding+the+Singular+Form">Overriding the Singular Form</h3>

<p>If you want to define the singular form of a resource, you should add
additional rules to the <code>Inflector</code>:</p>

<pre><code>ActiveSupport::Inflector.inflections do |inflect|
  inflect.irregular &#39;tooth&#39;, &#39;teeth&#39;
end
</code></pre>

<h3 id="label-Using+%3Aas+in+Nested+Resources">Using <code>:as</code> in <a href="../../../../classes/Nested.html">Nested</a> Resources</h3>

<p>The <code>:as</code> option overrides the automatically-generated name for
the resource in nested route helpers. For example:</p>

<pre><code>resources :magazines do
  resources :ads, as: &#39;periodical_ads&#39;
end
</code></pre>

<p>This will create routing helpers such as
<code>magazine_periodical_ads_url</code> and
<code>edit_magazine_periodical_ad_path</code>.</p>

<h2 id="label-Inspecting+and+Testing+Routes">Inspecting and Testing Routes</h2>

<p><a href="../../../../classes/Rails.html">Rails</a> offers facilities for
inspecting and testing your routes.</p>

<h3 id="label-Listing+Existing+Routes">Listing Existing Routes</h3>

<p>To get a complete list of the available routes in your application, visit
<code>http://localhost:3000/rails/info/routes</code> in your browser while
your server is running in the <strong>development</strong> environment. You
can also execute the <code>rake routes</code> command in your terminal to
produce the same output.</p>

<p>Both methods will list all of your routes, in the same order that they
appear in <code>routes.rb</code>. For each route, you&#39;ll see:</p>
<ul><li>
<p>The route name (if any)</p>
</li><li>
<p>The HTTP verb used (if the route doesn&#39;t respond to all verbs)</p>
</li><li>
<p>The URL pattern to match</p>
</li><li>
<p>The routing parameters for the route</p>
</li></ul>

<p>For example, here&#39;s a small section of the <code>rake routes</code>
output for a RESTful route:</p>

<pre><code>users GET    /users(.:format)          users#index
          POST   /users(.:format)          users#create
 new_user GET    /users/new(.:format)      users#new
edit_user GET    /users/:id/edit(.:format) users#edit</code></pre>

<p>You may restrict the listing to the routes that map to a particular
controller setting the <code>CONTROLLER</code> environment variable:</p>

<pre><code>$ CONTROLLER=users rake routes</code></pre>

<p>TIP: You&#39;ll find that the output from <code>rake routes</code> is much
more readable if you widen your terminal window until the output lines
don&#39;t wrap.</p>

<h3 id="label-Testing+Routes">Testing Routes</h3>

<p>Routes should be included in your testing strategy (just like the rest of
your application). <a href="../../../../classes/Rails.html">Rails</a>
offers three <a
href="http://api.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html">built-in
assertions</a> designed to make testing routes simpler:</p>
<ul><li>
<p><code>assert_generates</code></p>
</li><li>
<p><code>assert_recognizes</code></p>
</li><li>
<p><code>assert_routing</code></p>
</li></ul>

<h4 id="label-The+assert_generates+Assertion">The <code>assert_generates</code> Assertion</h4>

<p><code>assert_generates</code> asserts that a particular set of options
generate a particular path and can be used with default routes or custom
routes. For example:</p>

<pre><code>assert_generates &#39;/photos/1&#39;, { controller: &#39;photos&#39;, action: &#39;show&#39;, id: &#39;1&#39; }
assert_generates &#39;/about&#39;, controller: &#39;pages&#39;, action: &#39;about&#39;
</code></pre>

<h4 id="label-The+assert_recognizes+Assertion">The <code>assert_recognizes</code> Assertion</h4>

<p><code>assert_recognizes</code> is the inverse of
<code>assert_generates</code>. It asserts that a given path is recognized
and routes it to a particular spot in your application. For example:</p>

<pre><code>assert_recognizes({ controller: &#39;photos&#39;, action: &#39;show&#39;, id: &#39;1&#39; }, &#39;/photos/1&#39;)
</code></pre>

<p>You can supply a <code>:method</code> argument to specify the HTTP verb:</p>

<pre><code>assert_recognizes({ controller: &#39;photos&#39;, action: &#39;create&#39; }, { path: &#39;photos&#39;, method: :post })
</code></pre>

<h4 id="label-The+assert_routing+Assertion">The <code>assert_routing</code> Assertion</h4>

<p>The <code>assert_routing</code> assertion checks the route both ways: it
tests that the path generates the options, and that the options generate
the path. Thus, it combines the functions of <code>assert_generates</code>
and <code>assert_recognizes</code>:</p>

<pre><code>assert_routing({ path: &#39;photos&#39;, method: :post }, { controller: &#39;photos&#39;, action: &#39;create&#39; })
</code></pre>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>