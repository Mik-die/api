<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>active_support_instrumentation.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            active_support_instrumentation.md
        </h1>
        <ul class="files">
            <li>rails/guides/source/active_support_instrumentation.md</li>
            <li>Last modified: 2013-04-26 19:51:18 +0300</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-Active+Support+Instrumentation">Active Support Instrumentation</h1>

<p>Active Support is a part of core <a
href="../../../../classes/Rails.html">Rails</a> that provides Ruby language
extensions, utilities and other things. <a
href="../../../../classes/One.html">One</a> of the things it includes is an
instrumentation API that can be used inside an application to measure
certain actions that occur within Ruby code, such as that inside a <a
href="../../../../classes/Rails.html">Rails</a> application or the
framework itself. It is not limited to <a
href="../../../../classes/Rails.html">Rails</a>, however. It can be used
independently in other Ruby scripts if it is so desired.</p>

<p>In this guide, you will learn how to use the instrumentation API inside of
Active Support to measure events inside of <a
href="../../../../classes/Rails.html">Rails</a> and other Ruby code.</p>

<p>After reading this guide, you will know:</p>
<ul><li>
<p>What instrumentation can provide.</p>
</li><li>
<p>The hooks inside the <a href="../../../../classes/Rails.html">Rails</a>
framework for instrumentation.</p>
</li><li>
<p>Adding a subscriber to a hook.</p>
</li><li>
<p>Building a custom instrumentation implementation.</p>
</li></ul>
<hr style="height: 1px">

<h2 id="label-Introduction+to+instrumentation">Introduction to instrumentation</h2>

<p>The instrumentation API provided by Active Support allows developers to
provide hooks which other developers may hook into. There are several of
these within the <a href="../../../../classes/Rails.html">Rails</a>
framework, as described below in &lt;TODO: link to section detailing each
hook point&gt;. With this API, developers can choose to be notified when
certain events occur inside their application or another piece of Ruby
code.</p>

<p>For example, there is a hook provided within Active Record that is called
every time Active Record uses an SQL query on a database. This hook could
be <strong>subscribed</strong> to, and used to track the number of queries
during a certain action. There&#39;s another hook around the processing of
an action of a controller. This could be used, for instance, to track how
long a specific action has taken.</p>

<p>You are even able to create your own events inside your application which
you can later subscribe to.</p>

<h2 id="label-Rails+framework+hooks"><a href="../../../../classes/Rails.html">Rails</a> framework hooks</h2>

<p>Within the Ruby on <a href="../../../../classes/Rails.html">Rails</a>
framework, there are a number of hooks provided for common events. These
are detailed below.</p>

<h2 id="label-Action+Controller">Action Controller</h2>

<h3 id="label-write_fragment.action_controller">write_fragment.action_controller</h3>

<p>| Key | Value | | —— | —————- | | <code>:key</code> | The complete key |</p>

<pre><code>{
  key: &#39;posts/1-dasboard-view&#39;
}
</code></pre>

<h3 id="label-read_fragment.action_controller">read_fragment.action_controller</h3>

<p>| Key | Value | | —— | —————- | | <code>:key</code> | The complete key |</p>

<pre><code>{
  key: &#39;posts/1-dasboard-view&#39;
}
</code></pre>

<h3 id="label-expire_fragment.action_controller">expire_fragment.action_controller</h3>

<p>| Key | Value | | —— | —————- | | <code>:key</code> | The complete key |</p>

<pre><code>{
  key: &#39;posts/1-dasboard-view&#39;
}
</code></pre>

<h3 id="label-exist_fragment%3F.action_controller">exist_fragment?.action_controller</h3>

<p>| Key | Value | | —— | —————- | | <code>:key</code> | The complete key |</p>

<pre><code>{
  key: &#39;posts/1-dasboard-view&#39;
}
</code></pre>

<h3 id="label-write_page.action_controller">write_page.action_controller</h3>

<p>| Key | Value | | ——- | —————– | | <code>:path</code> | The complete path |</p>

<pre><code>{
  path: &#39;/users/1&#39;
}
</code></pre>

<h3 id="label-expire_page.action_controller">expire_page.action_controller</h3>

<p>| Key | Value | | ——- | —————– | | <code>:path</code> | The complete path |</p>

<pre><code>{
  path: &#39;/users/1&#39;
}
</code></pre>

<h3 id="label-start_processing.action_controller">start_processing.action_controller</h3>

<p>| Key | Value | | ————- | ——————————————————— | | <code>:controller</code>
| The controller name | | <code>:action</code> | The action | |
<code>:params</code> | <a href="../../../../classes/Hash.html">Hash</a> of
request parameters without any filtered parameter | | <code>:format</code>
| html/js/json/xml etc | | <code>:method</code> | HTTP request verb | |
<code>:path</code> | Request path |</p>

<pre><code>{
  controller: &quot;PostsController&quot;,
  action: &quot;new&quot;,
  params: { &quot;action&quot; =&gt; &quot;new&quot;, &quot;controller&quot; =&gt; &quot;posts&quot; },
  format: :html,
  method: &quot;GET&quot;,
  path: &quot;/posts/new&quot;
}
</code></pre>

<h3 id="label-process_action.action_controller">process_action.action_controller</h3>

<p>| Key | Value | | ————— | ——————————————————— | | <code>:controller</code>
| The controller name | | <code>:action</code> | The action | |
<code>:params</code> | <a href="../../../../classes/Hash.html">Hash</a> of
request parameters without any filtered parameter | | <code>:format</code>
| html/js/json/xml etc | | <code>:method</code> | HTTP request verb | |
<code>:path</code> | Request path | | <code>:view_runtime</code> | Amount
spent in view in ms |</p>

<pre><code>{
  controller: &quot;PostsController&quot;,
  action: &quot;index&quot;,
  params: {&quot;action&quot; =&gt; &quot;index&quot;, &quot;controller&quot; =&gt; &quot;posts&quot;},
  format: :html,
  method: &quot;GET&quot;,
  path: &quot;/posts&quot;,
  status: 200,
  view_runtime: 46.848,
  db_runtime: 0.157
}
</code></pre>

<h3 id="label-send_file.action_controller">send_file.action_controller</h3>

<p>| Key | Value | | ——- | ————————- | | <code>:path</code> | Complete path to
the file |</p>

<p>INFO. Additional keys may be added by the caller.</p>

<h3 id="label-send_data.action_controller">send_data.action_controller</h3>

<p><code>ActionController</code> does not had any specific information to the
payload. All options are passed through to the payload.</p>

<h3 id="label-redirect_to.action_controller">redirect_to.action_controller</h3>

<p>| Key | Value | | ———– | —————— | | <code>:status</code> | HTTP response
code | | <code>:location</code> | URL to redirect to |</p>

<pre><code>{
  status: 302,
  location: &quot;http://localhost:3000/posts/new&quot;
}
</code></pre>

<h3 id="label-halted_callback.action_controller">halted_callback.action_controller</h3>

<p>| Key | Value | | ——— | —————————– | | <code>:filter</code> | Filter that
halted the action |</p>

<pre><code>{
  filter: &quot;:halting_filter&quot;
}
</code></pre>

<h2 id="label-Action+View">Action View</h2>

<h3 id="label-render_template.action_view">render_template.action_view</h3>

<p>| Key | Value | | ————- | ——————— | | <code>:identifier</code> | Full path
to template | | <code>:layout</code> | Applicable layout |</p>

<pre><code>{
  identifier: &quot;/Users/adam/projects/notifications/app/views/posts/index.html.erb&quot;,
  layout: &quot;layouts/application&quot;
}
</code></pre>

<h3 id="label-render_partial.action_view">render_partial.action_view</h3>

<p>| Key | Value | | ————- | ——————— | | <code>:identifier</code> | Full path
to template |</p>

<pre><code>{
  identifier: &quot;/Users/adam/projects/notifications/app/views/posts/_form.html.erb&quot;,
}
</code></pre>

<h2 id="label-Active+Record">Active Record</h2>

<h3 id="label-sql.active_record">sql.active_record</h3>

<p>| Key | Value | | ———— | ——————— | | <code>:sql</code> | SQL statement | |
<code>:name</code> | <a href="../../../../classes/Name.html">Name</a> of
the operation | | <code>:object_id</code> | <code>self.object_id</code> |</p>

<p>INFO. The adapters will add their own data as well.</p>

<pre><code>{
  sql: &quot;SELECT \&quot;posts\&quot;.* FROM \&quot;posts\&quot; &quot;,
  name: &quot;Post Load&quot;,
  connection_id: 70307250813140,
  binds: []
}
</code></pre>

<h3 id="label-identity.active_record">identity.active_record</h3>

<p>| Key | Value | | —————- | —————————————– | | <code>:line</code> | Primary
Key of object in the identity map | | <code>:name</code> | Record&#39;s
class | | <code>:connection_id</code> | <code>self.object_id</code> |</p>

<h2 id="label-Action+Mailer">Action Mailer</h2>

<h3 id="label-receive.action_mailer">receive.action_mailer</h3>

<p>| Key | Value | | ————- | ——————————————– | | <code>:mailer</code> | <a
href="../../../../classes/Name.html">Name</a> of the mailer class | |
<code>:message_id</code> | ID of the message, generated by the Mail gem | |
<code>:subject</code> | <a
href="../../../../classes/Subject.html">Subject</a> of the mail | |
<code>:to</code> | To address(es) of the mail | | <code>:from</code> | From
address of the mail | | <code>:bcc</code> | BCC addresses of the mail | |
<code>:cc</code> | CC addresses of the mail | | <code>:date</code> | <a
href="../../../../classes/Date.html">Date</a> of the mail | |
<code>:mail</code> | The encoded form of the mail |</p>

<pre><code>{
  mailer: &quot;Notification&quot;,
  message_id: &quot;4f5b5491f1774_181b23fc3d4434d38138e5@mba.local.mail&quot;,
  subject: &quot;Rails Guides&quot;,
  to: [&quot;users@rails.com&quot;, &quot;ddh@rails.com&quot;],
  from: [&quot;me@rails.com&quot;],
  date: Sat, 10 Mar 2012 14:18:09 +0100,
  mail: &quot;...&quot; # ommitted for beverity
}
</code></pre>

<h3 id="label-deliver.action_mailer">deliver.action_mailer</h3>

<p>| Key | Value | | ————- | ——————————————– | | <code>:mailer</code> | <a
href="../../../../classes/Name.html">Name</a> of the mailer class | |
<code>:message_id</code> | ID of the message, generated by the Mail gem | |
<code>:subject</code> | <a
href="../../../../classes/Subject.html">Subject</a> of the mail | |
<code>:to</code> | To address(es) of the mail | | <code>:from</code> | From
address of the mail | | <code>:bcc</code> | BCC addresses of the mail | |
<code>:cc</code> | CC addresses of the mail | | <code>:date</code> | <a
href="../../../../classes/Date.html">Date</a> of the mail | |
<code>:mail</code> | The encoded form of the mail |</p>

<pre><code>{
  mailer: &quot;Notification&quot;,
  message_id: &quot;4f5b5491f1774_181b23fc3d4434d38138e5@mba.local.mail&quot;,
  subject: &quot;Rails Guides&quot;,
  to: [&quot;users@rails.com&quot;, &quot;ddh@rails.com&quot;],
  from: [&quot;me@rails.com&quot;],
  date: Sat, 10 Mar 2012 14:18:09 +0100,
  mail: &quot;...&quot; # ommitted for beverity
}
</code></pre>

<h2 id="label-ActiveResource">ActiveResource</h2>

<h3 id="label-request.active_resource">request.active_resource</h3>

<p>| Key | Value | | ————– | ——————– | | <code>:method</code> | HTTP method |
| <code>:request_uri</code> | Complete <a
href="../../../../classes/URI.html">URI</a> | | <code>:result</code> | HTTP
response object |</p>

<h2 id="label-Active+Support">Active Support</h2>

<h3 id="label-cache_read.active_support">cache_read.active_support</h3>

<p>| Key | Value | | —————— | ————————————————- | | <code>:key</code> | Key
used in the store | | <code>:hit</code> | If this read is a hit | |
<code>:super_operation</code> | :fetch is added when a read is used with
<code>#fetch</code> |</p>

<h3 id="label-cache_generate.active_support">cache_generate.active_support</h3>

<p>This event is only used when <code>#fetch</code> is called with a block.</p>

<p>| Key | Value | | —— | ——————— | | <code>:key</code> | Key used in the
store |</p>

<p>INFO. Options passed to fetch will be merged with the payload when writing
to the store</p>

<pre><code>{
  key: &#39;name-of-complicated-computation&#39;
}
</code></pre>

<h3 id="label-cache_fetch_hit.active_support">cache_fetch_hit.active_support</h3>

<p>This event is only used when <code>#fetch</code> is called with a block.</p>

<p>| Key | Value | | —— | ——————— | | <code>:key</code> | Key used in the
store |</p>

<p>INFO. Options passed to fetch will be merged with the payload.</p>

<pre><code>{
  key: &#39;name-of-complicated-computation&#39;
}
</code></pre>

<h3 id="label-cache_write.active_support">cache_write.active_support</h3>

<p>| Key | Value | | —— | ——————— | | <code>:key</code> | Key used in the
store |</p>

<p>INFO. Cache stores my add their own keys</p>

<pre><code>{
  key: &#39;name-of-complicated-computation&#39;
}
</code></pre>

<h3 id="label-cache_delete.active_support">cache_delete.active_support</h3>

<p>| Key | Value | | —— | ——————— | | <code>:key</code> | Key used in the
store |</p>

<pre><code>{
  key: &#39;name-of-complicated-computation&#39;
}
</code></pre>

<h3 id="label-cache_exist%3F.active_support">cache_exist?.active_support</h3>

<p>| Key | Value | | —— | ——————— | | <code>:key</code> | Key used in the
store |</p>

<pre><code>{
  key: &#39;name-of-complicated-computation&#39;
}
</code></pre>

<h2 id="label-Rails"><a href="../../../../classes/Rails.html">Rails</a></h2>

<h3 id="label-deprecation.rails">deprecation.rails</h3>

<p>| Key | Value | | ———— | ——————————- | | <code>:message</code> | The
deprecation warning | | <code>:callstack</code> | Where the deprecation
came from |</p>

<h2 id="label-Subscribing+to+an+event">Subscribing to an event</h2>

<p>Subscribing to an event is easy. Use
<code>ActiveSupport::Notifications.subscribe</code> with a block to listen
to any notification.</p>

<p>The block receives the following arguments:</p>
<ul><li>
<p>The name of the event</p>
</li><li>
<p><a href="../../../../classes/Time.html">Time</a> when it started</p>
</li><li>
<p><a href="../../../../classes/Time.html">Time</a> when it finished</p>
</li><li>
<p>An unique ID for this event</p>
</li><li>
<p>The payload (described in previous sections)</p>
</li></ul>

<pre><code>ActiveSupport::Notifications.subscribe &quot;process_action.action_controller&quot; do |name, started, finished, unique_id, data|
  # your own custom stuff
  Rails.logger.info &quot;#{name} Received!&quot;
end
</code></pre>

<p>Defining all those block arguments each time can be tedious. You can easily
create an <code>ActiveSupport::Notifications::Event</code> from block args
like this:</p>

<pre><code>ActiveSupport::Notifications.subscribe &quot;process_action.action_controller&quot; do |*args|
  event = ActiveSupport::Notifications::Event.new *args

  event.name      # =&gt; &quot;process_action.action_controller&quot;
  event.duration  # =&gt; 10 (in milliseconds)
  event.payload   # =&gt; {:extra=&gt;information}

  Rails.logger.info &quot;#{event} Received!&quot;
end
</code></pre>

<p>Most times you only care about the data itself. Here is a shortuct to just
get the data.</p>

<pre><code>ActiveSupport::Notifications.subscribe &quot;process_action.action_controller&quot; do |*args|
  data = args.extract_options!
  data # { extra: :information }
</code></pre>

<p>You may also subscribe to events matching a regular expresssion. This
enables you to subscribe to multiple events at once. Here&#39;s you could
subscribe to everything from <code>ActionController</code>.</p>

<pre><code>ActiveSupport::Notifications.subscribe /action_controller/ do |*args|
  # inspect all ActionController events
end
</code></pre>

<h2 id="label-Creating+custom+events">Creating custom events</h2>

<p>Adding your own events is easy as well.
<code>ActiveSupport::Notifications</code> will take care of all the heavy
lifting for you. Simply call <code>instrument</code> with a
<code>name</code>, <code>payload</code> and a block. The notification will
be sent after the block returns. <code>ActiveSupport</code> will generate
the start and end times as well as the unique ID. All data passed into the
<code>insturment</code> call will make it into the payload.</p>

<p>Here&#39;s an example:</p>

<pre><code>ActiveSupport::Notifications.instrument &quot;my.custom.event&quot;, this: :data do
  # do your custom stuff here
end
</code></pre>

<p>Now you can listen to this event with:</p>

<pre><code>ActiveSupport::Notifications.subscribe &quot;my.custom.event&quot; do |name, started, finished, unique_id, data|
  puts data.inspect # {:this=&gt;:data}
end
</code></pre>

<p>You should follow <a href="../../../../classes/Rails.html">Rails</a>
conventions when defining your own events. The format is:
<code>event.library</code>. If you application is sending Tweets, you
should create an event named <code>tweet.twitter</code>.</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>