<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>asset_pipeline.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            asset_pipeline.md
        </h1>
        <ul class="files">
            <li>rails/guides/source/asset_pipeline.md</li>
            <li>Last modified: 2013-04-26 19:51:18 +0300</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-The+Asset+Pipeline">The Asset Pipeline</h1>

<p>This guide covers the asset pipeline.</p>

<p>After reading this guide, you will know:</p>

<p>How to understand what the asset pipeline is and what it does.  How to
properly organize your application assets.  How to understand the benefits
of the asset pipeline.  How to add a pre-processor to the pipeline.  How to
package assets with a gem.</p>
<hr style="height: 1px">

<h2 id="label-What+is+the+Asset+Pipeline%3F">What is the Asset Pipeline?</h2>

<p>The asset pipeline provides a framework to concatenate and minify or
compress JavaScript and CSS assets. It also adds the ability to write these
assets in other languages such as CoffeeScript, Sass and <a
href="../../../../classes/ERB.html">ERB</a>.</p>

<p>Making the asset pipeline a core feature of <a
href="../../../../classes/Rails.html">Rails</a> means that all developers
can benefit from the power of having their assets pre-processed, compressed
and minified by one central library, Sprockets. This is part of Rails&#39;
“fast by default” strategy as outlined by DHH in his keynote at RailsConf
2011.</p>

<p>The asset pipeline is enabled by default. It can be disabled in
<code>config/application.rb</code> by putting this line inside the
application class definition:</p>

<pre><code>config.assets.enabled = false
</code></pre>

<p>You can also disable the asset pipeline while creating a new application by
passing the <code>--skip-sprockets</code> option.</p>

<pre><code>rails new appname --skip-sprockets</code></pre>

<p>You should use the defaults for all new applications unless you have a
specific reason to avoid the asset pipeline.</p>

<h3 id="label-Main+Features">Main Features</h3>

<p>The first feature of the pipeline is to concatenate assets. This is
important in a production environment, because it can reduce the number of
requests that a browser makes to render a web page. <a
href="../../../../classes/Web.html">Web</a> browsers are limited in the
number of requests that they can make in parallel, so fewer requests can
mean faster loading for your application.</p>

<p><a href="../../../../classes/Rails.html">Rails</a> 2.x introduced the
ability to concatenate JavaScript and CSS assets by placing <code>cache:
true</code> at the end of the <code>javascript_include_tag</code> and
<code>stylesheet_link_tag</code> methods. But this technique has some
limitations. For example, it cannot generate the caches in advance, and it
is not able to transparently include assets provided by third-party
libraries.</p>

<p>Starting with version 3.1, <a
href="../../../../classes/Rails.html">Rails</a> defaults to concatenating
all JavaScript files into one master <code>.js</code> file and all CSS
files into one master <code>.css</code> file. As you&#39;ll learn later in
this guide, you can customize this strategy to group files any way you
like. In production, <a href="../../../../classes/Rails.html">Rails</a>
inserts an MD5 fingerprint into each filename so that the file is cached by
the web browser. You can invalidate the cache by altering this fingerprint,
which happens automatically whenever you change the file contents.</p>

<p>The second feature of the asset pipeline is asset minification or
compression. For CSS files, this is done by removing whitespace and
comments. For JavaScript, more complex processes can be applied. You can
choose from a set of built in options or specify your own.</p>

<p>The third feature of the asset pipeline is that it allows coding assets via
a higher-level language, with precompilation down to the actual assets.
Supported languages include Sass for CSS, CoffeeScript for JavaScript, and
<a href="../../../../classes/ERB.html">ERB</a> for both by default.</p>

<h3 id="label-What+is+Fingerprinting+and+Why+Should+I+Care%3F">What is Fingerprinting and Why Should I Care?</h3>

<p>Fingerprinting is a technique that makes the name of a file dependent on
the contents of the file. When the file contents change, the filename is
also changed. For content that is static or infrequently changed, this
provides an easy way to tell whether two versions of a file are identical,
even across different servers or deployment dates.</p>

<p>When a filename is unique and based on its content, HTTP headers can be set
to encourage caches everywhere (whether at CDNs, at ISPs, in networking
equipment, or in web browsers) to keep their own copy of the content. When
the content is updated, the fingerprint will change. This will cause the
remote clients to request a new copy of the content. This is generally
known as <em>cache busting</em>.</p>

<p>The technique that <a href="../../../../classes/Rails.html">Rails</a> uses
for fingerprinting is to insert a hash of the content into the name,
usually at the end. For example a CSS file <code>global.css</code> could be
renamed with an MD5 digest of its contents:</p>

<pre><code>global-908e25f4bf641868d8683022a5b62f54.css</code></pre>

<p>This is the strategy adopted by the <a
href="../../../../classes/Rails.html">Rails</a> asset pipeline.</p>

<p>Rails&#39; old strategy was to append a date-based query string to every
asset linked with a built-in helper. In the source the generated code
looked like this:</p>

<pre><code>/stylesheets/global.css?1309495796</code></pre>

<p>The query string strategy has several disadvantages:</p>
<ol><li>
<p><strong>Not all caches will reliably cache content where the filename only
differs by query parameters</strong>&lt;br /&gt; <a
href="http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/">Steve
Souders recommends</a>, “…avoiding a querystring for cacheable resources”.
He found that in this case 5-20% of requests will not be cached. Query
strings in particular do not work at all with some CDNs for cache
invalidation.</p>
</li><li>
<p><strong>The file name can change between nodes in multi-server
environments.</strong>&lt;br /&gt; The default query string in <a
href="../../../../classes/Rails.html">Rails</a> 2.x is based on the
modification time of the files. When assets are deployed to a cluster,
there is no guarantee that the timestamps will be the same, resulting in
different values being used depending on which server handles the request.</p>
</li><li>
<p><strong>Too much cache invalidation</strong>&lt;br /&gt; When static assets
are deployed with each new release of code, the mtime of <em>all</em> these
files changes, forcing all remote clients to fetch them again, even when
the content of those assets has not changed.</p>
</li></ol>

<p>Fingerprinting fixes these problems by avoiding query strings, and by
ensuring that filenames are consistent based on their content.</p>

<p>Fingerprinting is enabled by default for production and disabled for all
other environments. You can enable or disable it in your configuration
through the <code>config.assets.digest</code> option.</p>

<p>More reading:</p>

<p><a
href="http://code.google.com/speed/page-speed/docs/caching.html">Optimize
caching</a>  <a
href="http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/">Revving
Filenames: don’t use querystring</a></p>

<h2 id="label-How+to+Use+the+Asset+Pipeline">How to Use the Asset Pipeline</h2>

<p>In previous versions of <a href="../../../../classes/Rails.html">Rails</a>,
all assets were located in subdirectories of <code>public</code> such as
<code>images</code>, <code>javascripts</code> and <code>stylesheets</code>.
With the asset pipeline, the preferred location for these assets is now the
<code>app/assets</code> directory. Files in this directory are served by
the Sprockets middleware included in the sprockets gem.</p>

<p>Assets can still be placed in the <code>public</code> hierarchy. Any assets
under <code>public</code> will be served as static files by the application
or web server. You should use <code>app/assets</code> for files that must
undergo some pre-processing before they are served.</p>

<p>In production, <a href="../../../../classes/Rails.html">Rails</a>
precompiles these files to <code>public/assets</code> by default. The
precompiled copies are then served as static assets by the web server. The
files in <code>app/assets</code> are never served directly in production.</p>

<h3 id="label-Controller+Specific+Assets">Controller Specific Assets</h3>

<p>When you generate a scaffold or a controller, <a
href="../../../../classes/Rails.html">Rails</a> also generates a JavaScript
file (or CoffeeScript file if the <code>coffee-rails</code> gem is in the
<code>Gemfile</code>) and a Cascading Style Sheet file (or SCSS file if
<code>sass-rails</code> is in the <code>Gemfile</code>) for that
controller.</p>

<p>For example, if you generate a <code>ProjectsController</code>, <a
href="../../../../classes/Rails.html">Rails</a> will also add a new file at
<code>app/assets/javascripts/projects.js.coffee</code> and another at
<code>app/assets/stylesheets/projects.css.scss</code>. By default these
files will be ready to use by your application immediately using the
<code>require_tree</code> directive. See <a
href="#manifest-files-and-directives">Manifest Files and Directives</a> for
more details on require_tree.</p>

<p>You can also opt to include controller specific stylesheets and JavaScript
files only in their respective controllers using the following:
<code>&lt;%= javascript_include_tag params[:controller] %&gt;</code> or
<code>&lt;%= stylesheet_link_tag params[:controller] %&gt;</code>. Ensure
that you are not using the <code>require_tree</code> directive though, as
this will result in your assets being included more than once.</p>

<p>WARNING: When using asset precompilation (the production default), you will
need to ensure that your controller assets will be precompiled when loading
them on a per page basis. By default .coffee and .scss files will not be
precompiled on their own. This will result in false positives during
development as these files will work just fine since assets will be
compiled on the fly. When running in production however, you will see 500
errors since live compilation is turned off by default. See <a
href="#precompiling-assets">Precompiling Assets</a> for more information on
how precompiling works.</p>

<p>NOTE: You must have an ExecJS supported runtime in order to use
CoffeeScript. If you are using Mac OS X or Windows you have a JavaScript
runtime installed in your operating system. Check <a
href="https://github.com/sstephenson/execjs#readme">ExecJS</a>
documentation to know all supported JavaScript runtimes.</p>

<p>You can also disable the generation of asset files when generating a
controller by adding the following to your
<code>config/application.rb</code> configuration:</p>

<pre><code>config.generators do |g|
  g.assets false
end
</code></pre>

<h3 id="label-Asset+Organization">Asset <a href="../../../../classes/Organization.html">Organization</a></h3>

<p>Pipeline assets can be placed inside an application in one of three
locations: <code>app/assets</code>, <code>lib/assets</code> or
<code>vendor/assets</code>.</p>

<p><code>app/assets</code> is for assets that are owned by the application,
such as custom images, JavaScript files or stylesheets.</p>

<p><code>lib/assets</code> is for your own libraries&#39; code that
doesn&#39;t really fit into the scope of the application or those libraries
which are shared across applications.</p>

<p><code>vendor/assets</code> is for assets that are owned by outside
entities, such as code for JavaScript plugins and CSS frameworks.</p>

<h4 id="label-Search+Paths">Search Paths</h4>

<p>When a file is referenced from a manifest or a helper, Sprockets searches
the three default asset locations for it.</p>

<p>The default locations are: <code>app/assets/images</code> and the
subdirectories <code>javascripts</code> and <code>stylesheets</code> in all
three asset locations, but these subdirectories are not special. Any path
under <code>assets</code> will be searched.</p>

<p>For example, these files:</p>

<pre><code>app/assets/javascripts/home.js
lib/assets/javascripts/moovinator.js
vendor/assets/javascripts/slider.js
vendor/assets/somepackage/phonebox.js</code></pre>

<p>would be referenced in a manifest like this:</p>

<pre><code>//= require home
//= require moovinator
//= require slider
//= require phonebox
</code></pre>

<p>Assets inside subdirectories can also be accessed.</p>

<pre><code>app/assets/javascripts/sub/something.js</code></pre>

<p>is referenced as:</p>

<pre><code>//= require sub/something
</code></pre>

<p>You can view the search path by inspecting
<code>Rails.application.config.assets.paths</code> in the <a
href="../../../../classes/Rails.html">Rails</a> console.</p>

<p>Besides the standard <code>assets/*</code> paths, additional (fully
qualified) paths can be added to the pipeline in
<code>config/application.rb</code>. For example:</p>

<pre><code>config.assets.paths &lt;&lt; Rails.root.join(&quot;lib&quot;, &quot;videoplayer&quot;, &quot;flash&quot;)
</code></pre>

<p>Paths are traversed in the order that they occur in the search path. By
default, this means the files in <code>app/assets</code> take precedence,
and will mask corresponding paths in <code>lib</code> and
<code>vendor</code>.</p>

<p>It is important to note that files you want to reference outside a manifest
must be added to the precompile array or they will not be available in the
production environment.</p>

<h4 id="label-Using+Index+Files">Using Index Files</h4>

<p>Sprockets uses files named <code>index</code> (with the relevant
extensions) for a special purpose.</p>

<p>For example, if you have a jQuery library with many modules, which is
stored in <code>lib/assets/library_name</code>, the file
<code>lib/assets/library_name/index.js</code> serves as the manifest for
all files in this library. This file could include a list of all the
required files in order, or a simple <code>require_tree</code> directive.</p>

<p>The library as a whole can be accessed in the site&#39;s application
manifest like so:</p>

<pre><code>//= require library_name
</code></pre>

<p>This simplifies maintenance and keeps things clean by allowing related code
to be grouped before inclusion elsewhere.</p>

<h3 id="label-Coding+Links+to+Assets">Coding Links to Assets</h3>

<p>Sprockets does not add any new methods to access your assets - you still
use the familiar <code>javascript_include_tag</code> and
<code>stylesheet_link_tag</code>.</p>

<pre><code>&lt;%= stylesheet_link_tag &quot;application&quot; %&gt;
&lt;%= javascript_include_tag &quot;application&quot; %&gt;</code></pre>

<p>In regular views you can access images in the <code>assets/images</code>
directory like this:</p>

<pre><code>&lt;%= image_tag &quot;rails.png&quot; %&gt;</code></pre>

<p>Provided that the pipeline is enabled within your application (and not
disabled in the current environment context), this file is served by
Sprockets. If a file exists at <code>public/assets/rails.png</code> it is
served by the web server.</p>

<p>Alternatively, a request for a file with an MD5 hash such as
<code>public/assets/rails-af27b6a414e6da00003503148be9b409.png</code> is
treated the same way. How these hashes are generated is covered in the <a
href="#in-production">In Production</a> section later on in this guide.</p>

<p>Sprockets will also look through the paths specified in
<code>config.assets.paths</code> which includes the standard application
paths and any path added by <a
href="../../../../classes/Rails.html">Rails</a> engines.</p>

<p>Images can also be organized into subdirectories if required, and they can
be accessed by specifying the directory&#39;s name in the tag:</p>

<pre><code>&lt;%= image_tag &quot;icons/rails.png&quot; %&gt;</code></pre>

<p>WARNING: If you&#39;re precompiling your assets (see <a
href="#in-production">In Production</a> below), linking to an asset that
does not exist will raise an exception in the calling page. This includes
linking to a blank string. As such, be careful using <code>image_tag</code>
and the other helpers with user-supplied data.</p>

<h4 id="label-CSS+and+ERB">CSS and <a href="../../../../classes/ERB.html">ERB</a></h4>

<p>The asset pipeline automatically evaluates <a
href="../../../../classes/ERB.html">ERB</a>. This means that if you add an
<code>erb</code> extension to a CSS asset (for example,
<code>application.css.erb</code>), then helpers like
<code>asset_path</code> are available in your CSS rules:</p>

<pre><code>.class { background-image: url(&lt;%= asset_path &#39;image.png&#39; %&gt;) }</code></pre>

<p>This writes the path to the particular asset being referenced. In this
example, it would make sense to have an image in one of the asset load
paths, such as <code>app/assets/images/image.png</code>, which would be
referenced here. If this image is already available in
<code>public/assets</code> as a fingerprinted file, then that path is
referenced.</p>

<p>If you want to use a <a
href="http://en.wikipedia.org/wiki/Data_URI_scheme">data URI</a> — a method
of embedding the image data directly into the CSS file — you can use the
<code>asset_data_uri</code> helper.</p>

<pre><code>#logo { background: url(&lt;%= asset_data_uri &#39;logo.png&#39; %&gt;) }</code></pre>

<p>This inserts a correctly-formatted data <a
href="../../../../classes/URI.html">URI</a> into the CSS source.</p>

<p>Note that the closing tag cannot be of the style <code>-%&gt;</code>.</p>

<h4 id="label-CSS+and+Sass">CSS and Sass</h4>

<p>When using the asset pipeline, paths to assets must be re-written and
<code>sass-rails</code> provides <code>-url</code> and <code>-path</code>
helpers (hyphenated in Sass, underscored in Ruby) for the following asset
classes: image, font, video, audio, JavaScript and stylesheet.</p>

<p><code>image-url(&quot;rails.png&quot;)</code> becomes
<code>url(/assets/rails.png)</code> 
<code>image-path(&quot;rails.png&quot;)</code> becomes
<code>&quot;/assets/rails.png&quot;</code>.</p>

<p>The more generic form can also be used but the asset path and class must
both be specified:</p>

<p><code>asset-url(&quot;rails.png&quot;, image)</code> becomes
<code>url(/assets/rails.png)</code> 
<code>asset-path(&quot;rails.png&quot;, image)</code> becomes
<code>&quot;/assets/rails.png&quot;</code></p>

<h4 id="label-JavaScript%2FCoffeeScript+and+ERB">JavaScript/CoffeeScript and <a href="../../../../classes/ERB.html">ERB</a></h4>

<p>If you add an <code>erb</code> extension to a JavaScript asset, making it
something such as <code>application.js.erb</code>, then you can use the
<code>asset_path</code> helper in your JavaScript code:</p>

<pre><code>$(&#39;#logo&#39;).attr({
  src: &quot;&lt;%= asset_path(&#39;logo.png&#39;) %&gt;&quot;
});</code></pre>

<p>This writes the path to the particular asset being referenced.</p>

<p>Similarly, you can use the <code>asset_path</code> helper in CoffeeScript
files with <code>erb</code> extension (e.g.,
<code>application.js.coffee.erb</code>):</p>

<pre><code>$(&#39;#logo&#39;).attr src: &quot;&lt;%= asset_path(&#39;logo.png&#39;) %&gt;&quot;</code></pre>

<h3 id="label-Manifest+Files+and+Directives">Manifest Files and Directives</h3>

<p>Sprockets uses manifest files to determine which assets to include and
serve. These manifest files contain <em>directives</em> — instructions that
tell Sprockets which files to require in order to build a single CSS or
JavaScript file. With these directives, Sprockets loads the files
specified, processes them if necessary, concatenates them into one single
file and then compresses them (if
<code>Rails.application.config.assets.compress</code> is true). By serving
one file rather than many, the load time of pages can be greatly reduced
because the browser makes fewer requests. Compression also reduces the file
size enabling the browser to download it faster.</p>

<p>For example, a new <a href="../../../../classes/Rails.html">Rails</a>
application includes a default
<code>app/assets/javascripts/application.js</code> file which contains the
following lines:</p>

<pre><code>// ...
//= require jquery
//= require jquery_ujs
//= require_tree .
</code></pre>

<p>In JavaScript files, the directives begin with <code>//=</code>. In this
case, the file is using the <code>require</code> and the
<code>require_tree</code> directives. The <code>require</code> directive is
used to tell Sprockets the files that you wish to require. Here, you are
requiring the files <code>jquery.js</code> and <code>jquery_ujs.js</code>
that are available somewhere in the search path for Sprockets. You need not
supply the extensions explicitly. Sprockets assumes you are requiring a
<code>.js</code> file when done from within a <code>.js</code> file.</p>

<p>The <code>require_tree</code> directive tells Sprockets to recursively
include <em>all</em> JavaScript files in the specified directory into the
output. These paths must be specified relative to the manifest file. You
can also use the <code>require_directory</code> directive which includes
all JavaScript files only in the directory specified, without recursion.</p>

<p>Directives are processed top to bottom, but the order in which files are
included by <code>require_tree</code> is unspecified. You should not rely
on any particular order among those. If you need to ensure some particular
JavaScript ends up above some other in the concatenated file, require the
prerequisite file first in the manifest. Note that the family of
<code>require</code> directives prevents files from being included twice in
the output.</p>

<p><a href="../../../../classes/Rails.html">Rails</a> also creates a default
<code>app/assets/stylesheets/application.css</code> file which contains
these lines:</p>

<pre><code>/* ...
 = require_self
 = require_tree .</code></pre>

<p>The directives that work in the JavaScript files also work in stylesheets
(though obviously including stylesheets rather than JavaScript files). The
<code>require_tree</code> directive in a CSS manifest works the same way as
the JavaScript one, requiring all stylesheets from the current directory.</p>

<p>In this example <code>require_self</code> is used. This puts the CSS
contained within the file (if any) at the precise location of the
<code>require_self</code> call. If <code>require_self</code> is called more
than once, only the last call is respected.</p>

<p>NOTE. If you want to use multiple Sass files, you should generally use the
<a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#import">Sass
@import rule</a> instead of these Sprockets directives. Using Sprockets
directives all Sass files exist within their own scope, making variables or
mixins only available within the document they were defined in.</p>

<p>You can have as many manifest files as you need. For example the
<code>admin.css</code> and <code>admin.js</code> manifest could contain the
JS and CSS files that are used for the admin section of an application.</p>

<p>The same remarks about ordering made above apply. In particular, you can
specify individual files and they are compiled in the order specified. For
example, you might concatenate three CSS files together this way:</p>

<pre><code>/* ...
 = require reset
 = require layout
 = require chrome
 /
</code></pre>

<h3 id="label-Preprocessing">Preprocessing</h3>

<p>The file extensions used on an asset determine what preprocessing is
applied. When a controller or a scaffold is generated with the default <a
href="../../../../classes/Rails.html">Rails</a> gemset, a CoffeeScript file
and a SCSS file are generated in place of a regular JavaScript and CSS
file. The example used before was a controller called “projects”, which
generated an <code>app/assets/javascripts/projects.js.coffee</code> and an
<code>app/assets/stylesheets/projects.css.scss</code> file.</p>

<p>When these files are requested, they are processed by the processors
provided by the <code>coffee-script</code> and <code>sass</code> gems and
then sent back to the browser as JavaScript and CSS respectively.</p>

<p>Additional layers of preprocessing can be requested by adding other
extensions, where each extension is processed in a right-to-left manner.
These should be used in the order the processing should be applied. For
example, a stylesheet called
<code>app/assets/stylesheets/projects.css.scss.erb</code> is first
processed as <a href="../../../../classes/ERB.html">ERB</a>, then SCSS, and
finally served as CSS. The same applies to a JavaScript file —
<code>app/assets/javascripts/projects.js.coffee.erb</code> is processed as
<a href="../../../../classes/ERB.html">ERB</a>, then CoffeeScript, and
served as JavaScript.</p>

<p>Keep in mind that the order of these preprocessors is important. For
example, if you called your JavaScript file
<code>app/assets/javascripts/projects.js.erb.coffee</code> then it would be
processed with the CoffeeScript interpreter first, which wouldn&#39;t
understand <a href="../../../../classes/ERB.html">ERB</a> and therefore you
would run into problems.</p>

<h2 id="label-In+Development">In Development</h2>

<p>In development mode, assets are served as separate files in the order they
are specified in the manifest file.</p>

<p>This manifest <code>app/assets/javascripts/application.js</code>:</p>

<pre><code>//= require core
//= require projects
//= require tickets
</code></pre>

<p>would generate this HTML:</p>

<pre><code>&lt;script src=&quot;/assets/core.js?body=1&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/assets/projects.js?body=1&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/assets/tickets.js?body=1&quot;&gt;&lt;/script&gt;</code></pre>

<p>The <code>body</code> param is required by Sprockets.</p>

<h3 id="label-Turning+Debugging+Off">Turning Debugging Off</h3>

<p>You can turn off debug mode by updating
<code>config/environments/development.rb</code> to include:</p>

<pre><code>config.assets.debug = false
</code></pre>

<p>When debug mode is off, Sprockets concatenates and runs the necessary
preprocessors on all files. With debug mode turned off the manifest above
would generate instead:</p>

<pre><code>&lt;script src=&quot;/assets/application.js&quot;&gt;&lt;/script&gt;</code></pre>

<p>Assets are compiled and cached on the first request after the server is
started. Sprockets sets a <code>must-revalidate</code> Cache-Control HTTP
header to reduce request overhead on subsequent requests — on these the
browser gets a 304 (Not Modified) response.</p>

<p>If any of the files in the manifest have changed between requests, the
server responds with a new compiled file.</p>

<p>Debug mode can also be enabled in the <a
href="../../../../classes/Rails.html">Rails</a> helper methods:</p>

<pre><code>&lt;%= stylesheet_link_tag &quot;application&quot;, debug: true %&gt;
&lt;%= javascript_include_tag &quot;application&quot;, debug: true %&gt;</code></pre>

<p>The <code>:debug</code> option is redundant if debug mode is on.</p>

<p>You could potentially also enable compression in development mode as a
sanity check, and disable it on-demand as required for debugging.</p>

<h2 id="label-In+Production">In Production</h2>

<p>In the production environment <a
href="../../../../classes/Rails.html">Rails</a> uses the fingerprinting
scheme outlined above. By default <a
href="../../../../classes/Rails.html">Rails</a> assumes that assets have
been precompiled and will be served as static assets by your web server.</p>

<p>During the precompilation phase an MD5 is generated from the contents of
the compiled files, and inserted into the filenames as they are written to
disc. These fingerprinted names are used by the <a
href="../../../../classes/Rails.html">Rails</a> helpers in place of the
manifest name.</p>

<p>For example this:</p>

<pre><code>&lt;%= javascript_include_tag &quot;application&quot; %&gt;
&lt;%= stylesheet_link_tag &quot;application&quot; %&gt;</code></pre>

<p>generates something like this:</p>

<pre><code>&lt;script src=&quot;/assets/application-908e25f4bf641868d8683022a5b62f54.js&quot;&gt;&lt;/script&gt;
&lt;link href=&quot;/assets/application-4dd5b109ee3439da54f5bdfd78a80473.css&quot; media=&quot;screen&quot; rel=&quot;stylesheet&quot; /&gt;</code></pre>

<p>Note: with the Asset Pipeline the :cache and :concat options aren&#39;t
used anymore, delete these options from the
<code>javascript_include_tag</code> and <code>stylesheet_link_tag</code>.</p>

<p>The fingerprinting behavior is controlled by the setting of
<code>config.assets.digest</code> setting in <a
href="../../../../classes/Rails.html">Rails</a> (which defaults to
<code>true</code> for production and <code>false</code> for everything
else).</p>

<p>NOTE: Under normal circumstances the default option should not be changed.
If there are no digests in the filenames, and far-future headers are set,
remote clients will never know to refetch the files when their content
changes.</p>

<h3 id="label-Precompiling+Assets">Precompiling Assets</h3>

<p><a href="../../../../classes/Rails.html">Rails</a> comes bundled with a
rake task to compile the asset manifests and other files in the pipeline to
the disk.</p>

<p>Compiled assets are written to the location specified in
<code>config.assets.prefix</code>. By default, this is the
<code>public/assets</code> directory.</p>

<p>You can call this task on the server during deployment to create compiled
versions of your assets directly on the server. See the next section for
information on compiling locally.</p>

<p>The rake task is:</p>

<pre><code>$ bundle exec rake assets:precompile</code></pre>

<p>For faster asset precompiles, you can partially load your application by
setting <code>config.assets.initialize_on_precompile</code> to false in
<code>config/application.rb</code>, though in that case templates cannot
see application objects or methods. <strong>Heroku requires this to be
false.</strong></p>

<p>WARNING: If you set <code>config.assets.initialize_on_precompile</code> to
false, be sure to test <code>rake assets:precompile</code> locally before
deploying. It may expose bugs where your assets reference application
objects or methods, since those are still in scope in development mode
regardless of the value of this flag. Changing this flag also affects
engines. Engines can define assets for precompilation as well. Since the
complete environment is not loaded, engines (or other gems) will not be
loaded, which can cause missing assets.</p>

<p>Capistrano (v2.8.0 and above) includes a recipe to handle this in
deployment. Add the following line to <code>Capfile</code>:</p>

<pre><code>load &#39;deploy/assets&#39;
</code></pre>

<p>This links the folder specified in <code>config.assets.prefix</code> to
<code>shared/assets</code>. If you already use this shared folder
you&#39;ll need to write your own deployment task.</p>

<p>It is important that this folder is shared between deployments so that
remotely cached pages that reference the old compiled assets still work for
the life of the cached page.</p>

<p>NOTE. If you are precompiling your assets locally, you can use <code>bundle
install --without assets</code> on the server to avoid installing the
assets gems (the gems in the assets group in the <a
href="../../Gemfile.html">Gemfile</a>).</p>

<p>The default matcher for compiling files includes
<code>application.js</code>, <code>application.css</code> and all
non-JS/CSS files (this will include all image assets automatically):</p>

<pre><code>[ Proc.new { |path| !%w(.js .css).include?(File.extname(path)) }, /application.(css|js)$/ ]
</code></pre>

<p>NOTE. The matcher (and other members of the precompile array; see below) is
applied to final compiled file names. This means that anything that
compiles to JS/CSS is excluded, as well as raw JS/CSS files; for example,
<code>.coffee</code> and <code>.scss</code> files are <strong>not</strong>
automatically included as they compile to JS/CSS.</p>

<p>If you have other manifests or individual stylesheets and JavaScript files
to include, you can add them to the <code>precompile</code> array:</p>

<pre><code>config.assets.precompile += [&#39;admin.js&#39;, &#39;admin.css&#39;, &#39;swfObject.js&#39;]
</code></pre>

<p>Or you can opt to precompile all assets with something like this:</p>

<pre><code># config/environments/production.rb
config.assets.precompile &lt;&lt; Proc.new do |path|
  if path =~ /\.(css|js)\z/
    full_path = Rails.application.assets.resolve(path).to_path
    app_assets_path = Rails.root.join(&#39;app&#39;, &#39;assets&#39;).to_path
    if full_path.starts_with? app_assets_path
      puts &quot;including asset: &quot; + full_path
      true
    else
      puts &quot;excluding asset: &quot; + full_path
      false
    end
  else
    false
  end
end
</code></pre>

<p>NOTE. Always specify an expected compiled filename that ends with js or
css, even if you want to add Sass or CoffeeScript files to the precompile
array.</p>

<p>The rake task also generates a <code>manifest.yml</code> that contains a
list with all your assets and their respective fingerprints. This is used
by the <a href="../../../../classes/Rails.html">Rails</a> helper methods to
avoid handing the mapping requests back to Sprockets. <a
href="../../../../classes/A.html">A</a> typical manifest file looks like:</p>

<pre><code>---
rails.png: rails-bd9ad5a560b5a3a7be0808c5cd76a798.png
jquery-ui.min.js: jquery-ui-7e33882a28fc84ad0e0e47e46cbf901c.min.js
jquery.min.js: jquery-8a50feed8d29566738ad005e19fe1c2d.min.js
application.js: application-3fdab497b8fb70d20cfc5495239dfc29.js
application.css: application-8af74128f904600e41a6e39241464e03.css</code></pre>

<p>The default location for the manifest is the root of the location specified
in <code>config.assets.prefix</code> (&#39;/assets&#39; by default).</p>

<p>NOTE: If there are missing precompiled files in production you will get an
<code>Sprockets::Helpers::RailsHelper::AssetPaths::AssetNotPrecompiledError</code>
exception indicating the name of the missing file(s).</p>

<h4 id="label-Far-future+Expires+Header">Far-future Expires Header</h4>

<p>Precompiled assets exist on the filesystem and are served directly by your
web server. They do not have far-future headers by default, so to get the
benefit of fingerprinting you&#39;ll have to update your server
configuration to add them.</p>

<p>For Apache:</p>

<pre><code># The Expires* directives requires the Apache module `mod_expires` to be enabled.
&lt;Location /assets/&gt;
  # Use of ETag is discouraged when Last-Modified is present
  Header unset ETag
  FileETag None
  # RFC says only cache for 1 year
  ExpiresActive On
  ExpiresDefault &quot;access plus 1 year&quot;
&lt;/Location&gt;
</code></pre>

<p>For nginx:</p>

<pre><code>location ~ ^/assets/ {
  expires 1y;
  add_header Cache-Control public;

  add_header ETag &quot;&quot;;
  break;
}</code></pre>

<h4 id="label-GZip+Compression">GZip Compression</h4>

<p>When files are precompiled, Sprockets also creates a <a
href="http://en.wikipedia.org/wiki/Gzip">gzipped</a> (.gz) version of your
assets. <a href="../../../../classes/Web.html">Web</a> servers are
typically configured to use a moderate compression ratio as a compromise,
but since precompilation happens once, Sprockets uses the maximum
compression ratio, thus reducing the size of the data transfer to the
minimum. On the other hand, web servers can be configured to serve
compressed content directly from disk, rather than deflating non-compressed
files themselves.</p>

<p>Nginx is able to do this automatically enabling <code>gzip_static</code>:</p>

<pre><code>location ~ ^/(assets)/  {
  root /path/to/public;
  gzip_static on; # to serve pre-gzipped version
  expires max;
  add_header Cache-Control public;
}</code></pre>

<p>This directive is available if the core module that provides this feature
was compiled with the web server. Ubuntu packages, even
<code>nginx-light</code> have the module compiled. Otherwise, you may need
to perform a manual compilation:</p>

<pre><code>./configure --with-http_gzip_static_module</code></pre>

<p>If you&#39;re compiling nginx with Phusion Passenger you&#39;ll need to
pass that option when prompted.</p>

<p><a href="../../../../classes/A.html">A</a> robust configuration for Apache
is possible but tricky; please Google around. (Or help update this Guide if
you have a good example configuration for Apache.)</p>

<h3 id="label-Local+Precompilation">Local Precompilation</h3>

<p>There are several reasons why you might want to precompile your assets
locally. Among them are:</p>

<p>You may not have write access to your production file system.  You may be
deploying to more than one server, and want to avoid the duplication of
work.  You may be doing frequent deploys that do not include asset changes.</p>

<p>Local compilation allows you to commit the compiled files into source
control, and deploy as normal.</p>

<p>There are two caveats:</p>

<p>You must not run the Capistrano deployment task that precompiles assets. 
You must change the following two application configuration settings.</p>

<p>In <code>config/environments/development.rb</code>, place the following
line:</p>

<pre><code>config.assets.prefix = &quot;/dev-assets&quot;
</code></pre>

<p>You will also need this in application.rb:</p>

<pre><code>config.assets.initialize_on_precompile = false
</code></pre>

<p>The <code>prefix</code> change makes <a
href="../../../../classes/Rails.html">Rails</a> use a different URL for
serving assets in development mode, and pass all requests to Sprockets. The
prefix is still set to <code>/assets</code> in the production environment.
Without this change, the application would serve the precompiled assets
from <code>public/assets</code> in development, and you would not see any
local changes until you compile assets again.</p>

<p>The <code>initialize_on_precompile</code> change tells the precompile task
to run without invoking <a href="../../../../classes/Rails.html">Rails</a>.
This is because the precompile task runs in production mode by default, and
will attempt to connect to your specified production database. Please note
that you cannot have code in pipeline files that relies on <a
href="../../../../classes/Rails.html">Rails</a> resources (such as the
database) when compiling locally with this option.</p>

<p>You will also need to ensure that any compressors or minifiers are
available on your development system.</p>

<p>In practice, this will allow you to precompile locally, have those files in
your working tree, and commit those files to source control when needed.
Development mode will work as expected.</p>

<h3 id="label-Live+Compilation">Live Compilation</h3>

<p>In some circumstances you may wish to use live compilation. In this mode
all requests for assets in the pipeline are handled by Sprockets directly.</p>

<p>To enable this option set:</p>

<pre><code>config.assets.compile = true
</code></pre>

<p>On the first request the assets are compiled and cached as outlined in
development above, and the manifest names used in the helpers are altered
to include the MD5 hash.</p>

<p>Sprockets also sets the <code>Cache-Control</code> HTTP header to
<code>max-age=31536000</code>. This signals all caches between your server
and the client browser that this content (the file served) can be cached
for 1 year. The effect of this is to reduce the number of requests for this
asset from your server; the asset has a good chance of being in the local
browser cache or some intermediate cache.</p>

<p>This mode uses more memory, performs more poorly than the default and is
not recommended.</p>

<p>If you are deploying a production application to a system without any
pre-existing JavaScript runtimes, you may want to add one to your Gemfile:</p>

<pre><code>group :production do
  gem &#39;therubyracer&#39;
end
</code></pre>

<h3 id="label-CDNs">CDNs</h3>

<p>If your assets are being served by a CDN, ensure they don&#39;t stick
around in your cache forever. This can cause problems. If you use
<code>config.action_controller.perform_caching = true</code>, <a
href="../../../../classes/Rack/Cache.html">Rack::Cache</a> will use
<code>Rails.cache</code> to store assets. This can cause your cache to fill
up quickly.</p>

<p>Every cache is different, so evaluate how your CDN handles caching and make
sure that it plays nicely with the pipeline. You may find quirks related to
your specific set up, you may not. The defaults nginx uses, for example,
should give you no problems when used as an HTTP cache.</p>

<h2 id="label-Customizing+the+Pipeline">Customizing the Pipeline</h2>

<h3 id="label-CSS+Compression">CSS Compression</h3>

<p>There is currently one option for compressing CSS, YUI. The <a
href="http://developer.yahoo.com/yui/compressor/css.html">YUI CSS
compressor</a> provides minification.</p>

<p>The following line enables YUI compression, and requires the
<code>yui-compressor</code> gem.</p>

<pre><code>config.assets.css_compressor = :yui
</code></pre>

<p>The <code>config.assets.compress</code> must be set to <code>true</code> to
enable CSS compression.</p>

<h3 id="label-JavaScript+Compression">JavaScript Compression</h3>

<p>Possible options for JavaScript compression are <code>:closure</code>,
<code>:uglifier</code> and <code>:yui</code>. These require the use of the
<code>closure-compiler</code>, <code>uglifier</code> or
<code>yui-compressor</code> gems, respectively.</p>

<p>The default <a href="../../Gemfile.html">Gemfile</a> includes <a
href="https://github.com/lautis/uglifier">uglifier</a>. This gem wraps <a
href="https://github.com/mishoo/UglifyJS">UglifierJS</a> (written for
NodeJS) in Ruby. It compresses your code by removing white space. It also
includes other optimizations such as changing your <code>if</code> and
<code>else</code> statements to ternary operators where possible.</p>

<p>The following line invokes <code>uglifier</code> for JavaScript
compression.</p>

<pre><code>config.assets.js_compressor = :uglifier
</code></pre>

<p>Note that <code>config.assets.compress</code> must be set to
<code>true</code> to enable JavaScript compression</p>

<p>NOTE: You will need an <a
href="https://github.com/sstephenson/execjs#readme">ExecJS</a> supported
runtime in order to use <code>uglifier</code>. If you are using Mac OS X or
Windows you have a JavaScript runtime installed in your operating system.
Check the <a href="https://github.com/sstephenson/execjs#readme">ExecJS</a>
documentation for information on all of the supported JavaScript runtimes.</p>

<h3 id="label-Using+Your+Own+Compressor">Using Your Own Compressor</h3>

<p>The compressor config settings for CSS and JavaScript also take any object.
This object must have a <code>compress</code> method that takes a string as
the sole argument and it must return a string.</p>

<pre><code>class Transformer
  def compress(string)
    do_something_returning_a_string(string)
  end
end
</code></pre>

<p>To enable this, pass a new object to the config option in
<code>application.rb</code>:</p>

<pre><code>config.assets.css_compressor = Transformer.new
</code></pre>

<h3 id="label-Changing+the+assets+Path">Changing the <em>assets</em> Path</h3>

<p>The public path that Sprockets uses by default is <code>/assets</code>.</p>

<p>This can be changed to something else:</p>

<pre><code>config.assets.prefix = &quot;/some_other_path&quot;
</code></pre>

<p>This is a handy option if you are updating an older project that didn&#39;t
use the asset pipeline and that already uses this path or you wish to use
this path for a new resource.</p>

<h3 id="label-X-Sendfile+Headers">X-Sendfile Headers</h3>

<p>The X-Sendfile header is a directive to the web server to ignore the
response from the application, and instead serve a specified file from
disk. This option is off by default, but can be enabled if your server
supports it. When enabled, this passes responsibility for serving the file
to the web server, which is faster.</p>

<p>Apache and nginx support this option, which can be enabled in
<code>config/environments/production.rb</code>.</p>

<pre><code># config.action_dispatch.x_sendfile_header = &quot;X-Sendfile&quot; # for apache
# config.action_dispatch.x_sendfile_header = &#39;X-Accel-Redirect&#39; # for nginx
</code></pre>

<p>WARNING: If you are upgrading an existing application and intend to use
this option, take care to paste this configuration option only into
<code>production.rb</code> and any other environments you define with
production behavior (not <code>application.rb</code>).</p>

<h2 id="label-Assets+Cache+Store">Assets Cache Store</h2>

<p>The default <a href="../../../../classes/Rails.html">Rails</a> cache store
will be used by Sprockets to cache assets in development and production.
This can be changed by setting <code>config.assets.cache_store</code>.</p>

<pre><code>config.assets.cache_store = :memory_store
</code></pre>

<p>The options accepted by the assets cache store are the same as the
application&#39;s cache store.</p>

<pre><code>config.assets.cache_store = :memory_store, { :size =&gt; 32.megabytes }
</code></pre>

<h2 id="label-Adding+Assets+to+Your+Gems">Adding Assets to Your Gems</h2>

<p>Assets can also come from external sources in the form of gems.</p>

<p><a href="../../../../classes/A.html">A</a> good example of this is the
<code>jquery-rails</code> gem which comes with <a
href="../../../../classes/Rails.html">Rails</a> as the standard JavaScript
library gem. This gem contains an engine class which inherits from
<code>Rails::Engine</code>. By doing this, <a
href="../../../../classes/Rails.html">Rails</a> is informed that the
directory for this gem may contain assets and the <code>app/assets</code>,
<code>lib/assets</code> and <code>vendor/assets</code> directories of this
engine are added to the search path of Sprockets.</p>

<h2 id="label-Making+Your+Library+or+Gem+a+Pre-Processor">Making Your Library or Gem a Pre-Processor</h2>

<p>As Sprockets uses <a href="https://github.com/rtomayko/tilt">Tilt</a> as a
generic interface to different templating engines, your gem should just
implement the Tilt template protocol. Normally, you would subclass
<code>Tilt::Template</code> and reimplement <code>evaluate</code> method to
return final output. Template source is stored at <code>@code</code>. Have
a look at <a
href="https://github.com/rtomayko/tilt/blob/master/lib/tilt/template.rb">Tilt::Template</a>
sources to learn more.</p>

<pre><code>module BangBang
  class Template &lt; ::Tilt::Template
    # Adds a &quot;!&quot; to original template.
    def evaluate(scope, locals, &amp;block)
      &quot;#{@code}!&quot;
    end
  end
end
</code></pre>

<p>Now that you have a <code>Template</code> class, it&#39;s time to associate
it with an extenstion for template files:</p>

<pre><code>Sprockets.register_engine &#39;.bang&#39;, BangBang::Template
</code></pre>

<h2 id="label-Upgrading+from+Old+Versions+of+Rails">Upgrading from Old Versions of <a href="../../../../classes/Rails.html">Rails</a></h2>

<p>There are a few issues when upgrading. The first is moving the files from
<code>public/</code> to the new locations. See <a
href="#asset-organization">Asset Organization</a> above for guidance on the
correct locations for different file types.</p>

<p>Next will be avoiding duplicate JavaScript files. Since jQuery is the
default JavaScript library from <a
href="../../../../classes/Rails.html">Rails</a> 3.1 onwards, you don&#39;t
need to copy <code>jquery.js</code> into <code>app/assets</code> and it
will be included automatically.</p>

<p>The third is updating the various environment files with the correct
default options. The following changes reflect the defaults in version
3.1.0.</p>

<p>In <code>application.rb</code>:</p>

<pre><code># Enable the asset pipeline
config.assets.enabled = true

# Version of your assets, change this if you want to expire all your assets
config.assets.version = &#39;1.0&#39;

# Change the path that assets are served from
# config.assets.prefix = &quot;/assets&quot;
</code></pre>

<p>In <code>development.rb</code>:</p>

<pre><code># Do not compress assets
config.assets.compress = false

# Expands the lines which load the assets
config.assets.debug = true
</code></pre>

<p>And in <code>production.rb</code>:</p>

<pre><code># Compress JavaScripts and CSS
config.assets.compress = true

# Choose the compressors to use
# config.assets.js_compressor  = :uglifier
# config.assets.css_compressor = :yui

# Don&#39;t fallback to assets pipeline if a precompiled asset is missed
config.assets.compile = false

# Generate digests for assets URLs.
config.assets.digest = true

# Precompile additional assets (application.js, application.css, and all non-JS/CSS are already added)
# config.assets.precompile += %w( search.js )
</code></pre>

<p>You should not need to change <code>test.rb</code>. The defaults in the
test environment are: <code>config.assets.compile</code> is true and
<code>config.assets.compress</code>, <code>config.assets.debug</code> and
<code>config.assets.digest</code> are false.</p>

<p>The following should also be added to <code>Gemfile</code>:</p>

<pre><code># Gems used only for assets and not required
# in production environments by default.
group :assets do
  gem &#39;sass-rails&#39;,   &quot;~&gt; 3.2.3&quot;
  gem &#39;coffee-rails&#39;, &quot;~&gt; 3.2.1&quot;
  gem &#39;uglifier&#39;
end
</code></pre>

<p>If you use the <code>assets</code> group with Bundler, please make sure
that your <code>config/application.rb</code> has the following Bundler
require statement:</p>

<pre><code>if defined?(Bundler)
  # If you precompile assets before deploying to production, use this line
  Bundler.require *Rails.groups(:assets =&gt; %w(development test))
  # If you want your assets lazily compiled in production, use this line
  # Bundler.require(:default, :assets, Rails.env)
end
</code></pre>

<p>Instead of the old <a href="../../../../classes/Rails.html">Rails</a> 3.0
version:</p>

<pre><code># If you have a Gemfile, require the gems listed there, including any gems
# you&#39;ve limited to :test, :development, or :production.
Bundler.require(:default, Rails.env) if defined?(Bundler)
</code></pre>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>