<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>active_record_basics.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            active_record_basics.md
        </h1>
        <ul class="files">
            <li>rails/guides/source/active_record_basics.md</li>
            <li>Last modified: 2013-04-26 19:51:18 +0300</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-Active+Record+Basics">Active Record Basics</h1>

<p>This guide is an introduction to Active Record.</p>

<p>After reading this guide, you will know:</p>
<ul><li>
<p>What <a href="../../../../classes/Object.html">Object</a> Relational
Mapping and Active Record are and how they are used in  <a
href="../../../../classes/Rails.html">Rails</a>.</p>
</li><li>
<p>How Active Record fits into the Model-View-Controller paradigm.</p>
</li><li>
<p>How to use Active Record models to manipulate data stored in a relational 
database.</p>
</li><li>
<p>Active Record schema naming conventions.</p>
</li><li>
<p>The concepts of database migrations, validations and callbacks.</p>
</li></ul>
<hr style="height: 1px">

<h2 id="label-What+is+Active+Record%3F">What is Active Record?</h2>

<p>Active Record is the M in <a
href="http://getting_started.html#the-mvc-architecture">MVC</a> - the model
- which is the layer of the system responsible for representing business
data and logic. Active Record facilitates the creation and use of business
objects whose data requires persistent storage to a database. It is an
implementation of the Active Record pattern which itself is a description
of an <a href="../../../../classes/Object.html">Object</a> Relational
Mapping system.</p>

<h3 id="label-The+Active+Record+Pattern">The Active Record Pattern</h3>

<p>Active Record was described by Martin Fowler in his book <em>Patterns of
Enterprise Application Architecture</em>. In Active Record, objects carry
both persistent data and behavior which operates on that data. Active
Record takes the opinion that ensuring data access logic is part of the
object will educate users of that object on how to write to and read from
the database.</p>

<h3 id="label-Object+Relational+Mapping"><a href="../../../../classes/Object.html">Object</a> Relational Mapping</h3>

<p>Object-Relational Mapping, commonly referred to as its abbreviation ORM, is
a technique that connects the rich objects of an application to tables in a
relational database management system. Using ORM, the properties and
relationships of the objects in an application can be easily stored and
retrieved from a database without writing SQL statements directly and with
less overall database access code.</p>

<h3 id="label-Active+Record+as+an+ORM+Framework">Active Record as an ORM Framework</h3>

<p>Active Record gives us several mechanisms, the most important being the
ability to:</p>
<ul><li>
<p>Represent models and their data</p>
</li><li>
<p>Represent associations between these models</p>
</li><li>
<p>Represent inheritance hierarchies through related models</p>
</li><li>
<p>Validate models before they get persisted to the database</p>
</li><li>
<p>Perform database operations in an object-oriented fashion.</p>
</li></ul>

<h2 id="label-Convention+over+Configuration+in+Active+Record">Convention over Configuration in Active Record</h2>

<p>When writing applications using other programming languages or frameworks,
it may be necessary to write a lot of configuration code. This is
particularly true for ORM frameworks in general. However, if you follow the
conventions adopted by <a href="../../../../classes/Rails.html">Rails</a>,
you&#39;ll need to write very little configuration (in some case no
configuration at all) when creating Active Record models. The idea is that
if you configure your applications in the very same way most of the times
then this should be the default way. In this cases, explicit configuration
would be needed only in those cases where you can&#39;t follow the
conventions for any reason.</p>

<h3 id="label-Naming+Conventions">Naming Conventions</h3>

<p>By default, Active Record uses some naming conventions to find out how the
mapping between models and database tables should be created. <a
href="../../../../classes/Rails.html">Rails</a> will pluralize your class
names to find the respective database table. So, for a class
<code>Book</code>, you should have a database table called
<strong>books</strong>. The <a
href="../../../../classes/Rails.html">Rails</a> pluralization mechanisms
are very powerful, being capable to pluralize (and singularize) both
regular and irregular words. When using class names composed of two or more
words, the model class name should follow the Ruby conventions, using the
CamelCase form, while the table name must contain the words separated by
underscores. Examples:</p>
<ul><li>
<p>Database Table - Plural with underscores separating words (e.g.,
<code>book_clubs</code>)</p>
</li><li>
<p>Model <a href="../../../../classes/Class.html">Class</a> - Singular with
the first letter of each word capitalized (e.g., <code>BookClub</code>)</p>
</li></ul>

<p>| Model / <a href="../../../../classes/Class.html">Class</a> | Table /
Schema | | ————- | ————– | | <code>Post</code> | <code>posts</code> | |
<code>LineItem</code> | <code>line_items</code> | | <code>Deer</code> |
<code>deer</code> | | <code>Mouse</code> | <code>mice</code> | |
<code>Person</code> | <code>people</code> |</p>

<h3 id="label-Schema+Conventions">Schema Conventions</h3>

<p>Active Record uses naming conventions for the columns in database tables,
depending on the purpose of these columns.</p>
<ul><li>
<p><strong>Foreign keys</strong> - These fields should be named following the
pattern  <code>singularized_table_name_id</code> (e.g.,
<code>item_id</code>, <code>order_id</code>). These are the  fields that
Active Record will look for when you create associations between  your
models.</p>
</li><li>
<p><strong>Primary keys</strong> - By default, Active Record will use an
integer column named  <code>id</code> as the table&#39;s primary key. When
using <a href="http://migrations.html">Rails Migrations</a> to create your
tables, this column will be  automatically created.</p>
</li></ul>

<p>There are also some optional column names that will create additional
features to Active Record instances:</p>
<ul><li>
<p><code>created_at</code> - Automatically gets set to the current date and
time when the  record is first created.</p>
</li><li>
<p><code>updated_at</code> - Automatically gets set to the current date and
time whenever  the record is updated.</p>
</li><li>
<p><code>lock_version</code> - Adds <a
href="http://api.rubyonrails.org/classes/ActiveRecord/Locking.html">optimistic
locking</a> to  a model.</p>
</li><li>
<p><code>type</code> - Specifies that the model uses <a
href="http://api.rubyonrails.org/classes/ActiveRecord/Base.html">Single
Table Inheritance</a></p>
</li><li>
<p><code>(table_name)_count</code> - Used to cache the number of belonging
objects on  associations. For example, a <code>comments_count</code> column
in a <code>Post</code> class that  has many instances of
<code>Comment</code> will cache the number of existent comments  for each
post.</p>
</li></ul>

<p>NOTE: While these column names are optional, they are in fact reserved by
Active Record. Steer clear of reserved keywords unless you want the extra
functionality. For example, <code>type</code> is a reserved keyword used to
designate a table using Single Table Inheritance (STI). If you are not
using STI, try an analogous keyword like “context”, that may still
accurately describe the data you are modeling.</p>

<h2 id="label-Creating+Active+Record+Models">Creating Active Record Models</h2>

<p>It is very easy to create Active Record models. All you have to do is to
subclass the <code>ActiveRecord::Base</code> class and you&#39;re good to
go:</p>

<pre><code>class Product &lt; ActiveRecord::Base
end
</code></pre>

<p>This will create a <code>Product</code> model, mapped to a
<code>products</code> table at the database. By doing this you&#39;ll also
have the ability to map the columns of each row in that table with the
attributes of the instances of your model. Suppose that the
<code>products</code> table was created using an SQL sentence like:</p>

<pre><code>CREATE TABLE products (
   id int(11) NOT NULL auto_increment,
   name varchar(255),
   PRIMARY KEY  (id)
);</code></pre>

<p>Following the table schema above, you would be able to write code like the
following:</p>

<pre><code>p = Product.new
p.name = &quot;Some Book&quot;
puts p.name # &quot;Some Book&quot;
</code></pre>

<h2 id="label-Overriding+the+Naming+Conventions">Overriding the Naming Conventions</h2>

<p>What if you need to follow a different naming convention or need to use
your <a href="../../../../classes/Rails.html">Rails</a> application with a
legacy database? No problem, you can easily override the default
conventions.</p>

<p>You can use the <code>ActiveRecord::Base.table_name=</code> method to
specify the table name that should be used:</p>

<pre><code>class Product &lt; ActiveRecord::Base
  self.table_name = &quot;PRODUCT&quot;
end
</code></pre>

<p>If you do so, you will have to define manually the class name that is
hosting the fixtures (class_name.yml) using the
<code>set_fixture_class</code> method in your test definition:</p>

<pre><code>class FunnyJoke &lt; ActiveSupport::TestCase
  set_fixture_class funny_jokes: &#39;Joke&#39;
  fixtures :funny_jokes
  ...
end
</code></pre>

<p>It&#39;s also possible to override the column that should be used as the
table&#39;s primary key using the
<code>ActiveRecord::Base.set_primary_key</code> method:</p>

<pre><code>class Product &lt; ActiveRecord::Base
  set_primary_key &quot;product_id&quot;
end
</code></pre>

<h2 id="label-CRUD%3A+Reading+and+Writing+Data">CRUD: Reading and Writing Data</h2>

<p>CRUD is an acronym for the four verbs we use to operate on data: *C*reate,
*R*ead, *U*pdate and *D*elete. Active Record automatically creates methods
to allow an application to read and manipulate data stored within its
tables.</p>

<h3 id="label-Create">Create</h3>

<p>Active Record objects can be created from a hash, a block or have their
attributes manually set after creation. The <code>new</code> method will
return a new object while <code>create</code> will return the object and
save it to the database.</p>

<p>For example, given a model <code>User</code> with attributes of
<code>name</code> and <code>occupation</code>, the <code>create</code>
method call will create and save a new record into the database:</p>

<pre><code>user = User.create(name: &quot;David&quot;, occupation: &quot;Code Artist&quot;)
</code></pre>

<p>Using the <code>new</code> method, an object can be instantiated without
being saved:</p>

<pre><code>user = User.new
user.name = &quot;David&quot;
user.occupation = &quot;Code Artist&quot;
</code></pre>

<p><a href="../../../../classes/A.html">A</a> call to <code>user.save</code>
will commit the record to the database.</p>

<p>Finally, if a block is provided, both <code>create</code> and
<code>new</code> will yield the new object to that block for
initialization:</p>

<pre><code>user = User.new do |u|
  u.name = &quot;David&quot;
  u.occupation = &quot;Code Artist&quot;
end
</code></pre>

<h3 id="label-Read">Read</h3>

<p>Active Record provides a rich API for accessing data within a database.
Below are a few examples of different data access methods provided by
Active Record.</p>

<pre><code># return a collection with all users
users = User.all
</code></pre>

<pre><code># return the first user
user = User.first
</code></pre>

<pre><code># return the first user named David
david = User.find_by_name(&#39;David&#39;)
</code></pre>

<pre><code># find all users named David who are Code Artists and sort by created_at in reverse chronological order
users = User.where(name: &#39;David&#39;, occupation: &#39;Code Artist&#39;).order(&#39;created_at DESC&#39;)
</code></pre>

<p>You can learn more about querying an Active Record model in the <a
href="http://active_record_querying.html">Active Record Query Interface</a>
guide.</p>

<h3 id="label-Update">Update</h3>

<p>Once an Active Record object has been retrieved, its attributes can be
modified and it can be saved to the database.</p>

<pre><code>user = User.find_by_name(&#39;David&#39;)
user.name = &#39;Dave&#39;
user.save
</code></pre>

<p><a href="../../../../classes/A.html">A</a> shorthand for this is to use a
hash mapping attribute names to the desired value, like so:</p>

<pre><code>user = User.find_by_name(&#39;David&#39;)
user.update(name: &#39;Dave&#39;)
</code></pre>

<p>This is most useful when updating several attributes at once. If, on the
other hand, you&#39;d like to update several records in bulk, you may find
the <code>update_all</code> class method useful:</p>

<pre><code>User.update_all &quot;max_login_attempts = 3, must_change_password = &#39;true&#39;&quot;
</code></pre>

<h3 id="label-Delete">Delete</h3>

<p>Likewise, once retrieved an Active Record object can be destroyed which
removes it from the database.</p>

<pre><code>user = User.find_by_name(&#39;David&#39;)
user.destroy
</code></pre>

<h2 id="label-Validations">Validations</h2>

<p>Active Record allows you to validate the state of a model before it gets
written into the database. There are several methods that you can use to
check your models and validate that an attribute value is not empty, is
unique and not already in the database, follows a specific format and many
more.</p>

<p>Validation is a very important issue to consider when persisting to
database, so the methods <code>create</code>, <code>save</code> and
<code>update</code> take it into account when running: they return
<code>false</code> when validation fails and they didn&#39;t actually
perform any operation on database. All of these have a bang counterpart
(that is, <code>create!</code>, <code>save!</code> and
<code>update!</code>), which are stricter in that they raise the exception
<code>ActiveRecord::RecordInvalid</code> if validation fails. <a
href="../../../../classes/A.html">A</a> quick example to illustrate:</p>

<pre><code>class User &lt; ActiveRecord::Base
  validates_presence_of :name
end

User.create  # =&gt; false
User.create! # =&gt; ActiveRecord::RecordInvalid: Validation failed: Name can&#39;t be blank
</code></pre>

<p>You can learn more about validations in the <a
href="http://active_record_validations.html">Active Record Validations
guide</a>.</p>

<h2 id="label-Callbacks">Callbacks</h2>

<p>Active Record callbacks allow you to attach code to certain events in the
life-cycle of your models. This enables you to add behavior to your models
by transparently executing code when those events occur, like when you
create a new record, update it, destroy it and so on. You can learn more
about callbacks in the <a href="http://active_record_callbacks.html">Active
Record Callbacks guide</a>.</p>

<h2 id="label-Migrations">Migrations</h2>

<p><a href="../../../../classes/Rails.html">Rails</a> provides a
domain-specific language for managing a database schema called migrations.
Migrations are stored in files which are executed against any database that
Active Record support using <code>rake</code>. Here&#39;s a migration that
creates a table:</p>

<pre><code>class CreatePublications &lt; ActiveRecord::Migration
  def change
    create_table :publications do |t|
      t.string :title
      t.text :description
      t.references :publication_type
      t.integer :publisher_id
      t.string :publisher_type
      t.boolean :single_issue

      t.timestamps
    end
    add_index :publications, :publication_type_id
  end
end
</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> keeps track of which
files have been committed to the database and provides rollback features.
To actually create the table, you&#39;d run <code>rake db:migrate</code>
and to roll it back, <code>rake db:rollback</code>.</p>

<p>Note that the above code is database-agnostic: it will run in MySQL,
postgresql, Oracle and others. You can learn more about migrations in the
<a href="http://migrations.html">Active Record Migrations guide</a></p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>