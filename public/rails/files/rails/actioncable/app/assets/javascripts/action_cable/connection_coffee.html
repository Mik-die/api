<!DOCTYPE html>
<html lang="en">
<head>
    <title>connection.coffee</title>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="../../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>
    <div class="banner">
        
        <h1>
            connection.coffee
        </h1>
        <ul class="files">
            
            <li>
                rails/actioncable/app/assets/javascripts/action_cable/connection.coffee
                
                    <a href="https://github.com/rails/rails/blob/45b6b7f57f1a2eb757eb612fcc94e42d5908ec21/actioncable/app/assets/javascripts/action_cable/connection.coffee" target="_blank" class="github_url">on GitHub</a>
                
            </li>
            <li>Last modified: 2019-08-09 23:12:34 +0300</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>#= require ./connection_monitor</p>

<p># Encapsulate the cable connection held by the consumer. This is an internal class not intended for direct user manipulation.</p>

<p>{message_types, protocols} = <a href="../../../../../../../classes/ActionCable.html"><code>ActionCable</code></a>.INTERNAL</p>
<dl class="rdoc-list label-list"><dt>supportedProtocolsâ€¦, unsupportedProtocol
<dd>
<h1 id="label-protocols">protocols</h1>
</dd></dl>

<p>class <a href="../../../../../../../classes/ActionCable.html"><code>ActionCable</code></a>.Connection</p>

<pre><code>@reopenDelay: 500

constructor: (@consumer) -&gt;
  {@subscriptions} = @consumer
  @monitor = new ActionCable.ConnectionMonitor this
  @disconnected = true

send: (data) -&gt;
  if @isOpen()
    @webSocket.send(JSON.stringify(data))
    true
  else
    false

open: =&gt;
  if @isActive()
    ActionCable.log(&quot;Attempted to open WebSocket, but existing socket is #{@getState()}&quot;)
    false
  else
    ActionCable.log(&quot;Opening WebSocket, current state is #{@getState()}, subprotocols: #{protocols}&quot;)
    @uninstallEventHandlers() if @webSocket?
    @webSocket = new ActionCable.WebSocket(@consumer.url, protocols)
    @installEventHandlers()
    @monitor.start()
    true

close: ({allowReconnect} = {allowReconnect: true}) -&gt;
  @monitor.stop() unless allowReconnect
  @webSocket?.close() if @isActive()

reopen: -&gt;
  ActionCable.log(&quot;Reopening WebSocket, current state is #{@getState()}&quot;)
  if @isActive()
    try
      @close()
    catch error
      ActionCable.log(&quot;Failed to reopen WebSocket&quot;, error)
    finally
      ActionCable.log(&quot;Reopening WebSocket in #{@constructor.reopenDelay}ms&quot;)
      setTimeout(@open, @constructor.reopenDelay)
  else
    @open()

getProtocol: -&gt;
  @webSocket?.protocol

isOpen: -&gt;
  @isState(&quot;open&quot;)

isActive: -&gt;
  @isState(&quot;open&quot;, &quot;connecting&quot;)

# Private

isProtocolSupported: -&gt;
  @getProtocol() in supportedProtocols

isState: (states...) -&gt;
  @getState() in states

getState: -&gt;
  return state.toLowerCase() for state, value of WebSocket when value is @webSocket?.readyState
  null

installEventHandlers: -&gt;
  for eventName of @events
    handler = @events[eventName].bind(this)
    @webSocket[&quot;on#{eventName}&quot;] = handler
  return

uninstallEventHandlers: -&gt;
  for eventName of @events
    @webSocket[&quot;on#{eventName}&quot;] = -&gt;
  return

events:
  message: (event) -&gt;
    return unless @isProtocolSupported()
    {identifier, message, type} = JSON.parse(event.data)
    switch type
      when message_types.welcome
        @monitor.recordConnect()
        @subscriptions.reload()
      when message_types.ping
        @monitor.recordPing()
      when message_types.confirmation
        @subscriptions.notify(identifier, &quot;connected&quot;)
      when message_types.rejection
        @subscriptions.reject(identifier)
      else
        @subscriptions.notify(identifier, &quot;received&quot;, message)

  open: -&gt;
    ActionCable.log(&quot;WebSocket onopen event, using &#39;#{@getProtocol()}&#39; subprotocol&quot;)
    @disconnected = false
    if not @isProtocolSupported()
      ActionCable.log(&quot;Protocol is unsupported. Stopping monitor and disconnecting.&quot;)
      @close(allowReconnect: false)

  close: (event) -&gt;
    ActionCable.log(&quot;WebSocket onclose event&quot;)
    return if @disconnected
    @disconnected = true
    @monitor.recordDisconnect()
    @subscriptions.notifyAll(&quot;disconnected&quot;, {willAttemptReconnect: @monitor.isRunning()})

  error: -&gt;
    ActionCable.log(&quot;WebSocket onerror event&quot;)
</code></pre>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
    
    
    
  
</div>

    </div>
  </body>
</html>
